<!DOCTYPE html>

<html>
    <head>
        <meta charset="utf-8">
        <title>CS230|Calvin Li</title>
        <link rel="stylesheet" href="./bootstrap-3.3.7-dist/css/bootstrap.css">
        <link rel="stylesheet" href="./css/style.css">
        <link rel="stylesheet" href="./css/note.css">
        <link rel="stylesheet" href="./css/cs230use.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:400,800" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Crimson+Text:600,600i" rel="stylesheet"> <!-- for math use -->
        <link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/hack-font/build/web/hack.css'> <!-- HACK!!! -->
        <!-- stylesheet found from w3school. (icon use)-->
        <link rel = "stylesheet" href = "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    </head>
    
    <body class="cs230">
        
        <nav class="navbar navbar-inverse navbar-fixed-top">
            <div class="container-fluid">
                <!-- Brand and toggle get grouped for better mobile display -->
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#topNavbar" aria-expanded="false">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="./index.html">Calvin Li</a>
                </div>

                <!-- Collect the nav links, forms, and other content for toggling -->
                <div class="collapse navbar-collapse" id="topNavbar">
                    <ul class="nav navbar-nav">
                        <li><a href="./doc/NewResume_CKLI.pdf" target="_blank;">Résumé</a></li>
                    </ul>
                    <ul class="nav navbar-nav navbar-right">
                        <li><a href="./about.html">About</a></li>
                        <li><a href="./projects.html">Projects</a></li>
                        <li class="courseNote">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Course Notes<span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <li><a href="./cs230.html">CS 230</a></li>
                                <li><a href="./cs246.html">CS 246</a></li>
                            </ul>
                        </li>
                    </ul>
                </div><!-- /.navbar-collapse -->
            </div><!-- /.container-fluid -->
        </nav>
        
        <br><br><br>
        
        <div class="container">
            
            <br>
            <table class="header">
                <tr>
                    <td colspan="100%">
                        <h1 class="title">CS 230 - Introduction to Computers and Computer Systems</h1>
                    </td>
                </tr>
                <tr>
                    <th colspan="5%">Instructor:</th>
                    <td colspan="95%">Rob Hackman</td>
                </tr>
                <tr>
                    <th colspan="5%">Office:</th>
                    <td colspan="95%">DC2551A</td>
                </tr>
                <tr>
                    <th colspan="5%">Email:</th>
                    <td colspan="95%"><a href = "mailto: r2hackma@uwaterloo.ca" target = "_blank;">r2hackma@uwaterloo.ca</a></td>
                </tr>
                <tr>
                    <th colspan="5%">Website:</th>
                    <td colspan="95%">
                        <a href="https://www.student.cs.uwaterloo.ca/~cs230/" target="_blank;">https://www.student.cs.uwaterloo.ca/~cs230/</a>
                    </td>
                </tr>
                <tr>
                    <th colspan="5%">Note:</th>
                    <td>All program codes in this course notes are provided by Prof. Hackman during class.</td>
                </tr>
            </table>
            <hr>
         
            <section id="lec15">
                <h3>Lecture 15 - 01/03/2018</h3>
                <hr>
                <b>Module 4 - Build and Execute</b>
                <p>
                    How do we really go from a high level language to a final executable binary file of our machine code instructions?<br><br>
                    Our classic tool chain is:
                </p>
                <ul>
                    <li>
                        <span class="key">Compiler</span>
                        <ul>
                            <li>It translates from a source language to a target language (usually high level to low level); this will produce assembly (compilers usually just create the final binary file). </li>
                        </ul>
                    </li>
                    <li><span class="key">Assembler</span>
                        <ul>
                            <li>It translates an assembly code program into a machine code object file.</li>
                        </ul>
                    </li>
                    <li>
                        <span class="key">Linker</span>
                        <ul>
                            <li>It combines multiple object files of machine code into a final executable file.</li>
                        </ul>
                    </li>
                    <li>
                        <span class="key">Loader</span>
                        <ul>
                            <li>It loads a program file into our main memory.</li>
                        </ul>
                    </li>
                    <li>
                        <span class="key">Library</span>
                        <ul>
                            <li>The special object files that can be added to your program either in the linking or loading phase.</li>
                        </ul>
                    </li>
                </ul>
                <p>
                    Notice that compiler, assembler and linker are for building and loader is for executing.<br>
                </p>
                <br>
                <b>The Compiler</b>
                <ul>
                    <li>translates a program from a <u>source</u> language to a <u>target language</u></li>
                    <li>typically from high language to low language</li>
                    <li>can be followed by an assembler to generate machine code</li>
                </ul>
                <p>
                    We usually breaks our compilation up into steps: these steps can be even subdivided.
                </p>
                <ol>
                    <li>
                        <span class="key">Scanning/Lexical Analysis</span>
                        <ul>
                            <li><u>scanning</u> through the program and breaking it up into meaningful tokens</li>
                            <li>the tool that performs this step is called a <u>lexer</u></li>
                        </ul>
                    </li>
                    <li>
                        <span class="key">Parsing/Syntax Analysis</span>
                        <ul>
                            <li>check that the sequences of tokens provided by our lexer is meaningful (does it follow the rules of our languages?)</li>
                            <li>the tool that performs parsing is called a <u>parser</u></li>
                        </ul>
                    </li>
                    <li>
                        <span class="key">Semantic Analysis</span>
                        <ul>
                            <li>gather information needed for the execution of the program from the source code</li>
                            <li>create a <u>symbol table</u> and do type checking</li>
                        </ul>
                    </li>
                    <li>
                        <span class="key">Code Generation</span>
                        <ul>
                            <li>generate the target language copy of this code</li>
                        </ul>
                    </li>
                </ol>
                <br>
                <b>Scanning/Lexical Analysis (Tokenizing)</b>
                <ul>
                    <li>ultimately convert our program into a stream of tokens</li>
                    <li><span class="key">tokens</span>: symbolic representations of parts of our program
                        <ul>
                            <li>keywords: <code>for</code>, <code>if</code>, <code>while</code>, etc.</li>
                            <li>operators: <code>+</code>, <code>-</code>, <code>==</code>, etc.</li>
                            <li>literals (constants): <code>500</code>, <code>2.5</code>, <code>"hello"</code>, etc.</li>
                            <li>delimiters (separates): <code>{</code>, <code>(</code>, <code>;</code>, etc.</li>
                            <li>identifiers (variable name): <code>minAddress</code>, <code>x</code>, etc.</li>
                        </ul>
                    </li>
                </ul>
                <p>
                    How to identify a valid identifier? Literal?<br>
                    We use specific methods of pattern matching comes from the theory of formal languages.<br>
                    <br>
                    What is a formal language? It is defined by:
                </p>
                <ul>
                    <li>A alphabet is a set of symbols that can be used to from the "words" of our language.</li>
                    <li>A set of rules that determines how characters from our alphabet can be combined to create "words".</li>
                    <li>There are specific kinds of formal languages and strict mathematical notations for defining them.</li>
                    <li>One specific type of formal language is a <u>regular language</u> and three different ways of representing a regular language are:
                        <ul>
                            <li>Deterministic Finite Automate (DFA)</li>
                            <li>Na-Deterministic Finite Automate (NFA)</li>
                            <li>Regular Expressions (RegEx)</li>
                        </ul>
                        All of these can match any regular language, and they are all mathematically equivalent structures.
                    </li>
                </ul>
                <br>
                <b>Deterministic Finite Automate (DFA)</b>
                <p>
                    A Deterministic Finite Automate (DFA) is a state machine.<br>
                    It is also called a Deterministic Finite State Machine (DFSM).<br>
                </p>
                <ul>
                    <li>has a finite set of states
                        <ul>
                            <li>a initial state</li>
                            <li>a non-empty set of accepting (terminal states)</li>
                        </ul>
                    </li>
                    <li>finite set of input symbols (alphabet)</li>
                    <li>A transition function (function from state-symbol pairs to state)
                        <ul>
                            <li>Example: <code>(S1, a ,S2)</code> if in state <code>S1</code> and receive input <code>'a'</code>, go to state <code>S2</code>.</li>
                        </ul>
                    </li>
                </ul>
                <p>
                    A DFA determines whether a given input string is part of your regular language (accepted) if you end in an accepting state after reading the input.<br>
                    Example: A DFA that accepts <code>beq</code>.
                </p>
                <img src="./image/cs230/lec15/15_1.png">
                <br><br>
                <ul>
                    <li><code>q<sub>0</sub></code> is our initial state</li>
                    <li><code>q<sub>3</sub></code> is an accepting state</li>
                    <li>transition labels show the input that causes that transition to be taken
                        <ul>
                            <li>CANNOT have 2 transitions FROM the same state that accept the same input</li>
                        </ul>
                    </li>
                </ul>
                <br>
                <b>Na-Deterministic Finite Automate (NFA)</b>
                <ul>
                    <li>CAN have many transition from the same state with the same input</li>
                    <li>CAN have transitions that require no input (called &epsilon;-transitions)</li>
                    <li>may be easier to create (but can be easier to make mistakes) and also harder to check if a string is part of your language</li>
                    <li>can always create an equivalent DFA to any NFA</li>
                </ul>
                <img src="./image/cs230/lec15/15_2.png">
                <p>
                    A Bit harder to evaluate if any given string is in your regular language.<br>
                    Example: <code>"00"</code> could end in <code>q<sub>0</sub></code>, <code>q<sub>1</sub></code> or <code>q<sub>2</sub></code> depending on the transitions you take.<br>
                    So long a string can end on an accepting state then it is accepted.<br>
                    It accepts any binary numbers that end in two 0's, or equivalently any binary number that is divisible by 4.<br>
                </p>
                <br>
                <b>Regular Expressions (RegEx)</b>
                <p>
                    A sequence of regular symbols and meta symbols that describes a regular language. The empty string is denoted &epsilon;.
                </p>
                <br>
                <b>Our Meta Characters</b>
                <ul>
                    <li>
                        <code>|</code> means "or", separates alternatives
                        <ul>
                            <li>Example: <code>hello|hi</code> accepts the string <code>hello</code> or the string <code>hi</code></li>
                        </ul>
                    </li>
                    <li>
                        <code>()</code> means "grouping", used to define scope/precedence of our operators
                        <ul>
                            <li>Example: <code>honor|honour</code> is equivalent to <code>hon(o|ou)r</code></li>
                        </ul>
                    </li>
                    <li><code>[]</code> matches any one symbol included in the brackets
                        <ul>
                            <li><code>[^]</code> matches any one symbol NOT in the brackets</li>
                            <li>Example: <code>[aeiou]</code> matches one real vowel</li>
                            <li>Example: <code>[a-z]</code> specifies the range of lowercase alphabet chars, basically is <code>[abcd...z]</code></li>
                            <li>Example: <code>[^0-9]</code> any non-digit characters</li>
                            <li>Example: <code>[a-zA-Z]</code> any alphabetical characters <code>[abc...zABC...Z]</code></li>
                        </ul>
                    </li>
                    <li><code>.</code> (period) represents ANY one characters</li>
                    <li><code>*</code> matches 0 or more of the previous character or pattern
                        <ul>
                            <li>Example: <code>Hell*o</code> matches {Helo, Hello, Helllo, Hellllo, etc.}</li>
                            <li>Example: <code>[0-9]*</code> matches {&epsilon;, any natural number}</li>
                            <li>Example: <code>.*</code> matches <u>ANY</u> string including the empty string</li>
                        </ul>
                    </li>
                    <li><code>+</code> matches 1 or more of the previous character or pattern
                        <ul>
                            <li>Example: <code>[0-9]+</code> any natural number</li>
                            <li>Example: <code>.+</code> any non-empty string</li>
                        </ul>
                    </li>
                    <li><code>?</code> matches 0 or 1 of the previous character or pattern
                        <ul>
                            <li>Example: <code>Honou?r</code> is same as <code>Hon(o|ou)r</code></li>
                        </ul>
                    </li>
                    <li><code>\</code> is escape character, use this before a meta character to literally match that meta character, not have special behaviours.</li>
                </ul>
                <br>
                <p>
                    Examples:<br>
                    <code>a*</code> = {&epsilon;, a, aa, aaa, aaaa, ...}
                </p>
                <img src="./image/cs230/lec15/15_3.png">
                <br><br>
                <p>
                    <code>.+</code> = set of all non empty strings
                </p>
                <img src="./image/cs230/lec15/15_4.png">
                <p>
                    Notice that &Sigma; represents our alphabet, so here it means any charcter from our alphabet.<br>
                    <br>
                    <code>colou?r</code> = {colour, color}
                </p>
                <img src="./image/cs230/lec15/15_5.png">
                <br><br>
                <p>
                    Example:<br>
                    How to write a regular expression that matches ANY string that contains exactly one <code>a</code> character, regardless of case (one A or a, that's is)?<br>
                    Let's think about it. What defines a string with exactly <code>a</code>, can we break it up into components?<br>
                </p>
                <ul>
                    <li>a string of non-A characters (may be empty)</li>
                    <li>an <code>A</code> or an <code>a</code></li>
                    <li>a string of non-A characters (may be empty)</li>
                </ul>
                <p>
                    Answer: <code>[^aA]*[aA][^aA]*</code>
                </p>
            </section>
            <hr>
            
            <section id="lec16">
                <h3>Lecture 16 - 06/03/2018</h3>
                <hr>
                <p>
                    Recall:<br>
                    We were talking about regular language to solve our problem of tokenization (lexing/scanning).<br>
                    <br>
                    We discussed 3 constructs for defining a regular language - DFA, NFA and RegEx.<br>
                    <br>
                    Example: All strings that contain exactly one 'A' character (regardless of case).<br>
                    Solution: <code>[^aA]*[aA][^aA]*</code>
                </p>
                <img src="./image/cs230/lec16/16_1.png">
                <br><br>
                <p>
                    What does the regular expression <code>([1-9]|1[0-2]):[0-5][0-9](AM|PM)?</code> accept?<br>
                    12 hour clock time, you may or may not be told if it is AM or PM.<br>
                </p>
                <img src="./image/cs230/lec16/16_2.png">
                <br>
                <img src="./image/cs230/lec16/16_3.png">
                <br>
                <p>
                    Let's write a regEx that accepts real numbers. Our real number can be just a decimal number or can be a decimal number following by 'E' then an integer.<br>
                    What are our cases? Let <span class="math">x, y, z &isin; sequence of digit</span>.
                </p>
                <ul>
                    <li class="math">x.y</li>
                    <li class="math">x.yEz</li>
                    <li class="math">x.y-z</li>
                    <li class="math">-x.y</li>
                    <li class="math">-x.yEz</li>
                    <li class="math">-x.yE-z</li>
                </ul>
                <p>
                    Answer: <code>-?[0-9]+\.[0-9]+(E-?[0-9]+)?</code>
                </p>
                <img src="./image/cs230/lec16/16_4.png">
                <br><br>
                <p>
                    Splitting our input stream: How to tokenize <code>if17</code>?
                </p>
                <ul>
                    <li>one token, identifier (variable name) <code>if17</code></li>
                    <li>variable name <code>if1</code> followed by literal 7</li>
                    <li>keyword <code>if</code> followed by literal 17</li>
                    <li>keyword <code>if</code> followed by literal 1, followed by literal 7</li>
                    <li>variable name <code>i</code> followed by variable name "f17"</li>
                    <li>e.t.c.</li>
                </ul>
                <p>
                    To solve conflicting rules (is <code>if</code> the keyword or variable name), the rule that is written first takes priority.<br>
                    <br>
                    To solve cases where an input could be broken up multiple times by some of rules, the longest match is taken (<code>17</code> is <code>17</code>, not <code>1</code> then <code>7</code>).<br>
                    <br>
                    If the input doesn't match any of our rules, then it is not part of our language.<br>
                    In the context of compiling:
                </p>
                <ul>
                    <li>the code will not compile</li>
                    <li>you will receive an error message</li>
                    <li>stop executing, skip characters until valid input is reached again, and keep going - so that all the syntax errors can be printed our when found</li>
                </ul>
                <p>
                    After the scanner's execution, there is a sequence of valid tokens (e.g. a series of correctly spelled words in English).<br>
                </p>
                <br>
                <b>Parsing</b>
                <ul>
                    <li>analyse the sequence of tokens and verify that it follows the rules of our language
                        <ul>
                            <li>e.g. Does that sequence of correctly spelled rules follow the rules of grammar?</li>
                        </ul>
                    </li>
                    <li>report errors if not</li>
                    <li>create an <span class="keyword">Abstract Syntax Tree (AST)</span></li>
                </ul>
                <p>
                    So, we need some way to state the rules of our language, regular languages are not sufficient.<br>
                    We want a way to specify our language that is:
                </p>
                <ul>
                    <li>simple for humans</li>
                    <li>unlike human languages, must be unambiguous
                        <ul><li>a sentence can have <u>only one</u> meaning</li></ul>
                    </li>
                </ul>
                <p>
                    Example:<br>
                    1. "It's unpleasantly like being drunk."<br>
                    2. "What;s so unpleasant about being drunk?"<br>
                    1. You ask a glass of water.<br>
                    It must be easy to build parsing tools for that language.<br>
                    <br>
                    We want a formal language that is defined by what is called a "Context-Free Grammar" (CFG).<br>
                </p>
                <br>
                <b>Context-Free Grammar (CFG)</b>
                <p>The components of CFG are:</p>
                <ul>
                    <li><span class="keyword">terminal symbols</span>: actual symbols that appear in our language
                        <ul>
                            <li>the set of our terminal symbols can be thought of as our alphabet</li>
                        </ul>
                    </li>
                    <li><span class="keyword">nonterminals</span>: abstract component of our language, we can think of them as variable names
                        <ul>
                            <li>nonterminals themselves don't literally appear in our input</li>
                            <li>one nonterminal is chosen as our "start symbol" where all valid "sentences" of our language begin</li>
                            <li>denoted <code>&lt;NTName&gt;</code></li>
                        </ul>
                    </li>
                    <li><span class="keyword">production rules</span>
                        <ul>
                            <li>rules of expansion of our nonterminals into one or more terminals and/or nonterminals</li>
                            <li>more than one rule per nonterminal is allowed, alternatives are separated with <code>|</code> (the pipe character)</li>
                            <li>notation is <code>&lt;NTName&gt; -&gt; Expansion1|Expansion2</code></li>
                        </ul>
                    </li>
                </ul>
                <br>
                <b>Deriving Input Strings</b>
                <ul>
                    <li>application of production rules to generate valid input string
                        <ul>
                            <li>starting with our start symbol, repeatedly replace one nonterminal with <u>one</u> of its expansions</li>
                            <li>continue until all nonterminals are gone</li>
                            <li>resulting sequence of terminals is a valid or syntactically correct input string</li>
                            <li>formal definition of our language is all valid sequences that can be derived from our start symbol following our rules of production</li>
                            <li>systematic approach is to always expand the left-most nonterminal</li>
                        </ul>
                    </li>
                </ul>
                <p>
                    Example:<br>
                    Simple language that accepts <code>if</code> and <code>while</code> constructs and only values 0 or 1 as our conditions. An <code>if</code> or <code>while</code> can be defined as:<br>
                </p>
                <ul>
                    <li>either the keyword <code>if</code> or <code>while</code></li>
                    <li>after the keyword, we see an opening parenthesis <code>(</code> then a 0 or a 1, and then <code>)</code></li>
                    <li>after the conditional, we see <code>{</code> then any number of <code>if</code> or <code>while</code> statement then a <code>}</code></li>
                    <li>Terminals: while if 0 1 ( ) { }</li>
                    <li>Starting nonterminal: &lt;statement&gt;</li>
                </ul>
                <img src="./image/cs230/lec16/16_5.png"  align="left" class="leftMargin">
                <span>
                    <pre><code>
                        &lt;statement&gt; &rarr; &lt;keyword&gt;&lt;condition&gt;&lt;block&gt;<br>
                        &lt;condition&gt; &rarr; (0)|(1)<br>
                        &lt;keyword&gt; &rarr; while|if<br>
                        &lt;block&gt; &rarr; {&lt;blockComponent&gt;}<br>
                        &lt;blockComponent&gt; &rarr; &epsilon;|&lt;statement&gt; &lt;blockComponent&gt;<br>
                        <br>
                        // Example derivation of<br>
                        <span class="cline">01&nbsp;&nbsp;</span> while (1) {<br>
                        <span class="cline">02&nbsp;&nbsp;</span> &nbsp;&nbsp;if (0) {}<br>
                        <span class="cline">03&nbsp;&nbsp;</span> }<br>
                    </code></pre>
                </span>
                <p>
                    Stat at our start NT:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span> &lt;statement&gt;<br>
                        <span class="cline">02&nbsp;&nbsp;</span> &lt;keyword&gt; &lt;condition&gt; &lt;block&gt;<br>
                        <span class="cline">03&nbsp;&nbsp;</span> while &lt;condition&gt; &lt;block&gt;<br>
                        <span class="cline">04&nbsp;&nbsp;</span> while (1) &lt;block&gt; <br>
                        <span class="cline">05&nbsp;&nbsp;</span> while (1) {&lt;blockComponent&gt;}<br>
                        <span class="cline">06&nbsp;&nbsp;</span> while (1) {&lt;statement&gt; &lt;blockComponent&gt;}<br>
                        <span class="cline">07&nbsp;&nbsp;</span> while (1) {&lt;keyword&gt; &lt;condition&gt; &lt;block&gt; &lt;blockComponent&gt;} <br>
                        <span class="cline">08&nbsp;&nbsp;</span> while (1) {if &lt;condition&gt; &lt;block&gt; &lt;blockComponent&gt;} <br>
                        <span class="cline">09&nbsp;&nbsp;</span> while (1) {if (0) &lt;block&gt; &lt;blockComponent&gt;}<br>
                        <span class="cline">10&nbsp;&nbsp;</span> while (1) {if (0) {&lt;blockComponent&gt;} &lt;blockComponent&gt;}<br>
                        <span class="cline">11&nbsp;&nbsp;</span> while (1) {if (0) {} &lt;blockComponent&gt;}<br>
                        <span class="cline">12&nbsp;&nbsp;</span> while (1) {if (0) {}}<br>
                    </code></pre>
                </span>
            </section>
            <hr>
            
            <section id="lec17">
                <h3>Lecture 17 - 08/03/2018</h3>
                <hr>
                <p>Recall from last lecture...</p>
                <span>
                    <pre><code>
                        &lt;statement&gt; &rarr; &lt;keyword&gt; &lt;condition&gt; &lt;block&gt;<br>
                        &lt;keyword&gt; &rarr; while|if<br>
                        &lt;condition&gt; &rarr; (1)|(0)<br>
                        &lt;block&gt; &rarr; {&lt;blockComponent&gt;}<br>
                        &lt;blockComponent&gt; &rarr; &epsilon;|&lt;statement&gt; &lt;blockComponent&gt;<br>
                        <br>
                        // example: Statement (1)<br>
                        <span class="cline">01&nbsp;&nbsp;</span> while (1) {<br>
                        <span class="cline">02&nbsp;&nbsp;</span> &nbsp;&nbsp;if (0) {}<br>
                        <span class="cline">03&nbsp;&nbsp;</span> }<br>
                    </code></pre>
                </span>
                <p>
                    So we want our parser to produce an AST. It can be hard for a human to go straight from a grammar to an AST. Thus, we will also discuss a parse tree and how it differs from an AST.<br> 
                    <br>
                    A parse tree:
                </p>
                <ul>
                    <li>explicitly encodes the entirety of your derivation</li>
                    <li>has your non-terminals as the internal nodes</li>
                    <li>root of your tree is the start non-terminal</li>
                    <li>children of nodes are given by the production rules</li>
                    <li>has your terminals as leaf nodes</li>
                </ul>
                <br>
                <p>While an AST:</p>
                <ul>
                    <li>implicitly encodes as much information as possible in the structure of the idea</li>
                    <li>doesn't explicitly include non-terminals</li>
                    <li>simple to interpret/work with</li>
                </ul>
                <p>
                    For our statement (1), the parse tree and AST are...
                </p>
                <img src="./image/cs230/lec17/17_1.png">
                <br>
                <p>
                    If we did have multiple statements in our block, in an AST, we would essentially have an empty node as the right child of the <code>if</code> or <code>while</code>.<br>
                    Example: <code>while (1) {if (0) {} while (0) {}}</code>
                </p>
                <img src="./image/cs230/lec17/17_2.png">
                <br>
                <p>
                    Let's consider another example.<br>
                    A CFG for the input to a basic integers calculator. We want to support subtraction, addition, multiplication, division and parentheses.<br>
                    <br>
                    Grammar (E1):
                </p>
                <ul>
                    <li>Tokens: <code>*</code>, <code>+</code>, <code>-</code>, <code>/</code>, <code>(</code>, <code>)</code>, and integer constants</li>
                    <li>Start with non-terminal <code>&lt;expr&gt;</code> (expression)</li>
                </ul>
                <span>
                    <pre><code>
                        &lt;expr&gt; &rarr; &lt;term&gt; &lt;more terms&gt;<br>
                        &lt;term&gt; &rarr; &lt;factor&gt; &lt;more factors&gt;<br>
                        &lt;factor&gt; &rarr; &lt;expr&gt;|int<br>
                        &lt;more Terms&gt; &rarr; + &lt;term&gt; &lt;more terms&gt;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| - &lt;term&gt; &lt;more terms&gt;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &epsilon;<br>
                        &lt;more factors&gt; &rarr; * &lt;factor&gt; &lt;more factors&gt;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| /  &lt;factor&gt; &lt;more factors&gt;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &epsilon;<br>
                    </code></pre>
                </span>
                <br>
                <p>Example: Leftmost derivation of <code span="math">7 + 34</code>.</p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span> &lt;expr&gt;<br>
                        <span class="cline">02&nbsp;&nbsp;</span> &lt;term&gt; &lt;more terms&gt;<br>
                        <span class="cline">03&nbsp;&nbsp;</span> &lt;factor&gt; &lt;more factors&gt; &lt;more terms&gt;<br>
                        <span class="cline">04&nbsp;&nbsp;</span> 7 &lt;more factors&gt; &lt;more terms&gt;<br>
                        <span class="cline">05&nbsp;&nbsp;</span> 7 &lt;more terms&gt;<br>
                        <span class="cline">06&nbsp;&nbsp;</span> 7 + &lt;term&gt; &lt;more terms&gt;<br>
                        <span class="cline">07&nbsp;&nbsp;</span> 7 + &lt;factor&gt; &lt;more factors&gt; &lt;more terms&gt;<br>
                        <span class="cline">08&nbsp;&nbsp;</span> 7 + 34 &lt;more factors&gt; &lt;more terms&gt;<br>
                        <span class="cline">09&nbsp;&nbsp;</span> 7 + 34 &lt;more terms&gt;<br>
                        <span class="cline">10&nbsp;&nbsp;</span> 7 + 34<br>
                    </code></pre>
                </span>
                <img src="./image/cs230/lec17/17_3.png">
                <br>
                <p>
                    We must consider a couple other factors other than just having our CFG be unambiguous.<br>
                    Two things of concern are associativity and precedence of our operators.<br>
                </p>
                <ul>
                    <li>
                        <span span="keyword">Associativity</span>: grouping of our equivalent operators
                        <ul>
                            <li>
                                <span class="math">6 - 3 + 4</span> could be read left or right associative, respectively <span class="math">(6 - 3) + 4</span> or <span class="math">6 - (3 + 4)</span>
                            </li>
                            <li>
                                For integer division, associativity is very important. So by definition, division is left-associative.
                                <ul>
                                    <li>
                                        <span class="math">6 / 3 / 2</span> if interpreted right-associative: <span class="math">6 / (3 / 2)</span> &rarr; <span class="math">6 / 1</span> &rarr; <span class="math">6</span>
                                    </li>
                                    <li>
                                        <span class="math">6 / 3 / 2</span> if interpreted left-associative <span class="math">(6 / 3) / 2</span> &rarr; <span class="math">2 / 2</span> &rarr; <span class="math">1</span>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <span span="keyword">Precedence</span>: which operators "bind together", who should get executed first
                    </li>
                </ul>
                <p>
                    Example: Our parse tree for <span class="math">6 / 3 / 2</span> following with <code>E1</code> is...
                </p>
                <img src="./image/cs230/lec17/17_4.png">
                <br>
                <p>
                    This is right associative! This is NOT good!<br>
                    <br>
                    So we rewrite our grammar to be left associative. We do this by having our expressions <i>ALWAYS</i> recurse on the left hand side of the operator and the right hand side being a terminal, atomic expression in parentheses.<br>
                    <br>
                    New Grammar (E2), start non-terminal <code>&lt;expr&gt;</code>.
                </p>
                <span>
                    <pre><code>
                        &lt;expr&gt; &rarr; &lt;expr&gt; + &lt;term&gt;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &lt;expr&gt; - &lt;term&gt;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &lt;expr&gt; * &lt;term&gt;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &lt;expr&gt; / &lt;term&gt;<br>		  
                        &lt;term&gt; &rarr; int<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (&lt;expr&gt;)<br>
                    </code></pre>
                </span>
                <br>
                <p>So deriving <span class="math">6 / 3 / 2</span> with <code>E2</code> we get:</p>
                <img src="./image/cs230/lec17/17_5.png">
                <br>
                <p>
                    Precedence is obviously also important.<br>
                    Example: <span class="math">2 + 3 * 4</span> is <span class="math">2 + (3 * 4)</span> not <span class="math">(2 + 3) * 4</span>.<br>
                </p>
                <img src="./image/cs230/lec17/17_6.png">
                <br>
                <p>
                    This derives to <span class="math">(2 + 3) * 4</span>!!! This is NOT good!!!<br>
                    <br>
                    New, Grammar <code>E3</code>.<br>
                    To enforce precedence, we order our rules from least to most precedence.<br> 
                </p>
                <span>
                    <pre><code>
                        &lt;expr&gt; &rarr; &lt;term&gt; + &lt;term&gt;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &lt;term&gt; - &lt;term&gt;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &lt;term&gt;<br>
                        &lt;term&gt; &rarr; &lt;term&gt; * &lt;factor&gt;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &lt;term&gt; / &lt;factor&gt;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &lt;factor&gt;<br>
                        &lt;factor&gt; &rarr; (&lt;expr&gt;)<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| int<br>
                    </code></pre>
                </span>
                <p>
                    Let's derive <span class="math">2 + 3 * 4</span>.<br>
                </p>
                <img src="./image/cs230/lec17/17_7.png">
                <br><br>
                <b>Ambiguity</b>
                <p>
                    If a sentence can be interpreted more than one way, there exists two derivations for the same sentence.<br>
                    <br>
                    Grammar <code>E4</code>:<br>
                </p>
                <span>
                    <pre><code>
                        &lt;expr&gt; &rarr; &lt;term&gt; + &lt;term&gt;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &lt;term&gt; - &lt;term&gt;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &lt;factor&gt;<br>
                        &lt;factor&gt; &rarr; &lt;factor&gt; * &lt;factor&gt;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &lt;factor&gt; / &lt;factor&gt;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &lt;expr&gt;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| int<br>       
                    </code></pre>
                </span>
                <br>
                <p>Example: derive <span class="math">2 * 3 * 4</span> using <code>E4</code>.</p>
                <img src="./image/cs230/lec17/17_8.png">
                <br>
                <p>
                    Associativity of this language is ambiguous!<br>
                    <br>
                    Lastly, grammar <code>E5</code>:<br>
                </p>
                <span>
                    <pre><code>
                        &lt;expr&gt; &rarr; &lt;expr&gt; + &lt;expr&gt;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &lt;expr&gt; - &lt;expr&gt;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &lt;expr&gt; * &lt;expr&gt;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &lt;expr&gt; / &lt;expr&gt;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (&lt;expr&gt;)<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| int<br> 
                    </code></pre>
                </span>
                <br>
                <p>Example: derive <span class="math">2 + 3 * 4</span>.</p>
                <img src="./image/cs230/lec17/17_9.png">
                <br>
                <p>
                    Ambiguous Precedence!!!<br>
                    Associativity, precedence, ambiguity &rarr; why do we care?<br>
                </p>
                <ul>
                    <li>good specification of our language means a good free structure</li>
                    <li>good tree structure &rarr; correct evaluation for code generation</li>
                    <li>if ambiguous - which tree do we generate?</li>
                </ul>
                <p>
                    Encode precedence and associativity in your grammar.<br>
                    If we have an ambiguous grammar, we have no definitive output.<br>
                </p>
                <ul>
                    <li>certain ambiguities can be spotted easily
                        <ul><li>example: two same non-terminals in a rule</li></ul>
                    </li>
                    <li>
                        ultimately, undecidable problem
                        <ul>
                            <li>no method can exist that an answer "is this grammar ambiguous" for all grammars</li>
                        </ul>
                    </li>
                </ul>
                <br>
                <b>Parse Tree Evaluation</b>
                <ul>
                    <li>recursive tree traversal</li>
                    <li>evaluate current node <u>after</u> evaluating children (post-order traversal)</li>
                </ul>
                <p>
                    In order to ensure proper evaluation order...
                </p>
                <ul>
                    <li>arrange your non-terminal rules (have we fixed precedence?)</li>
                    <li>potentially introduce new non-terminals</li>
                </ul>
                <p>
                    That's parsing; the parser uses a CFG to check the validity of the input stream of tokens and produce an AST for the next steps.<br>
                    <br>
                    Last stages of Compiler - Semantic Analyzer<br>
                </p>
                <ul>
                    <li>create a symbol table
                        <ul>
                            <li>maps variable names/function/class names to relevant information</li>
                        </ul>
                    </li>
                    <li>type checking
                        <ul>
                            <li>
                                make sure operations are valid on the types passed in 
                                <ul>
                                    <li>example: can't add an integer and a string <code>5 + "hello"</code></li>
                                </ul>
                            </li>
                            <li>annotate the parse tree or AST with type information</li>
                        </ul>
                    </li>
                </ul>
            </section>
            <hr>
            
            <section id="lec18">
                <h3>Lecture 18 - 13/03/2018</h3>
                <hr>
                <img src="./image/cs230/lec18/18_1.png" class="textNextToImg">
                <p>
                    Evaluate a parse tree or AST, we do so with recursive tree traversal.<br>
                    Typically, post-order traversal.<br>
                </p>
                <br>
                <p>
                    If you're looking at Node N, first evaluate its left child, then its right child, then node N itself. (post-order traversal)<br>
                    <br>
                    In order to ensure proper evaluation order, our tree <u>must</u> have a good structure (proper associatively and precedence) to enforce a good structure:
                </p>
                <ol>
                    <li>carefully arrange your non-terminals in your rules</li>
                    <li>potentially introduce new non-terminals</li>
                </ol>
                <br>
                <b>Last Stage of Compilation</b>
                <ul>
                    <li>Semantic Analysis
                        <ul>
                            <li>Check extra semantic information not included in our token sequence or tree</li>
                            <li>
                                <span class="keyword">Type Checking</span>
                                <ul>
                                    <li>Example: It is valid to say (as per the rules of our grammar) <code>var1 = var2</code>, but if <code>var1</code> is an integer and <code>var2</code> is a string, this is invalid.</li>
                                </ul>
                            </li>
                            <li>Does the identifier being referenced actually exist at this point?
                                <ul>
                                    <li>Example: <code>len(myVar)</code> &rarr; If <code>myVar</code> does not exist then this is nonsensical</li>
                                </ul>
                            </li>
                            <li>
                                Builds the <u>symbol table</u> which keeps track of what identifiers exist in the current given scope and their type signatures.
                            </li>
                        </ul>
                    </li>
                    <li>
                        Code Generation
                        <ul>
                            <li>Generate the actual target language version of our source code.</li>
                        </ul>
                    </li>
                </ul>
                <p>
                    Last class we looked at 5 grammars, which <code>E4</code> and <code>E5</code> were purpose fully bad to show ambiguity.<br>
                    <code>E3</code> was our best grammar.<br>
                </p>
                <span>
                    <pre><code>
                        &lt;expr&gt; &rarr; &lt;term&gt; + &lt;term&gt;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &lt;term&gt; - &lt;term&gt;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &lt;term&gt;<br>
                        &lt;term&gt; &rarr; &lt;term&gt; * &lt;factor&gt;<br>
                         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &lt;term&gt; / &lt;factor&gt;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &lt;factor&gt;<br>
                        &lt;factor&gt; &rarr; (&lt;expr&gt;)<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| int<br>
                    </code></pre>
                </span>
                <br>
                <p>
                    Let's look at the derivation of <span class="math">10 * (1 + 2)</span>
                </p>
                <img src="./image/cs230/lec18/18_2.png">
                <br><br>
                <p>
                    The code generation is quite straightforward.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>addi $9,&nbsp;&nbsp;$0,&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;; eval left child of *<br>
                        <span class="cline">02&nbsp;&nbsp;</span>addi $10, $0,&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;; eval left child of +<br>
                        <span class="cline">03&nbsp;&nbsp;</span>addi $11, $0,&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;; eval right child of +<br>
                        <span class="cline">04&nbsp;&nbsp;</span>add  $10, $10, $11 ; eval +<br>
                        <span class="cline">05&nbsp;&nbsp;</span>mult $9,&nbsp;&nbsp;$10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; eval *<br>
                    </code></pre>
                </span>
                <p>
                    If instead of literals, we did have some sort of variables, we will have to keep track of where the variables are stored and use the equivalent operations with loads and stores.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>var1: .word 0<br>
                        <span class="cline">02&nbsp;&nbsp;</span>var2: .word 0<br>
                    </code></pre>
                </span>
                <p>
                    Code generation becomes slightly trickier when generating assembly for high level programming concepts; for example, loops, functions, classes, etc.<br>
                    In the end you just have to find a general form for the concept and generate with the given concepts.<br>
                    <br>
                    After code generation is done, we must now assemble.<br>
                    Assembler will:
                </p>
                <ol>
                    <li>do line by line translation of one assembly instruction to one (or more) machine code instructions</li>
                    <li>insert data for our <code>.word</code> directives</li>
                    <li>ignore any comments or blank lines</li>
                    <li>compute the addresses of each label and replace references to that label with that address</li>
                </ol>
                <p>
                    Example:
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>list&nbsp;&nbsp;$9 ----&rarr; &lt;binary represent of list $9&gt;<br>
                        <span class="cline">02&nbsp;&nbsp;</span>.word string &rarr; 000&hellip;&hellip;10100100<br>
                        &#8285;<br>
                        <span class="cline">41&nbsp;&nbsp;</span>jr $31 &rarr; 0000 0011 1110 0000<br>
                        <span class="cline">42&nbsp;&nbsp;</span>string: .word 0x41; ASCII for 'A' &rarr; 0001&hellip;&hellip;101001<br>
                        <span class="cline">43&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.word 0x00 --------------&rarr; 0000&hellip;&hellip;0000<br>
                    </code></pre>
                </span>
                <br>
                <b>Linker</b>
                <p>
                    Goal: combine multiple object files.<br>
                    <br>
                    Why break up our program into multiple files?<br>
                    It can avoid compiling our whole program every time we make a change, only compile the files that changed and re-link.<br>
                    <br>
                    Linker resolves <u>external symbols</u>: label that refers to other object file.<br>
                    For example, we could want to jump to a subroutine in another object file.<br>
                    <br>
                    Also, linker produces the final executable.<br>
                </p>
                <br>
                <b>Basics of Object File Format</b>
                <ul>
                    <li>file header (meta data)</li>
                    <li>text segment (actual code)</li>
                    <li>data segment (static data)</li>
                    <li>defined external symbols
                        <ul>
                            <li>our symbols that other object files can refer to</li>
                        </ul>
                    </li>
                    <li>undefined external symbols
                        <ul>
                            <li>symbols not defined here, we must find them in another object files' defined external symbols </li>
                        </ul>
                    </li>
                    <li>local symbols (debugging relocation)</li>
                </ul>
                <br>
                <b>Relocation</b>
                <p>
                    When assembler produces our object files, the code for each starts at address 0.<br>
                    How do we combine multiple files like this?
                </p>
                <ul>
                    <li>Relative addresses (e.g. branch) is not a problem.</li>
                    <li>Absolute addresses and static data must be fixed.
                        <ul>
                            <li>We have object file contain a list of such code locations.</li>
                        </ul>
                    </li>
                    <li>Adjust Actual addresses in object code.</li>
                </ul>
                <p>Example:</p>
                <table class="textTable">
                    <tr>
                        <th colspan="2">File A</th>
                        <td colspan="2">&nbsp;</td>
                        <th colspan="2">File B</th>
                    </tr>
                    <tr>
                        <td>0</td>
                        <td><code>&hellip;&hellip;</code></td>
                        <td colspan="2"></td>
                        <td>0</td>
                        <td><code>&hellip;&hellip;</code></td>
                    </tr>
                    <tr>
                        <td colspan="2"><code>&hellip;&hellip;</code></td>
                        <td colspan="2"></td>
                        <td colspan="2"><code>&hellip;&hellip;</code></td>
                    </tr>
                    <tr>
                        <td>64</td>
                        <td><code>jar mySubroutine</code></td>
                        <td colspan="2"></td>
                        <td>42</td>
                        <td><code>mySubroutine: addi &hellip;&hellip;</code></td>
                    </tr>
                    <tr>
                        <td colspan="2"><code>&hellip;&hellip;</code></td>
                        <td colspan="2"></td>
                        <td colspan="2"><code>&hellip;&hellip;</code></td>
                    </tr>
                    <tr>
                        <td>99</td>
                        <td><code>jr $31</code></td>
                        <td colspan="2"></td>
                        <td colspan="2"><code>&hellip;&hellip;</code></td>
                    </tr>
                </table>
                <br>
                <p>
                    Imagine we just stack there files on top of each other.<br>
                    Then, the first instruction of file B actually becomes instruction 100.<br>
                    So, the first instruction of <code>mySubroutine</code> becomes instruction 142.<br>
                    Now, when we jump to <code>mySubroutine</code>, we can resolve the address to be <span class="math">142 * 4</span>.<br>
                </p>
                <br>
                <b>Libraries</b>
                <ul>
                    <li>just a collection of object files</li>
                    <li>contain functionality used by many programs, like square root</li>
                    <li>ready for linking with other files</li>
                </ul>
                <br>
                <b>Loading</b>
                <ul>
                    <li>loading executable from disk into memory</li>
                    <li>if command line arguments are used, place them in the correct (expectable) place</li>
                    <li>initialise register (e.g. stack pointer)</li>
                    <li>create a new process in the operating system and initialise by jumping to the start label</li>
                </ul>
                <br>
                <b>Dynamic Linking</b>
                <ul>
                    <li>relocate and resolve symbols at load time instead of linking</li>
                </ul>
                <br>
                <b>Dynamic Library</b>
                <ul>
                    <li>do not add the library to the final compiled executable, combine with it at the loading step (smaller executable)</li>
                </ul>
                <br>
                <b>Dynamic Shared Libraries</b>
                <ul>
                    <li>keep only one object code in memory, store in special memory area, or special relocatable object code</li>
                    <li><span class="keyword">Dynamic Link Libraries (DLL)</span> on Windows</li>
                    <li>modifications to a DLL apply all programs that use it
                        <ul>
                            <li>no rebuilding necessary</li>
                        </ul>
                    </li>
                    <li>requires that the computer running your program has the DLL you rely on and it has to be a compatible version</li>
                </ul>
                <br>
                <b>Alternative Execution Approaches</b>
                <ul>
                    <li>
                        <span class="keyword">Interpretation</span>
                        <ul>
                            <li>alternative to compiling</li>
                            <li>scanning, parsing and type checking are done in the same way</li>
                            <li>where a compiler would traverse the AST and generate the code and a interpreter traverses the tree and executes the code</li>
                            <li>usually slower than executing a compiled program
                                <ul>
                                    <li>may have to traverse some part of the tree multiple time (e.g. loop)</li>
                                    <li>it is a program executing your program</li>
                                </ul>
                            </li>
                            <li>writing an interpreter is usually easier than writing a compiler and if you write an interpreter with a language that can be compiled on may different machines, now you language works on all those machines</li>
                        </ul>
                    </li>
                    <li>
                        Compilation and Interpretation can be combined:
                        <ul>
                            <li>have a compiler that generates an intermediate representation of your code, and an interpreter that interprets that intermediate representation</li>
                            <li>
                                Java is an example of this
                                <ul>
                                    <li>Java is compiled to Java byte code</li>
                                    <li>the interpreter that interprets the Java byte code is the <span class="keyword">Java Virtual Machine (JVM)</span></li>
                                    <li>if we can write a JVM for a system, we can run Java on that system</li>
                                </ul>
                            </li>
                            <li>trade-off is between portability and speed</li>
                        </ul>
                    </li>
                </ul>
            </section>
            <hr>

            <table class="buttomTable">
                <tr>
                    <td class="buttomLeftTable"><a href="./cs230_3.html">&larr; Go to Module 3 - Machine Internals</a></td>
                    <td class="buttomCentreTable"><a href="./cs230.html">&uarr; Go to Index</a></td>
                    <td class="buttomRightTable"><a href="./cs230_5.html">&rarr; Go to Module 5 - Multiprocessing&nbsp;</a></td>
                </tr>
            </table>
            <hr>
            
            <p>
                Find a typo or mistake? Feel free to contact me and I will correct it as soon as possible.
            </p>
            <hr>
            
            <div class="footer">
                <p>Thanks For Coming Here. - Calvin Li</p>
                <a href = "mailto: ck6li@edu.uwaterloo.ca" target = "_blank;">
                    <i class = "fa fa-envelope-square"></i>
                </a>
                <a href = "https://www.linkedin.com/in/vertckli/" target = "_blank;">
                    <i class = "fa fa-linkedin-square"></i>
                </a>       
                <a href = "https://www.instagram.com/vert_arts/" target = "_blank;">
                    <i class="fa fa-instagram"></i>
                </a>
                <a href = "https://github.com/vertli" target = "_blank;">
                    <i class="fa fa-github-square"></i>
                </a>
                <br>
                <p><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" /></a> This work by <a xmlns:cc="http://creativecommons.org/ns#" href="https://vertli.github.io/" property="cc:attributionName" rel="cc:attributionURL">Chun Kit (Calvin) Li</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>. Chun Kit (Calvin) Li &copy; 2017 - 2018</p>
            </div>
            <hr>
            
        </div>
        
        <script src="https://code.jquery.com/jquery-2.1.4.js"></script>
        <script src="./bootstrap-3.3.7-dist/js/bootstrap.js"></script>
        
    </body>
    
</html>