<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    <title>CS230|Calvin Li</title>
    <link rel="stylesheet" href="./bootstrap-3.3.7-dist/css/bootstrap.css">
    <link rel="stylesheet" href="./css/style.css">
    <link rel="stylesheet" href="./css/newNote.css">
    <!-- Code Display use -->
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?skin=desert"></script>
    <link rel="stylesheet" href="./css/skin.css">
    <!-- Google Fonts: Noto Sans-->
    <link href="https://fonts.googleapis.com/css?family=Noto+Sans:400,700" rel="stylesheet">
    <!-- stylesheet found from w3school. (icon use)-->
    <link rel = "stylesheet" href = "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  </head>
    
  <body class="cs230">

    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#topNavbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="./index.html">Calvin Li</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="topNavbar">
          <ul class="nav navbar-nav">
            <li><a href="./doc/NewResume_CKLI.pdf" target="_blank;">Résumé</a></li>
          </ul>
          <ul class="nav navbar-nav navbar-right">
            <li><a href="./about.html">About</a></li>
            <li><a href="./projects.html">Projects</a></li>
            <li class="courseNote">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Course Notes<span class="caret"></span></a>
              <ul class="dropdown-menu">
                <li><a href="./cs230.html">CS 230</a></li>
                <li><a href="./cs246.html">CS 246</a></li>
              </ul>
            </li>
          </ul>
        </div><!-- /.navbar-collapse -->
      </div><!-- /.container-fluid -->
    </nav>
        
    <br><br><br>
        
    <div class="container">     
      <br>
      <table class="header">
        <tr>
          <td colspan="100%">
            <h1 class="title">CS 230 - Introduction to Computers and Computer Systems</h1>
          </td>
        </tr>
        <tr>
          <th colspan="5%">Instructor:</th>
          <td colspan="95%">Rob Hackman</td>
        </tr>
        <tr>
          <th colspan="5%">Office:</th>
          <td colspan="95%">DC2551A</td>
        </tr>
        <tr>
          <th colspan="5%">Email:</th>
          <td colspan="95%"><a href = "mailto: r2hackma@uwaterloo.ca" target = "_blank;">r2hackma@uwaterloo.ca</a></td>
        </tr>
        <tr>
          <th colspan="5%">Website:</th>
          <td colspan="95%">
            <a href="https://www.student.cs.uwaterloo.ca/~cs230/" target="_blank;">https://www.student.cs.uwaterloo.ca/~cs230/</a>
          </td>
        </tr>
        <tr>
          <th colspan="5%">Note:</th>
          <td>All program codes in this course notes are provided by Prof. Hackman during class.</td>
        </tr>
      </table>
      <hr>

      <section id="lec4">
        <h3>Lecture 4 - 16/01/2018</h3>
        <hr>
        <h4>Real Numbers</h4>
        <p>
          What is real number? For example, \(1.15\) is real number.
        </p>
        <p>
          How does computer represent real numbers?<br>
          First of all, let's talk about the <strong>Scientific Notation</strong>.<br>
          For example, \(-3.24 \times 10^{56}\), and it is also called as <strong>Normalized Scientific Notation</strong>.
        </p>
        <p>
          <strong>Normalized Scientific Notation</strong>: one non-zero digit in front of the decimal point<br>
          For example, \(0.002 \times 10^{4}\) and \(56.123 \times 10^{8}\) are not normalized.
        </p>
        <p>
          How do we write a real number in binary with scientific notation?<br>
          For example, \(1.01_2 \cdot 2^1\) where the \(.\) after \(1\) and before \(0\) is called a binary point (radix point generally).<br>
          So what does \(1.01_2\) mean?<br>
          Before we answer this answer, we need to ask ourselves, what does \(1.01_{10}\) mean?
          \begin{align*}
            1.01_{10} = 1 \cdot 10^0 + 0 \cdot 10^{-1} + 1 \cdot 10^{-2}
          \end{align*}
          With the same idea, we have...
          \begin{align*}
            1.01_2 &amp;= 1 \cdot 2^0 + 0 \cdot 2^{-1} + 1 \cdot 2^{-2}\\
                   &amp;= 1 + \frac{1}{4}\\
                   &amp;= 1.25_{10}
          \end{align*}
        </p>
        <p>
          How do we represent real numbers in our machines?<br>
          We use what's called <strong>floating point number</strong>.<br>
          The reason it is called this name because it allow the binary point to "float" by changing the exponent.<br>
          The opposite would be fixed point.
        </p>
        <p>
          Floating point is of the form \(I.F \cdot B^E\) where...
        </p>
        <ul>
          <li>\(I\): Integer</li>
          <li>\(F\): Fractional</li>
          <li>\(B\): Base</li>
          <li>\(E\): Exponent</li>
          <li>\(I.F\): Significand (or "Mantissa")</li>
        </ul>
        <p>Our floats are always normalized, so \(I\) is always \(1\).</p>
        <ul>
          <li>left out of our representation is called "implicit/hidden point"</li>
        </ul>
        <p>
          The base in always \(2\) because we are in binary!<br>
          So these are the components of our floating point.
        </p>
        <p>
          How does float represent in a machine? the standard <strong>IEEE 754</strong>.<br>
          We have single precision 32 bits, double precision 64 bits.
        </p>
        <p>
          Single Precision Float: 32 bits
        </p>
        <img src="./image/cs230/lec4/4_1.png" class="imgCentre"><br>
        <p>
          We have 1 bit for the sign bit (green box), 8 bits for the exponent (red boxes) and the rest of the boxes (purple) are for the fractional.<br>
          Note that integer and base are not represented since base is 2 and integer is always 1 except for special subnormal numbers.
        </p>
        <p>
          Also, we need to know that the exponent bits do not represent exactly the exponent \(e\) in \(I.F \cdot B^e\). Why?<br>
          The standard uses a bias value, so the exponent bits represent an unsigned number and you subtract the bias from it.<br>
          Bias for single precision is \(127\).
        </p>
        <p>
          So to calculate the value \((-1)^5 \cdot (I.F) \cdot 2^{e-127}\), let's try calculating the decimal value of single precision float:
          \begin{align*}
            0 \: 10000100 \: 11000000000000000000000
          \end{align*}
          The first \(0\) is the sign bit.<br>
          Then, \(10000100\) are the exponent bits:
          \begin{align*}
            10000100 &amp;= 128 + 4 - bias\\
                     &amp;= 132 - 127\\
                     &amp;= 5
          \end{align*}
          The rest of the bits \(11000000000000000000000\) are the fractional bits where
          \begin{align*}
            1.11 &amp;= 1 + 2^{-1} + 2^{-2}\\
                 &amp;= 1 + 0.5 + 0.25\\ 
                 &amp;= 1.75
          \end{align*}
          So, we now have:
          \begin{align*}
            (-1)^S \cdot (I.F) \cdot 2^{e-127} &amp;= (-1)^0 \cdot (1.11) \cdot 2^5\\
                                               &amp;= 1 \cdot (1.75) \cdot 2^5\\
                                               &amp;=56.0
          \end{align*}
        </p>
        <p>
          Let's consider a simplified 8-bit representation for floats: 1 bit for sign bit, 3 bits for exponent (bias = 3) and 4 bits for fractional.<br>
          Note that bias is a choosing value, so you don't have to worry about it.
        </p>
        <p>
          Example: Express \(4.5\) in our simplified format.<br>
          Note that \(4_{10} = 100_{2}\) and \(0.5_{10} = \frac{1}{2}_{10} = 2^{-1} = 0.1_{2}\).<br>
          Thus, \(4.5_{10} = 100.1_{2}\).<br>
          Then we have \(100.1\cdot 2^0\) and normalise it, we get \(1.001 \cdot 2^2\).<br>
          Next, the exponent is \(e + bias = 2 + 3 = 5 = 101_2\) and sign bit is \(0\) since \(4.5\) is a positive number.<br>
          So, we get \(0 \: 101 \: 0010\) as our final answer, where \(0\) is the sign bit, \(101\) is the exponent bits and \(0010\) is the fractional bits.
        </p>
        <p>
          Arithmetic with floats is easy.<br>
          For addition, just set the exponents the same and add the significands (regular addition).
        </p>
        <p>
          Example: Add \(1.25\) and \(2.125\) in our simplified format.<br>
          Note that \(1.25 = 1.01 \cdot 2^0\).<br>
          So we know that \(F = 0100\), \(E = 0 + 3 = 3 = 011\) and \(S = 0\).<br>
          Thus, \(1.25_{10} = 0 \: 011 \: 0100^{2}\).<br>
          Also, \(2.125 = 1.0001 \cdot 2^1\).<br>
          So we know that \(F = 0001\), \(E = 1 + 3 = 4 = 100\) and \(S = 0\).<br>
          Thus, \(2.125_{10} = 0 \: 100 \: 0001_{2}\).
          \begin{align*}
            1.25 + 2.125 &amp;= 1.01 \cdot 2^0 + 1.0001 \cdot 2^1 \\
                         &amp;= 1.01 \cdot 2^0 + 10.001 \cdot 2^0 \\
                         &amp;= 11.011 \cdot 2^0 \\
                         &amp;= 1.1011 \cdot 2^1
          \end{align*}
        </p>
        <p>
          From the normalized scientific notation \(1.1011 \cdot 2^{1}\), we know that \(F = 1011\), \(E = 1 + 3 = 4 = 100\) and <\(S = 0\).<br>
          So our final answer is \(0 \: 100 \: 1011\).
        </p>
        <p>
          For multiplication, we add exponents, then multiply significands.<br>
          For example, \(1.5 \cdot 2.25\).<br>
          Note that \(1.5 = 0 \: 011 \: 100\) and \(2.25 = 0 \: 100 \: 0010\).
        </p>
        <p>
          Step 1 - Add Exponents:<br>
          \((E_{1.5} - bias) + (E_{2.25} - bias) = (011 - 011) + (100 - 011) = 1 = e\)<br>
          So \(E = 1 + 3 = 4 = 100_{2}\).
        </p>
        <p>
          Step 2 - Multiply Significands:
          \begin{align*}
            1.1000 \times 1.0010 &amp;= (1 \cdot 1.001) + (0.1 \cdot 1.001) \\
                                 &amp;= 1.001 + 0.1001 \\
                                 &amp;= 1.1011
          \end{align*}
        </p>
        <p>
          So our new fractional bits are \(1011\), new exponent bits are \(100\) and new sign bit is \(0\).<br>
          Therefore, \(1.5 \cdot 2.25 = 0 \: 100 \: 1011\).
        </p>
        <p>
          However, examining our simplified format we can see the problems that arise in floating point numbers.<br>
          The first problem is there exists infinite numbers between 0 and 1, but we cannot represent infinite numbers within 32 bits!<br>
          For example, consider \(15.25\) in our 8-bit system:<br>
          \(15.25 = 1111.01 \cdot 2^{0} = 1.11101 \cdot 2^{3}\)<br>
          We need 5 bits for the fraction but we only have 4 bits to use!<br>
          So we get an overflow, which is \(1.1110 \cdot 2^{3}\).<br>
          If we round up, we get \(15.5\); if we round down, we get \(15.0\).
        </p>
        <p>
          So overflow can happen; they get represented as <strong>inf</strong> (also occurs for divide by 0).
        </p>
        <p>For IEEE 754,</p>
        <table class="cs">
          <tr>
            <th>Exponent Bits</th>
            <th>Fractional Bits</th>
            <th>Value/Type</th>
          </tr>
          <tr>
            <td>0000 0000</td>
            <td>00...00</td>
            <td>0</td>
          </tr>
          <tr>
            <td>0000 0000</td>
            <td>non-zero</td>
            <td>subnormal</td>
          </tr>
          <tr>
            <td>0000 0000 1...1111 1110</td>
            <td>Any</td>
            <td>normal number</td>
          </tr>
          <tr>
            <td>1111 1111</td>
            <td>00...00</td>
            <td>infinity</td>
          </tr>
          <tr>
            <td>1111 1111</td>
            <td>non-zero</td>
            <td>NaN</td>
          </tr>
        </table>
        <p>
          What is <strong>NaN</strong>? It means "not a number".<br>
          For example, \(\sqrt{-1}\), \(\frac{\infty}{\infty}\) and \(\infty \cdot 0\).
        </p>
        <p>
          If we didn't create a special case for subnormal numbers, then the gap between \(0\) and our smallest representable number would be:
          \begin{align*}
            0 \: 000 \: 0000_2 &amp;= 1.0000 \cdot 2^{-3}\\
                               &amp;= 0.1255
          \end{align*}
          That is a large gap! Often we talk about small numbers.<br>
          This also means our gap between adjacent numbers is \(0.0001 \cdot 2^{-3} = 2^{-7}\).
        </p>
        <p>
          Instead, we treat subnormal numbers as a special case.<br>
          So, when we would have \((0 - bias)\) exponent instead we do \((1 - bias)\) as exponent and have the implicit bit be \(0\).<br>
          This is how to interpret subnormal numbers: \((-1)^{S} \cdot (0.F) \cdot 2^{1 - bias}\)
        </p>
        <ul>
          <li>Smallest number \(&gt;0\) is \(1.00 \cdot 2^{-2}\)</li>
          <li>Gap between number is \(0.0001 \cdot 2^{-2}\) (worse)</li>
          <li>Smallest subnormal number is \(0.0001 \cdot 2^{-2} = 0.01525\) (much better!)</li>
        </ul>
        <p>
          So using subnormal numbers we get a larger gap between our numbers (largest/smallest possible exponent).<br>
          But we get closer to 0 before losing all our precision.<br>
          Tradeoff is the gaps between representable numbers and how close to 0 we can get.
        </p>
        <br>
        <h4>Gradual Underflow</h4>
        <p>
          Don't forget floating point is not exact, it is only an approximation of real numbers.<br>
          For example, \(0.1\) cannot be represented in IEEE 754.<br>
          Therefore, don't use <code>==</code> on floats.<br>
          Also, associativity and distribution or arithmetic operators are not guaranteed!
        </p>
        <br>
        <h4>Module 2 - Assembly Language</h4>
        <p>Recall: Computers only understand set instructions which are group of \(1\)'s and \(0\)'s (machine code).</p>
        <p>
          A assembly language is one step up from that - basis operations that operate on registers.<br>
          It has a direct translation to machine code.
        </p>
        <p>
        A program called an assembler translates assembly to machine code.
        </p>
        <p>
          In order to understand how computers/programs work, we are going to study <strong>MIPS</strong> on assembly language.<br>
          Because assembly languages operate on registers (actual hardware of CPU), assembly languages are tied to hardware.<br>
          Hence why we use an emulator.
        </p>
        <p>
          <strong>MIPS</strong> is an acronym for Microprocessor without Interlocked Pipeline Stages; we will talk about the meaning later (someday in the future).
        </p>
        <p>
          In MUPS, we have 32 registers (which are labeled with <code>$0</code> to <code>$31</code>).<br>
          Each register is 32 bits.<br>
          Why we only have 32 registers, not more? More means slower - we need more bits to store a register.<br>
          For now, we only need 5 bits to store 32 registers.
        </p>
        <p>
          <strong>Special Registers</strong><br>
          PC (program counter) holds the memory address of the next instruction; each instruction done increments it by 4, or it can be manipulator.
        </p>
        <p>
          <strong>Register 0 (<code>$0</code>)</strong>: It is the constant \(0\); otherwise, the machine will die!<br>
          <br>
          <strong>Conventions</strong><br>
          <code>$31</code> is the return address and <code>$30</code>, <code>$29</code> and <code>$28</code> are special.
        </p>
      </section>
      <hr>

      <section id="lec5">
        <h3>Lecture 5 - 18/01/2018</h3>
        <hr>
        <h4>Announcements:</h4>
        <p>
          Assignment 1 is due tomorrow!<br>
          Midterm is 3 weeks after today!
        </p>
        <br>
        <h4>Midterm</h4>
        <p>
          In midterm, you can have one \(8.5" \times 11"\) (inches) single-sided "cheat sheet".<br>
          You can write anything on the cheat sheet, but only single sided.<br>
          It will be taken away during midterm if it is NOT single sided.<br>
          It will be collected with your midterm paper.<br>
           One more thing, this cheat sheet must be hand-written.
        </p>
        <br>
        <h4>MIPS (Microprocessor without Interlocked Pipeline Stages)</h4>
        <p>
          MIPS does NOT stand for "Millions for Instructions Per Second".
        </p>
        <p>
          It is an assembly language; it has direct translation to machine code.<br>
          We use assembler to translate from assembly language to machine code.<br>
          An assembly language operates directly on the registers in the CPU, so it is tied to the hardware.<br>
          <br>
          In MIPS, we have 32 registers labeled with 0 to 31.
        </p>
        <br>
        <h4>Special Registers</h4>
        <ul>
          <li>Program Counter (PC) holds the address of the next instruction to execute</li>
          <li>Register 0 (<code>$0</code>): constant 0</li>
          <li>Conversion <code>$31</code>: return address</li>
          <li>Conversions <code>$28</code>, <code>$29</code>, <code>$30</code>: global, stack, frame, etc.; our emulator uses <code>$30</code> for stack pointer (SP)</li>
        </ul>
        <br>
        <h4>Instructions</h4>
        <p>
          They have up to 3 operands, often registers.<br>
          When using 3 operands, the first one is the destination, the other two are sources.
        </p>
        <p>Example: Addition</p>
<pre class="prettyprint linenums:1">add $8, $9, $10</pre>
        <p>
          This instruction add the values stored in register 9 and register 10 together, then store the result in register 8.
        </p>
        <p>
          The general form for these R-type instruction (register instruction) is:
        </p>
<pre class="prettyprint linenums:1">add $d, $s, $t</pre>
        <p>
          <code>$d</code> is the destination register (Rd); <code>$s</code> and <code>$t</code> are the source registers, which are denoted as Rs and Rt.<br>
          The instruction <span class="add">add</span> means \(d = s + t\) and the values stored in those registers.
        </p>
        <p>
          Example: Subtraction
        </p>
<pre class="prettyprint linenums:1">sub $d, $s, $t  ; d = s - t</pre>
        <p>
          Note that <code>;</code> is how to start a comment in MIPS.
        </p>
        <p>
          What if we want a value that does not already exist in one of our registers? We can use <strong>immediate</strong> instruction.
        </p>
<pre class="prettyprint linenums:1">addi $t, $s, i</pre>
        <p>
          In here, <code>$t</code> is the destination register and <code>$s</code> is the source register.<br>
          How about <code>i</code>? This is an I-type instruction, which means we are using a literal value.
        </p>
        <p>
          Example: Add the value in register 8 to the literal value 42, then store the result in register 15.
        </p>
<pre class="prettyprint linenums:1">addi $15, $8, 42</pre>
        <p>
          Example: Add 10 and 24, subtract 3, store result in $3.
        </p>
<pre class="prettyprint linenums:1">addi $1, $0, 10  ; initialize $1 to 10
addi $2, $0, 24  ; initialize $2 to 24
add  $3, $1, $2  ; add the value 10 and 24 in register 1 and register 2, store result in register 3
addi $3, $3, -3  ; subtract 3 from value in register 3, store result in register 3
jr   $31         ; need this to terminate program in emulator
</pre>
        <br>
        <p>
          <strong>Multiplication</strong><br>
          Note that we have 32 bits in our registers.<br>
          If we multiply 2 32-bit numbers together, the result could have as many as 64 bits.<br>
          Hence, we have the special registers "hi" and "lo" to store the result.
        </p>
        <table class="cs">
          <tr>
            <td>hi</td>
            <td>lo</td>
          </tr>
          <tr>
            <td>32 bits</td>
            <td>32 bits</td>
          </tr>
        </table>
        <br>
<pre class="prettyprint linenums:1">mult $s, $t  ; $s &times; $t, place result in hi and lo
</pre>
        <br>
        <p><strong>Special instructions to copy from hi and lo:</strong></p>
<pre class="prettyprint linenums:1">mfhi $d  ; "move from hi" and copy the value in $hi to $d
mflo $d  ; "move from lo" and copy the value in $lo to $d
</pre>
        <br>
        <p>
          <strong>Division</strong>: <code>div $s, $t &nbsp;; $s / $t</code><br>
          It is always integer division; it place the quotient in <code>$lo</code> and the remainder in <code>$hi</code>.
        </p>
        <p>
          Example: Calculate average of 3 numbers stored in <code>$3</code>, <code>$4</code> and <code>$5</code>, then store result in <code>$3</code>.
        </p>
<pre class="prettyprint linenums:1">; calculate ($3 + $4 + $5) / $3
add  $3, $4, $3
add  $3, $5, $3
addi $6, $0, 3
div  $3, $6
mflo $3
jr   $31
</pre>  
        <p>
          So now we can do basic math. Yeah!<br>
          But what if we cant to do basic math lots of times?<br>
          In Python, we have constructs like while loop, for loop, recursion for repetition.<br>
          If we want repetition in MIPS, we need to manipulate <code>$PC</code>.
        </p>
        <br>
        <p><strong>Conditional Branches</strong></p>
<pre class="prettyprint linenums:1">beq $s, $t, label  ; branch if equal
; if $s == $t, then goto label
; overwrite $pc with the address of the instruction at label

bne $s, $t, label  ; branch if not equal
; if $s != $t, then goto label
</pre>  
        <br>
        <p>Example: Write a loop with MIPS.</p>
<pre class="prettyprint linenums:1">addi $1, $0, 10
loopStart:
  addi $1, $1, -1
  ; loop body
  bne $1, $0, loopStart
  jr $31
</pre>
        <br>
        <p>
          Example: Calculate \(0 + 1 + \dots + n\) where \(n\) is stored in <code>$8</code>, and store result in <code>$7</code>.<br>
          In Python...
        </p>
<pre class="prettyprint linenums:1 lang-py">;; assume n already initialized
iter = n
y = 0
while (iter != 0):
  y = y + iter
  iter = iter - 1
</pre>
        <br>
        <p>In MIPS: assume \(n =\) <code>$8</code>, \(y =\) <code>$7</code> and \(iter =\) <code>$9</code></p>
<pre class="prettyprint linenums:1">add $9, $8, $0   ; iter = n
add $7, $0, $0   ; y = 0
beq $9, $0, end  ; skip if iter == 0
loopStart:
  add  $7, $7, $8  ; y = y + iter
  addi $9, $9, -1  ; iter = iter - 1
  bne  $9, $0, loopStart
end:
  jr $31
</pre>
        <br>
        <p>There are more instructions. For example...</p>
<pre class="prettyprint linenums:1">slt $d, $s, $t
</pre>
        <p>
          This instruction is "set less than".<br>
          If <code>$s</code> \(&lt;\) <code>$t</code>, then <code>$d</code> \(:= 1\), otherwise <code>$d</code> \(:= 0\).<br>
          It is just a comparison operator with the result (T/F) store in <code>$d</code>.<br>
          So we can combine this with branches to simulate conditional.
        </p>
        <p>
            Example: if \(x &lt; y\), set \(x := x - y\)<br>
            In Python, we do...
        </p>
<pre class="prettyprint linenums:1 lang-py">if (x &lt; y):
  x = x - y
</pre>
        <br>
        <p>In MIPS, let \(x =\) <code>$7</code>, \(y =\) <code>$8</code></p>
<pre class="prettyprint linenums:1">slt $6, $7, $8
beq $6, $0, done
sub $7, $7, $8
done:
  jr $31
</pre>
        <br>
        <h4>Memory</h4>
        <p>
          Memory region forms in MIPS is \(2^{32}\) bytes (\(4\)GiB).<br>
          Note that \(2^{30} = 1\) gibibyte and so \(2^{30} \times 4 = 4 gibibytes = 2^{32}\).<br>
          Memory is essentially a huge array, addresses are the indices or rather always are small bits of memory, indices are address offsets.
        </p>
        <p>
          In this course, we use word-aligned memory access/addressing (\(4\)-byte).<br>
          MIPS word = \(32\) bits
        </p>
        <table class="tableNoBorder">
          <tr>
            <td></td>
            <td colspan="4">32 bits</td>
          </tr>
          <tr>
            <td>0</td>
            <td class="tableWithBorder">0</td>
            <td class="tableWithBorder">1</td>
            <td class="tableWithBorder">2</td>
            <td class="tableWithBorder">3</td>
          </tr>
          <tr>
            <td>4</td>
            <td class="tableWithBorder">0</td>
            <td class="tableWithBorder">1</td>
            <td class="tableWithBorder">2</td>
            <td class="tableWithBorder">3</td>
          </tr>
          <tr>
            <td>8</td>
            <td class="tableWithBorder">0</td>
            <td class="tableWithBorder">1</td>
            <td class="tableWithBorder">2</td>
            <td class="tableWithBorder">3</td>
          </tr>
          <tr>
            <td>...</td>
            <td class="tableWithBorder">...</td>
            <td class="tableWithBorder">...</td>
            <td class="tableWithBorder">...</td>
            <td class="tableWithBorder">...</td>
          </tr>
        </table>
        <p>
          Accessing Memory: <code>lw $t, i($s)  ; load word</code><br>
          It treats the value in register <code>$s</code> as an address for memory, add \(i\) to <code>$s</code>.<br>
          Then the result as an address, copy the word (32 bits) stored at that address into register <code>t</code>.<br>
          Note that \(i =\) <code>$s</code> <strong>MUST</strong> be word aligned (divisible by \(4\)).
        </p>
        <p>
          Example: <code>lw  $2, 4($1)</code>
        </p>
        <table class="tableNoBorder">
          <tr>
            <th colspan="2">Register:</th>
            <th colspan="2">Memory:</th>
          </tr>
          <tr>
            <td>0</td>
            <td class="tableWithBorder">0x00000000</td>
            <td>address</td>
            <td>value</td>
          </tr>
          <tr>
            <td>1</td>
            <td class="tableWithBorder">0x00000010</td>
            <td>0</td>
            <td>12</td>
          </tr>
          <tr>
            <td>2</td>
            <td class="tableWithBorder">0x00000015</td>
            <td>4</td>
            <td>42</td>
          </tr>
          <tr>
            <td colspan="2" rowspan="6"></td>
            <td>8</td>
            <td>9</td>
          </tr>
          <tr>
            <td>12</td>
            <td>17</td>
          </tr>
          <tr>
            <td>16</td>
            <td>125</td>
          </tr>
          <tr>
            <td>20</td>
            <td>21</td>
          </tr>
          <tr>
            <td>24</td>
            <td>100</td>
          </tr>
          <tr>
            <td>...</td>
            <td>...</td>
          </tr>
        </table>
        <p>
          Since the value in <code>$1</code> is \(16\), then \(4($1) = 4 + $1 = 4 + 16 = 20\).<br>
          So we are looking for the address \(20\).<br>
          Therefore, we need to store the value \(21\) into <code>$2</code>.
        </p>
        <p>Make sure you can differentiate between:</p>
        <ul>
          <li>register <u>number</u> (\(0 - 31\))</li>
          <li>
            register value (e.g. <code>$20</code>)
            <ul>
              <li>contents of the registers</li>
            </ul>
          </li>
          <li>memory address</li>
          <li>memory contents (value)</li>
        </ul>
        <p>
          Example: Read values stored in memory addresses \(64\) and \(72\), add them together, store the result in address \(80\).
        </p>

<pre class="prettyprint linenums:1">addi  $1, $0, 64
lw    $2, 0($1)
lw    $3, 8($1)
add   $4, $2, $3
sw    $4, 16($1) ; save word
jr    $31
</pre>
        <p>Remember a program is just a bunch of machine code instructions (1's and 0's).</p>
        <p>
          What do our 32-bit instructions look like in memory?<br>
          R-type Instructions (e.g. add)
        </p>
        <table class="cs">
          <tr>
            <td>op</td>
            <td>Rs</td>
            <td>Rt</td>
            <td>Rd</td>
            <td>shamt</td>
            <td>func</td>
          </tr>
          <tr>
            <td>6 bits</td>
            <td>5 bits</td>
            <td>5 bits</td>
            <td>5 bits</td>
            <td>5 bits</td>
            <td>6 bits</td>
          </tr>
        </table>
        <br>
        <ul>
          <li>op: op-code</li>
          <li>Rs, Rt, Td: the source registers and the destination register</li>
          <li>shamt: shift amount (only used for shift instructions)</li>
          <li>func: works together with op-code to denote arithmetic instructions</li>
        </ul>
      </section>
      <hr>

      <section id="lec6">
        <h3>Lecture 6 - 23/01/2018</h3>
        <hr>
        <p>
          Recall: A program is just a series of instructions, and instructions are just specific groups of 1's and 0's.
        </p>
        <p>
          So, what does a program look like in memory?<br>
          In MIPS, we have 32-bit instructions with 3 different instruction types: R-type, I-type and J-type.
        </p>
        <br>
        <h4>R-type Instruction</h4>
        <table class="cs">
            <tr>
              <td>Op-code</td>
              <td>R<sub>s</sub></td>
              <td>R<sub>t</sub></td>
              <td>R<sub>d</sub></td>
              <td>shamt</td>
              <td>func</td>
            </tr>
            <tr>
              <td>6 bits</td>
              <td>5 bits</td>
              <td>5 bits</td>
              <td>5 bits</td>
              <td>5 bits</td>
              <td>6 bits</td>
            </tr>
        </table>
        <p>
          R<sub>s</sub>, R<sub>t</sub>: the source registers.<br>
          R<sub>d</sub>: the destination register.<br>
          shamt: shift amount, only used for shift operations.<br>
          func: 6 bits used in tandem with the op-code to denote arithmetic instructions.
        </p>
        <br>
        <h4>I-type Instruction</h4>
        <table class="cs">
          <tr>
            <td>Op-code</td>
            <td>R<sub>s</sub></td>
            <td>R<sub>t</sub></td>
            <td>Immediate Value</td>
          </tr>
          <tr>
            <td>6 bits</td>
            <td>5 bits</td>
            <td>5 bits</td>
            <td>16 bits</td>
          </tr>
        </table>
        <br>
        <h4>J-type Instruction</h4>
        <table class="cs">
          <tr>
            <td>Op-code</td>
            <td>Address</td>
          </tr>
          <tr>
            <td>6 bits</td>
            <td>26 bits</td>
          </tr>
        </table>
        <br>
        <p>
          Example: What is the binary represent of <code>add $3, $1, $2</code>?<br>
          According to our MIPS Reference Sheet, we know that...<br>
          The op-code binary is \(000000\), the shamt binary is \(00000\) and the function binary is \(100000\).<br>
          Now we need to find the binary of R<sub>s</sub> (<code>$1</code>), R<sub>t</sub> (<code>$2</code>) and R<sub>d</sub> (<code>$3</code>).
          Notice that the binary of 3 is \(00011\), the binary of 1 is \(00001\) and the binary of 2 is \(00010\).<br>
          Therefore, the binary represent of <code>add $3, $1, $2</code> is \(0000 \: 0000 \: 0010 \: 0010 \: 0001 \: 1000 \: 0010 \: 0000\).
        </p>
        <p>
          Example: Given \(0000 \: 0000 \: 1000 \: 0101 \: 0011 \: 1000 \: 0010 \: 1010\), what is this instruction?<br>
          The first 6 bits \(000000\) is for op-code, so we know that this is a R-type instruction.<br>
          Then the last 6 bits \(101010\) is for function, and according to our MIPS Reference Sheet, the instruction is <code>slt</code>.<br>
          Then we get 4 from the R<sub>s</sub> bits \(00100\), 5 from the R<sub>t</sub> bits \(00101\), 7 from the R<sub>d</sub> bits \(00111\), and the shamt bits are \(00000\).<br>
          Therefore, \(0000 \: 0000 \: 1000 \: 0101 \: 0011 \: 1000 \: 0010 \: 1010\) is <code>slt $7, $5, $7</code>.
        </p>
        <p>
          Note that the binary represent of shamt is always \(00000\) and we don't have to worry/carry about it in this course.
        </p>
        <p>
          Example: Find the binary represent of <code>addi $5, $0, 42</code>.<br>
          Answer: \(0010 \: 0000 \: 0000 \: 0101 \: 0000 \: 0000 \: 0010 \: 1010\) where \(001000\) is the op-code, \(00000\) is the R<sub>s</sub>(<code>$0</code>), \(00101\) is the R<sub>t</sub>(<code>$5</code>) and \(0000000000101010\) is the immediate value 42.
        </p>
        <p>
          In this course, our programs start at memory address 0 - the "top" of memory.<br>
          That means our program counter(PC) starts at 0 and increments by 4 each instruction.
        </p>
        <table class="tableNoBorder">
          <tr>
            <td>0</td>
            <td class="tableWithBorder">instruction 1</td>
          </tr>
          <tr>
            <td>4</td>
            <td class="tableWithBorder">instruction 2</td>
          </tr>
          <tr>
            <td>8</td>
            <td class="tableWithBorder">instruction 3</td>
          </tr>
          <tr>
            <td>12</td>
            <td class="tableWithBorder">instruction 4</td>
          </tr>
          <tr>
            <td>...</td>
            <td class="tableWithBorder">...</td>
          </tr>
        </table>
        <br>
        <p>
          Generally, our data is stored after our program.<br>
          We could put it in the middle and jump over it, but why bother?
        </p>
        <p>
          Immediate instructions limit us to 16-bit immediate value, but we have 32 bits of space in our registers! It seems wasteful.
        </p>
<pre class="prettyprint linenums:1">lis   $d    ; instruction is 1 word
.word 4254  ; value is 1 word
</pre>
        <br>
        <p>
          The r-type instruction <code>lis $d</code> means "load immediate and skip".<br>
          It treats the next 32 bits as data, load into <code>$d</code> and skip over that word.<br>
          In memory...<br>
        </p>
        <table class="tableNoBorder">
          <tr>
            <td>0</td>
            <td class="tableWithBorder">instruction 1</td>
            <td><code>lis $d</code></td>
          </tr>
          <tr>
            <td>4</td>
            <td class="tableWithBorder">4254</td>
            <td></td>
          </tr>
          <tr>
            <td>8</td>
            <td class="tableWithBorder">instruction 3</td>
            <td></td>
          </tr>
          <tr>
            <td>12</td>
            <td class="tableWithBorder">instruction 4</td>
            <td></td>
          </tr>
          <tr>
            <td>...</td>
            <td class="tableWithBorder">...</td>
            <td></td>
          </tr>
        </table>
        <br>
        <p>
          Alright, let's talk about I/O (Input/Output).<br>
          How can we do I/O in MIPS?<br>
          We have special memory address that lie outside of our "real" memory space, and treat those addresses as the location of our I/O devices.
        </p>
        <p>
          So for us, \(0xFFFF0004\) is our input device.<br>
          <code>lw</code> when used of this address receives 1 byte of our destination register.
        </p>
        <p>
          To write, we use \(0xFFFF000C\) as the address of our output device.<br>
          USe <code>sw $t, i($s)</code> on this address, to put the lowest order byte of your source register, interpreted as an ASCII character to the screen.
        </p>
        <p>
          If you had \(65\) in one register, and \(65 + 2^{24}\) in another, and printed both - they would both print 'A'.
        </p>
        <p>
          Example: Print out everything you read from input, only stop when you see the ASCII character for ESC.
        </p>
<pre class="prettyprint linenums:1">   lis  $1
   .word 0xffff0004    ; Input address
   lis  $2
   .word 0xffff000c    ; Output address
   addi $3, $0, 0x1b   ; ESC char in ASCII
loop:
   lw   $4, 0($1)      ; Read char from input
   sw   $4, 0($2)      ; Print that char back to output
   bne  $3, $4, loop   ; Repeat if ESC not entered
   jr   $31            ; Finish
</pre>
        <br>
        <p>
          Let's look at storing data in a program as a string and iterating that string: "Hello World"
        </p>
<pre class="prettyprint linenums:1">
   lis  $1
   .word 0xffff000c
   lis  $2
   .word helloWorld     ; Replaced by assembler with address of label
loop:
   lw   $3, 0($2)       ; Load address character at address stored in $2
   beq  $3, $0, end     ; If we read NUL char we are done.
   sw   $3, 0($1)       ; Print that character.
   addi $2, $2, 4       ; Point $2 at next char in string.
   beq  $0, $0, loop
end:
   jr   $31
helloWorld:
   .word 0x48
   .word 0x65
   .word 0x6c
   .word 0x6c
   .word 0x6f
   .word 0x20
   .word 0x57
   .word 0x6f
   .word 0x72
   .word 0x6c
   .word 0x64
   .word 0x21
   .word 0x0a
   .word 0x00
</pre>
        <br>
        <h4>Subroutines</h4>
        <ul>
          <li>equivalent to our high level functions</li>
          <li>
            makes assembly programming debugging easier
            <ul>
              <li>break up our problem into smaller subproblems</li>
            </ul>
          </li>
          <li>can be reusable, callable from anywhere!</li>
        </ul>
        <br>
        <p>What do we need to make these work?</p>
        <ul>
          <li>
            How to call/return execution from a subroutine?
            <ul>
              <li>call is easy; we're always jumping to the same location to run the subroutine (static)</li>
              <li>called subroutine must return execution to whatever part of the program called it (dynamic)</li>
            </ul>
          </li>
          <li>What about passing arguments and returning values?</li>
        </ul>
        <br>
        <p>
          We already know how to call a subroutine (jump to its label).<br>
          So how to return execution?<br>
          If we want dynamic return, we need to know 2 things:
        </p>
        <ul>
          <li>
            need to store the address of where to return execution, so the subroutine can jump back to that address
            <ul>
              <li>we must store <code>$pc + 4</code> for our return address</li>
            </ul>
          </li>
          <li>
            jump to the subroutine
            <ul>
              <li>luckily, we have an instruction to do just this : <code>jal srLabel ; jump and link</code></li>
              <li>store the next instruction to execute in <code>$31</code> (next instruction to execute after source register is done</li>
            </ul>
          </li>
          <li>
            then, jump to srLabel
            <ul>
              <li>but we have still got some problems</li>
              <li>we must be able to store register 31's value before overwriting it or we lose the previous return address</li>
            </ul>
          </li>
          <li>
            Where to store? Another register? NO!
            <ul>
              <li>limited (only 32) and valuable</li>
              <li>registers are not dynamic - ops that use them are not</li>
              <li>subroutine might overwrite that register</li>
            </ul>
          </li>
        </ul>
        <p>
          Solution: STACK!!!<br>
          Finally, we can talk about stack.<br>
          But what is stack? Stack is just a last in first out (LIFO) data structure.
        </p>
      </section>
      <hr>

      <section id="lec7">
        <h3>Lecture 7 - 25/01/2018</h3>
        <hr>
        <p>
          Problem: We need to store the value of our return address register somewhere and so the value won't be overwritten.<br>
          Solution: Use the stack.
        </p>
        <br>
        <h4>Stack</h4>
        <p>
          It is a last-in first-out (LIFO) data structure.<br>
          Example:
        </p>
        <img src="./image/cs230/lec7/7_1.png" class="imgCentre">
        <br>
        <p>
          Stacks are a very convenient way of representing/using our memory.<br>
          Convention: Stack grows up from the bottom of memory (as opposed to our program that went down from the top, address 0).<br>
          Normally, in MIPS register 29, is the stack pointer register.<br>
          In our emulator, the stack pointer is in register 30.
        </p>
        <p>
          How to use the stack via the stack pointer?<br>
          If we want to store something, we must "make room" on the stack by making the stack pointer further away from the bottom of memory however many bytes we need.<br>
          This is achieved by decrementing.
        </p>
        <p>
          How much must we decrement the stack pointer by to store one register?<br>
          We must decrement by 4.
        </p>
        <p>
          To store return address on stack, or any other register's value for that matter:
        </p>
<pre class="prettyprint linenums:1">addi $30, $30, -4
sw&nbsp;&nbsp;&nbsp;$31, 0($30)
</pre>
        <img src="./image/cs230/lec7/7_2.png" class="imgCentre">
        <p>The value of <code>$31</code> at the time it was stored.</p>
        <p>To restore a value from the stack:</p>
<pre class="prettyprint linenums:1">lw   $31, 0($30)
addi $30, $30, 4
</pre>
        <p>
          Now we know how to dynamically return from a subroutine without losing our return address.<br>
          So generally to call a subroutine...
        </p>
<pre class="prettyprint linenums:1">addi  $30, $30, -4
sw    $31, 0($30)
jal   srLabel
lw    $31, 0($30)
addi  $30, $30, 4
</pre>
        <br>
        <p>
          How to pass values into subroutine as arguments and our as return values?<br>
          Specific Register Conventions:
        </p>
        <ul>
          <li><code>$2</code> and <code>$3</code>: return values</li>
          <li><code>$4</code> to <code>$7</code>: arguments</li>
          <li><code>$8</code> to <code>$15</code>, <code>$24</code>, <code>$25</code>: unsaved temporaries</li>
          <li><code>$16</code> to <code>$23</code>: saved temporaries</li>
          <li>rest are special uses</li>
        </ul>
        <p>If you need more than 2 return values or 3 arguments - use the stack!</p>
        <p>
          <strong>Unsaved Temporaries</strong> mean that these registers are <u>NOT</u> preserved when a subroutine is ran.<br>
          If you are going to call a subroutine and want to keep these values, you MUST save them (this is the caller's job to save), move them to saved temporaries, OR push to stack before call.
        </p>
        <p>
          <strong>Saved Temporaries</strong> are guaranteed to be preserved across a call, so when a subroutine returns you are promised to still have those values.<br>
          It is the store register's job (or the caller's job) to save these registers.
        </p>
        <p>
          Let's put it all together in a case study.<br>
          We will use <code>a2q5.asm</code> from assignment 2 as our case study.<br>
          Assume we need to print an array of integers separated by commas.<br>
          We need to break up into 2 tasks...
        </p>
        <ul>
          <li>
            printing an integer
            <ul>
              <li>need to print each digit in order</li>
              <li>print a minus sign in front if it its negative</li>
            </ul>
          </li>
          <li>iterating an array printing each element in it</li>
        </ul>
        <p>
          To figure out digits, repeatedly divide by 10 and look at remainder.<br>
          Example: \(2542 \div 10 = 254 .. 2\)
        </p>
        <p>
          Do we print that digit as soon as we read it?<br>
          No, then we will print the string reversal of the number.<br>
          We need to store digits as we discover them, then print them in the reverse order of discovery!<br>
          Push them onto stack, them pop them off and print them.
        </p>
<pre class="prettyprint linenums:1">printInt:
  ; $4 is the int to print
  add   $11, $0, $0       ; init $11 to 0
  add   $12, $4, $0       ; init $12 to our number
  addi  $13, $0, 10       ; init $13 to 10
  lis   $10               ; setup $10 as printer
  .word 0xFFFF000C
  slt   $8,  $4, $0       ; check if negative number
  beq   $8,  $0, pushLoop ; if positive just start loop
  sub   $12, $0, $4       ; convert to positive
  addi  $9,  $0, 45       ; load 45, ascii -
  sw    $9,  0($10)       ; print minus sign
pushLoop:
  div   $12, $13          ; divide current number by 10
  mfhi  $14               ; copy remainder into $14
  mflo  $12               ; update current number to quotient
  addi  $11, $11, 1       ; increment number characters
  addi  $30, $30, -4      ; make space on stack
  sw    $14, 0($30)       ; store digit on stack
  bne   $12, $0, pushLoop ; keep going it not at 0
popLoop:
  lw    $9,  0($30)       ; load current digit to print
  addi  $9,  $9,  48      ; set to ASCII value for that digit
  sw    $9,  0($10)       ; print the digit
  addi  $30, $30, 4       ; pop off stack 
  addi  $11, $11, -1      ; decrement count of digits
  bne   $11, $0,  popLoop ; keep going if not done
  jr    $31
</pre>
        <p>
          So now we can print integers!<br>
          Let's use that to print our array!
        </p>
        <p>
          There's lots of ways these subroutines could be improved.<br>
          For example, in <code>pLoop</code> from <code>a2q5.asm</code>, we don't actually need to back up all those registers.<br>
          We could just initialize before use - not at start.<br>
          Example: the comma character and the space character<br>
          We don't need to use that many registers - we can reuse registers in ways that make sense.
        </p>
      </section>
      <hr>

      <section id="lec8">
        <h3>Lecture 8 - 30/01/2018</h3>
        <hr>
        <p>
          Assignment 2 due this Friday (2<sup>nd</sup> February, 2018) at 5pm!<br>
          Midterm is next week, Thursday 8<sup>th</sup> February, 2018!
        </p>
        <br>
        <h4>Questions from last lecture?</h4>
        <p>
           The stack - controlled (used) through a pointer (a memory address) to the current location of the stack.<br>
          Our stack pointer is in <code>$30</code>.<br>
          Stack starts at the BOTTOM (END) of our memory and "grows up" towards the start.
        </p>
        <img src="./image/cs230/lec8/8_1.png" class="imgCentre">
        <p>
          Note that we can't store store anything in the end of memory - that would go outside the memory space!
        </p>
<pre class="prettyprint linenums">addi $30, $30, -4</pre>
        <img src="./image/cs230/lec8/8_2.png" class="imgCentre">
        <br>
<pre class="prettyprint linenums">; assume $1 is 0xFB
sw $1, 0($30)</pre>
        <img src="./image/cs230/lec8/8_3.png" class="imgCentre">
        <br>
<pre class="prettyprint linenums">addi $30, $30, -8</pre>

        <img src="./image/cs230/lec8/8_4.png" class="imgCentre">
        <br>
<pre class="prettyprint linenums">; assume $2 is 0x81, $3 is 0xABC
sw $2, 0($30)
sw $3, 4($30)
</pre>
        <img src="./image/cs230/lec8/8_5.png" class="imgCentre">
        <br>
<pre class="prettyprint linenums">addi $1, $0, 0xABD ; now $1 is 0xABD
addi $2, $0, 0xEE  ; now $2 is 0xEE
addi $3, $0, 0xCC  ; now $3 is 0xCC
lw   $2, 0($30)    ; $2 is back to 0x81
</pre>
        <img src="./image/cs230/lec8/8_6.png" class="imgCentre">
        <br>
<pre class="prettyprint linenums">addi $30, $30, 4</pre>
        <img src="./image/cs230/lec8/8_7.png" class="imgCentre">
        <p>
          Note that even the value \(0x81) is popped, it still exists in memory until we overwrite something into the memory.
        </p>
<pre class="prettyprint linenums">lw  $3,  0($30)
lw  $1,  4($30)
; now $3 is 0xABC and $1 is 0xFB
add $30, $30, 8
</pre>
        <img src="./image/cs230/lec8/8_8.png" class="imgCentre">
        <br>
        <h4>Why bother learning assembly?</h4>
        <ul>
          <li>Gain and understanding of what a program actually is (sequence of instructions)</li>
          <li>Understand how our high level languages can be interpreted by a computer</li>
          <li>Gain an appreciation for which high level constructs are slower (take more instructions)</li>
          <li>
            Understand high level concepts better
            <ul>
                <li>example: How is data actually represented?</li>
            </ul>
          </li>
        </ul>	
        <br>
        <h4>Machine Internals and Performance</h4>
        <p>
          Computers are constructed with a <u>CLOCK</u> that determines the speed at which instructions are done.<br>
          Basically, it is a metronome for the computer - it keeps time for operations and achieves by sending an alternating signal of high/low voltage (in time).
        </p>
        <img src="./image/cs230/lec8/8_9.png" class="imgCentre">
        <p>Electric signal propagates pretty fast.</p>
        <ul>
          <li>Not infinitely fast, physical constraints</li>
          <li>Gate delay, time it takes for a signal to enter a gate and result exit the gate (at a steady state)</li>
        </ul>
        <p>
          Clock Period (Cycle Time): Duration in seconds of a cycle<br>
          Clock Frequency (Clock Rate): Cycles per second (1/cycle time) in Hz (hertz)
        </p>
        <p>
          Example: clock period of \(250ps = 250(10^{12}) s/cycle\).<br>
          Note: ps is picoseconds, a.k.a \(10^{12}\).<br>
          What is our clock rate?
          \begin{align*}
          1 \div 250(10^{-12}) &amp;= 10^{12} \div 250 \\
                               &amp;= 4(10^{9}) \\
                               &amp;= 4GHz
          \end{align*}
        </p>
        <p>Our cycles are used to "time" operations.</p>
        <br>
        <h4>Single Cycle Execution</h4>
        <ul>
          <li>Execute one instruction per cycle</li>
          <li>
            Fixed cycle time equal to the time it takes for our slowest instruction
            <ul>
              <li>add v.s. multiply</li>
              <li>memory instructions (slow)</li>
            </ul>
          </li>
          <li>If we want our common cases to be fast - then single cycle execution is not a great choice.</li>
        </ul>
        <br>
        <h4>Measuring Performance</h4>
        <p>Time</p>
        <ul>
          <li>
            Time to execute program (short as possible is goal!) - different ways of measuring this:
            <ul>
              <li>
                Elapsed Time (total response time): total real time it takes the program to execute from an outside perspective<br>
                It includes wait times (waiting for a resource like memory or hard dist), waiting for input, idle time.
              </li>
            </ul>
          </li>
          <li>
            CPU Time is how much time your program actually spends processing instructions and quite often CPU time is less than Elapsed time. 
          </li>
        </ul>
        <ul>
          <li>Latency - time to execute one instruction</li>
          <li>Throughput - number of instructions executed per unit of time</li>
        </ul>
        <br>
        <h4>Metrics of a Program/Hardware Combo</h4>
        <ul>
          <li>Cycles Per Instruction (CPI) - determined by the CPU hardware, probable for different instructions to take different number of cycles</li>
          <li>Instruction count (IC) - the number of instructions in a program. Affected by primarily the program itself, the instruction set itself (e.g. <code>slt</code> and <code>bne</code> v.s. "branch is less than", the compiler (how much does it optimizes)</li>
        </ul>
        <p>
          Number of clock cycles for a program: \(IC \cdot CPI\)<br>
          \(CPU Time = IC \cdot CPI \cdot cycleTime\)
        </p>
        <p>
          Example:<br>
          Computer A has a cycle time \(250ps\) and CPI is \(2.0\).<br>
          Computer B has a cycle time \(500ps\) and CPI is \(1.2\).<br>
          Both of them use same instruction set, running the same program. Which is faster?
        </p>
        <p>
          \(CPU TIME_{A} = IC \cdot 20 \cdot 250ps = IC \cdot 500ps\)<br>
          \(CPU TIME_{B} = IC \cdot 1.2 \cdot 500ps = IC \cdot 600ps\)
        </p>
        <p>
          So computer A is faster - how much faster?<br>
          \(CPU TIME_{B} \div CPU TIME_{A} = 600ps \div 500ps = 1.2\)
        </p>
        <p>Computer A is \(1.2\) times faster than computer B.</p>
        <p>
          Example: 3 different types of instructions, each takes a different number of cycles, 2 programs X and Y.
        </p>
        <table class="cs">
          <tr>
            <th>I-type</th>
            <th>A</th>
            <th>B</th>
            <th>C</th>
          </tr>
          <tr>
            <td>CPI</td>
            <td>1</td>
            <td>2</td>
            <td>4</td>
          </tr>
          <tr>
            <td>IC<sub>x</sub></td>
            <td>1</td>
            <td>1</td>
            <td>3</td>
          </tr>
          <tr>
            <td>IC<sub>Y</sub></td>
            <td>2</td>
            <td>4</td>
            <td>1</td>
          </tr>
        </table>
        <br>
        <p>
          What is the weighted average CPI for programs X and Y?
          \begin{align*}
            CPI_X &amp;= numbers \: of \: cycles \div numbers \: of \: instructions \\
                  &amp;= \frac{1 \cdot 1 + 2 \cdot 1 + 4 \cdot 3}{1 + 1 + 3} \\
                  &amp;= 3.0
          \end{align*}
          \begin{align*}
            CPI_Y &amp;= numbers \: of \: cycles \div numbers \: of \: instructions \\
                  &amp;= \frac{1 \cdot 2 + 2 \cdot 4 + 4 \cdot 1}{2 + 4 + 1} \\
                  &amp;= \frac{14}{7} \\
                  &amp;= 2.0
          \end{align*}
        </p>
        <p>
            So program Y is using less cycles per instruction than X since it's using quicker instructions.
        </p>
        <p>
            In summary, we can calculate CPU time required for some program as<br>
            \(CPUtime = IC \cdot CPI \cdot cycleTime = IC \cdot CPI \cdot (\frac{1}{clockRate})\)<br>
            We can try to reduce CPU time by...
        </p>
        <ul>
          <li>using less instructions</li>
          <li>Reduce our CPI time</li>
          <li>Faster clock (over-clocking)</li>
        </ul>
        <p>Tradeoffs to all of these - we have other ways to increase performance.</p>
        <br>
        <h4>Pipelining</h4>
        <p>
          The idea behind pipelining is to use all your resources as much possible, not have resources sit waiting.<br>
          A completely unpipelined task will do each task in sequence waiting for completion before starting the next.<br>
          A pipelined version will do multiple tasks in parallel, so long as there is no reason why it cannot. (The resource required is not available, or its not ready.)
        </p>
        <p>
          The best real life analogy for pipelining is laundry. We have 4 tasks (wash, dry, fold, put away) and 3 resources (washer, dryer, manual labour).
        </p>
        <p>
          In the pipelined version, we don't wait for one load to be completely finished (folded and put away) before starting the next load.<br>
          So our pipelined version is faster, by making sure our resources in use as often as possible.<br>
          In reality, it's not this clean , e.g. we have might have hang dry (take labour resource), can't fold and put away at same time.
        </p>
        <p>
          Under pipelining, can I wash one article of clothing faster than without pipelining?<br>
          Pipelining does not affect LATENCY; it only affects throughput.
        </p>
        <p>
          In MIPS, we break up our execution into 5 steps, each step takes one cycle, and all 5 can be done in the same cycle (they use different resources). So in theory, we could have 5 instructions currently executing in any one cycle (under ideal conditions).
        </p>
        <p>Let's talk about our stages of execution.</p>
        <ol>
          <li>
            Instruction Fetch (IF)
            <ul>
              <li>load instruction from memory into the CPU</li>
              <li>load from the address in <code>$PC</code></li>
            </ul>
          </li>
          <li>
            Instruction Decode (ID)
            <ul>
              <li>Determine which instruction this is and what registers it is using (decode the bits of the instruction)</li>
              <li>Read the values from the corresponding registers into the ALU (takes place in the second half of cycle)</li>
              <li>Also determine if it is a branch instruction</li>
            </ul>
          </li>
          <li>
            Execute (EX)
            <ul>
              <li>Do the operation indicated by the instruction (done in the ALU)</li>
              <li>For <code>add</code> do addition</li>
              <li>For <code>mult</code> do multiplication</li>
              <li>For  <code>lw/sw</code> compute the address  <code>$s + i</code>, etc.</li>
            </ul>
          </li>
        </ol>
      </section>
      <hr>

      <table class="buttomTable">
        <tr>
          <td class="buttomLeftTable"><a href="./cs230_1.html">&larr; Go to Module 1 - Arithmetic, Hardware, Data</a></td>
          <td class="buttomCentreTable"><a href="./cs230.html">&uarr; Go to Index</a></td>
          <td class="buttomRightTable"><a href="./cs230_3.html">&rarr; Go to Module 3 - Machine Internals&nbsp;</a></td>
        </tr>
      </table>
      <hr>

      <p>Find a typo or mistake? Feel free to contact me and I will correct it as soon as possible.</p>
      <hr>

      <div class="footer">
        <p>Thanks For Coming Here. - Calvin Li</p>
        <a href = "mailto: ck6li@edu.uwaterloo.ca" target = "_blank;"><i class = "fa fa-envelope-square"></i></a>
        <a href = "https://www.linkedin.com/in/vertckli/" target = "_blank;"><i class = "fa fa-linkedin-square"></i></a>       
        <a href = "https://www.instagram.com/vert_arts/" target = "_blank;"><i class="fa fa-instagram"></i></a>
        <a href = "https://github.com/vertli" target = "_blank;"><i class="fa fa-github-square"></i></a>
        <br>
        <p><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" /></a> This work by <a xmlns:cc="http://creativecommons.org/ns#" href="https://vertli.github.io/" property="cc:attributionName" rel="cc:attributionURL">Chun Kit (Calvin) Li</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>. Chun Kit (Calvin) Li &copy; 2017 - 2018</p>
      </div>
      <hr>

    </div>

    <script src="https://code.jquery.com/jquery-2.1.4.js"></script>
    <script src="./bootstrap-3.3.7-dist/js/bootstrap.js"></script>
    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML"></script>

  </body>
    
</html>