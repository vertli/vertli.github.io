<!DOCTYPE html>

<html>
    <head>
        <meta charset="utf-8">
        <title>CS230|Calvin Li</title>
        <link rel="stylesheet" href="./bootstrap-3.3.7-dist/css/bootstrap.css">
        <link rel="stylesheet" href="./css/style.css">
        <link rel="stylesheet" href="./css/note.css">
        <link rel="stylesheet" href="./css/cs230use.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:400,800" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Crimson+Text:600,600i" rel="stylesheet"> <!-- for math use -->
        <link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/hack-font/build/web/hack.css'> <!-- HACK!!! -->
        <!-- stylesheet found from w3school. (icon use)-->
        <link rel = "stylesheet" href = "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    </head>
    
    <body class="cs230">
        
        <nav class="navbar navbar-inverse navbar-fixed-top">
            <div class="container-fluid">
                <!-- Brand and toggle get grouped for better mobile display -->
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#topNavbar" aria-expanded="false">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="./index.html">Calvin Li</a>
                </div>

                <!-- Collect the nav links, forms, and other content for toggling -->
                <div class="collapse navbar-collapse" id="topNavbar">
                    <ul class="nav navbar-nav">
                        <li><a href="./doc/NewResume_CKLI.pdf" target="_blank;">Résumé</a></li>
                    </ul>
                    <ul class="nav navbar-nav navbar-right">
                        <li><a href="./about.html">About</a></li>
                        <li><a href="./projects.html">Projects</a></li>
                        <li class="courseNote">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Course Notes<span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <li><a href="./cs230.html">CS 230</a></li>
                                <li><a href="./cs246.html">CS 246</a></li>
                            </ul>
                        </li>
                    </ul>
                </div><!-- /.navbar-collapse -->
            </div><!-- /.container-fluid -->
        </nav>
        
        <br><br><br>
        
        <div class="container">
            
            <br>
            <table class="header">
                <tr>
                    <td colspan="100%">
                        <h1 class="title">CS 230 - Introduction to Computers and Computer Systems</h1>
                    </td>
                </tr>
                <tr>
                    <th colspan="5%">Instructor:</th>
                    <td colspan="95%">Rob Hackman</td>
                </tr>
                <tr>
                    <th colspan="5%">Office:</th>
                    <td colspan="95%">DC2551A</td>
                </tr>
                <tr>
                    <th colspan="5%">Email:</th>
                    <td colspan="95%"><a href = "mailto: r2hackma@uwaterloo.ca" target = "_blank;">r2hackma@uwaterloo.ca</a></td>
                </tr>
                <tr>
                    <th colspan="5%">Website:</th>
                    <td colspan="95%">
                        <a href="https://www.student.cs.uwaterloo.ca/~cs230/" target="_blank;">https://www.student.cs.uwaterloo.ca/~cs230/</a>
                    </td>
                </tr>
                <tr>
                    <th colspan="5%">Note:</th>
                    <td>All program codes in this course notes are provided by Prof. Hackman during class.</td>
                </tr>
            </table>
            <hr>
            
            <section id="lec4">
                <h3>Lecture 4 - 16/01/2018</h3>
                <hr>
                <b>Real Numbers</b>
                <p>
                    What is real number? For example, <span class="math">1.15</span> is real number.<br>
                    <br>
                    How does computer represent real numbers?<br>
                    First of all, let's talk about the <span class="key">Scientific Notation</span>.<br>
                    For example, <span class="math">-3.24&times;10<sup>56</sup></span>, and it is also called as <span class="key">Normalized Scientific Notation</span>.<br>
                    <br>
                    <span class="key">Normalized Scientific Notation</span>: one non-zero digit in front of the decimal point<br>
                    For example, <span class="math">0.002&times;10<sup>4</sup></span> and <span class="math">56.123&times;10<sup>8</sup></span> are not normalized.<br>
                    <br>
                    How do we write a real number in binary with scientific notation?<br>
                    For example, <span class="math">1.01<sub>2</sub> &sdot; 2<sup>1</sup></span> where the <span class="key">.</span> after 1 and before 0 is called a binary point (radix point generally).<br>
                    So what does <span class="math">1.01<sub>2</sub></span> mean?<br>
                    Before we answer this answer, we need to ask ourselves, what does <span class="math">1.01<sub>10</sub></span> mean?<br>
                    <span class="math">1.01<sub>10</sub> = 1 &sdot; 10<sup>0</sup> + 0 &sdot; 10<sup>-1</sup> + 1 &sdot; 10<sup>-2</sup></span><br>
                    With the same idea, we have...<br>
                    <span class="math">1.01<sub>2</sub> = 1 &sdot; 2<sup>0</sup> + 0 &sdot; 2<sup>-1</sup> + 1 &sdot; 2<sup>-2</sup> = 1 +  1/4 = 1.25<sub>10</sub></span><br>
                    <br>
                    How do we represent real numbers in our machines?<br>
                    We use what's called <span class="math">floating point number</span>.<br>
                    The reason it is called this name because it allow the binary point to "float" by changing the exponent.<br>
                    The opposite would be fixed point.<br>
                    <br>
                    Floating point is of the form <span class="math">I.F &sdot; B<sup>E</sup></span> where...<br>
                </p>
                <ul>
                    <li><span class="math">I</span>: Integer</li>
                    <li><span class="math">F</span>: Fractional</li>
                    <li><span class="math">B</span>: Base</li>
                    <li><span class="math">E</span>: Exponent</li>
                    <li><span class="math">I.F</span>: Significand (or "Mantissa")</li>
                </ul>
                <p>
                    Our floats are always normalized, so <span class="math">I</span> is always <span class="math">1</span>.<br>
                </p>
                <ul>
                    <li>left out of our representation is called "implicit/hidden point"</li>
                </ul>
                <p>
                    The base in always <span class="math">2</span> because we are in binary!<br>
                    So these are the components of our floating point.<br>
                    <br>
                    How does float represent in a machine? the standard <span class="key">IEEE 754</span>.<br>
                    We have single precision 32 bits, double precision 64 bits.<br>
                    <br>
                    Single Precision Float: 32 bits<br>
                </p>
                <img src="./image/cs230/lec4/4_1.png">
                <p>
                    We have 1 bit for the sign bit (green box), 8 bits for the exponent (red boxes) and the rest of the boxes (purple) are for the fractional.<br>
                    Note that integer and base are not represented since base is 2 and integer is always 1 except for special subnormal numbers.<br>
                    <br>
                    Also, we need to know that the exponent bits do not represent exactly the exponent <span class="math">e</span> in <span class="math">I.F &sdot; B<sup>e</sup></span>. Why?<br>
                    The standard uses a bias value, so the exponent bits represent an unsigned number and you subtract the bias from it.<br>
                    Bias for single precision is 127.<br>
                    <br>
                    So to calculate the value <span class="math">(-1)<sup>5</sup> &sdot; (I.F)&dot;2<sup>e-127</sup></span>, let's try calculating the decimal value of single precision float:<br>
                    <span class="math">0 10000100 11000000000000000000000</span><br>
                    The first <span class="math">0</span> is the sign bit.<br>
                    Then, <span class="math">10000100</span> are the exponent bits: <span class="math">10000100 = 128 + 4 - bias = 132 - 127 = 5</span><br>
                    The rest of the bits <span class="math">11000000000000000000000</span> are the fractional bits where<br>
                    &nbsp;&nbsp;<span class="math">1.11 = 1 + 2<sup>-1</sup> + 2<sup>-2</sup> = 1 + 0.5 + 0.25 = 1.75</span><br>
                    So, we now have:<br>
                </p>
                <table class="math">
                    <tr>
                        <td>(-1)<sup>S</sup> &sdot; (I.F) &sdot; 2<sup>e-127</sup></td>
                        <td>&nbsp;= (-1)<sup>0</sup> &sdot; (1.11) &sdot; 2<sup>5</sup></td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= 1 &sdot; (1.75) &sdot; 2<sup>5</sup></td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= 56.0</td>
                    </tr>
                </table>
                <p>
                    Let's consider a simplified 8-bit representation for floats: 1 bit for sign bit, 3 bits for exponent (bias = 3) and 4 bits for fractional.<br>
                    Note that bias is a choosing value, so you don't have to worry about it.<br>
                    <br>
                    Example: Express 4.5 in our simplified format.<br>
                    Note that <span class="math">4<sub>10</sub> = 100<sub>2</sub></span> and <span class="math">0.5<sub>10</sub> = 1/2<sub>10</sub> = 2<sup>-1</sup> = 0.1<sub>2</sub></span>.<br>
                    Thus, <span class="math">4.5<sub>10</sub> = 100.1<sub>2</sub></span>.<br>
                    Then we have <span class="math">100.1 &sdot; 2<sup>0</sup></span> and normalize it, we get <span class="math">1.001 &sdot; 2<sup>2</sup></span>.<br>
                    Next, the exponent is <span class="math">e + bias = 2 + 3 = 5 = 101<sub>2</sub></span> and sign bit is 0 since 4.5 is a positive number.<br>
                    So, we get 0 101 0010 as our final answer, where 0 is the sign bit, 101 is the exponent bits and 0010 is the fractional bits.<br>
                    <br>
                    Arithmetic with floats is easy.<br>
                    For addition, just set the exponents the same and add the significands (regular addition).<br>
                    <br>
                    Example: Add 1.25 and 2.125 in our simplified format.<br>
                    Note that <span class="math">1.25 = 1.01 &sdot; 2<sup>0</sup></span>.<br>
                    So we know that <span class="math">F = 0100</span>, <span class="math">E = 0 + 3 = 3 = 011</span> and <span class="math">S = 0</span>.<br>
                    Thus, <span class="math">1.25<sub>10</sub> = 0 011 0100<sub>2</sub></span>.<br>
                    Also, <span class="math">2.125 = 1.0001 &sdot; 2<sup>1</sup></span>.<br>
                    So we know that <span class="math">F = 0001</span>, <span class="math">E = 1 + 3 = 4 = 100</span> and <span class="math">S = 0</span>.<br>
                    Thus, <span class="math">2.125<sub>10</sub> = 0 100 0001<sub>2</sub></span>.<br>
                </p>
                <table class="math">
                    <tr>
                        <td>1.25 + 2.125</td>
                        <td>&nbsp;= 1.01 &sdot; 2<sup>0</sup> + 1.0001 &sdot; 2<sup>1</sup></td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= 1.01 &sdot; 2<sup>0</sup> + 10.001 &sdot; 2<sup>0</sup></td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= 11.011 &sdot; 2<sup>0</sup></td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= 1.1011 &sdot; 2<sup>1</sup></td>
                    </tr>
                </table>
                <p>
                    From the normalized scientific notation <span class="math">1.1011 &sdot; 2<sup>1</sup></span>, we know that <span class="math">F = 1011</span>, <span class="math">E = 1 + 3 = 4 = 100</span> and <span class="math">S = 0</span>.<br>
                    So our final answer is 0 100 1011.<br>
                    <br>
                    For multiplication, we add exponents, then multiply significands.<br>
                    For example, <span class="math">1.5 &sdot; 2.25</span>.<br>
                    Note that <span class="math">1.5 = 0 011 100</span> and <span class="math">2.25 = 0 100 0010</span>.<br>
                    Step 1 - Add Exponents:<br>
                    <span class="math">(E<sub>1.5</sub> - bias) + (E<sub>2.25</sub> - bias) = (011 - 011) + (100 - 011) = 1 = e</span><br>
                    So <span class="math">E = 1 + 3 = 4 = 100<sub>2</sub></span>.<br>
                    Step 2 - Multiply Significands:<br>
                </p>
                <table class="math">
                    <tr>
                        <td>1.1000 &times; 1.0010</td>
                        <td>&nbsp;= (1 &sdot; 1.001) + (0.1 &sdot; 1.001)</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= 1.001 + 0.1001</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= 1.1011</td>
                    </tr>
                </table>
                <p>
                    So our new fractional bits are 1011, new exponent bits are 100 and new sign bit is 0.<br>
                    Therefore, <span class="math">1.5 &sdot; 2.25 = 0 100 1011</span>.<br>
                    <br>
                    However, examining our simplified format we can see the problems that arise in floating point numbers.<br>
                    The first problem is there exists infinite numbers between 0 and 1, but we cannot represent infinite numbers within 32 bits!<br>
                    For example, consider 15.25 in our 8-bit system:<br>
                    <span class="math">15.25 = 1111.01 &sdot; 2<sup>0</sup> = 1.11101 &sdot; 2<sup>3</sup></span><br>
                    We need 5 bits for the fraction but we only have 4 bits to use!<br>
                    So we get an overflow, which is <span class="math">1.1110 &sdot; 2<sup>3</sup></span>.<br>
                    If we round up, we get 15.5; if we round down, we get 15.0.<br>
                    <br>
                    So overflow can happen; they get represented as <span class="key">inf</span> (also occurs for divide by 0).<br>
                    <br>
                    For IEEE 754,<br>
                </p>
                <table class="textTable">
                    <tr>
                        <th>Exponent Bits</th>
                        <th>Fractional Bits</th>
                        <th>Value/Type</th>
                    </tr>
                    <tr>
                        <td>0000 0000</td>
                        <td>00...00</td>
                        <td>0</td>
                    </tr>
                    <tr>
                        <td>0000 0000</td>
                        <td>non-zero</td>
                        <td>subnormal</td>
                    </tr>
                    <tr>
                        <td>0000 0000 1...1111 1110</td>
                        <td>Any</td>
                        <td>normal number</td>
                    </tr>
                    <tr>
                        <td>1111 1111</td>
                        <td>00...00</td>
                        <td>infinity</td>
                    </tr>
                    <tr>
                        <td>1111 1111</td>
                        <td>non-zero</td>
                        <td>NaN</td>
                    </tr>
                </table>
                <p>
                    What is <span class="key">NaN</span>? It means "not a number".<br>
                    For example, &radic;-1, &infin;/&infin; and &infin; &sdot; 0.<br>
                    <br>
                    If we didn't create a special case for subnormal numbers, then the gap between 0 and our smallest representable number would be:<br>
                    <span class="math">0 000 0000<sub>2</sub> = 1.0000 &sdot; 2<sup>-3</sup> = 0.1255</span><br>
                    That is a large gap! Often we talk about small numbers.<br>
                    This also means our gap between adjacent numbers is <span class="math">0.0001 &sdot; 2<sup>-3</sup> = 2<sup>-7</sup></span>.<br>
                    <br>
                    Instead, we treat subnormal numbers as a special case.<br>
                    So, when we would have (0 - bias) exponent instead we do (1 - bias) as exponent and have the implicit bit be 0.<br>
                    This is how to interpret subnormal numbers: <span class="math">(-1)<sup>S</sup> &sdot; (0.F) &sdot; 2<sup>1 - bias</sup></span><br>
                </p>
                <ul>
                    <li>Smallest number (&gt;0) is <span class="math">1.00 &sdot; 2<sup>-2</sup></span></li>
                    <li>Gap between number is <span class="math">0.0001 &sdot; 2<sup>-2</sup></span> (worse)</li>
                    <li>Smallest subnormal number is <span class="math">0.0001 &sdot; 2<sup>-2</sup> = 0.01525</span> (much better!)</li>
                </ul>
                <p>
                    So using subnormal numbers we get a larger gap between our numbers (largest/smallest possible exponent).<br>
                    But we get closer to 0 before losing all our precision.<br>
                    Tradeoff is the gaps between representable numbers and how close to 0 we can get.<br>
                </p>
                <br>
                <b>Gradual Underflow</b>
                <p>
                    Don't forget floating point is not exact, it is only an approximation of real numbers.<br>
                    For example, 0.1 cannot be represented in IEEE 754.<br>
                    Therefore, don't use <code>==</code> on floats.<br>
                    Also, associativity and distribution or arithmetic operators are not guaranteed!<br>
                </p>
                <br>
                <b>Assembly Language</b>
                <p>
                    Recall: Computers only understand set instructions which are group of 1's and 0's (machine code).<br>
                    <br>
                    A assembly language is one step up from that - basis operations that operate on registers.<br>
                    It has a direct translation to machine code.<br>
                    <br>
                    A program called an assembler translates assembly to machine code.<br>
                    <br>
                    In order to understand how computers/programs work, we are going to study <span class="key">MIPS</span> on assembly language.<br>
                    Because assembly languages operate on registers (actual hardware of CPU), assembly languages are tied to hardware.<br>
                    Hence why we use an emulator.<br>
                    <br>
                    <span class="key">MIPS</span> is an acronym for Microprocessor without Interlocked Pipeline Stages; we will talk about the meaning later (someday in the future).<br>
                    <br>
                    In MUPS, we have 32 registers (which are labeled with $0 to $31).<br>
                    Each register is 32 bits.<br>
                    Why we only have 32 registers, not more? More means slower - we need more bits to store a register.<br>
                    For now, we only need 5 bits to store 32 registers.<br>
                    <br>
                    <span class="key">Special Registers</span><br>
                    PC (program counter) holds the memory address of the next instruction; each instruction done increments it by 4, or it can be manipulator.<br>
                    <br>
                    <span class="key">Register 0 ($0)</span>: It is the constant 0; otherwise, the machine will die!<br>
                    <br>
                    <span class="key">Conventions</span><br>
                    $31 is the return address and $30, $29 and $28 are special.<br>
                </p>
            </section>
            <hr>
            
            <section id="lec5">
                <h3>Lecture 5 - 18/01/2018</h3>
                <hr>
                <b>Announcements:</b>
                <p>
                    Assignment 1 is due tomorrow!<br>
                    Midterm is 3 weeks after today!<br>
                </p>
                <br>
                <b>Midterm</b>
                <p>
                    In midterm, you can have one 8.5" &times; 11" (inches) single-sided "cheat sheet".<br>
                    You can write anything on the cheat sheet, but only single sided.<br>
                    It will be taken away during midterm if it is NOT single sided.<br>
                    It will be collected with your midterm paper.<br>
                    One more thing, this cheat sheet must be hand-written.<br>
                </p>
                <br>
                <b>MIPS (Microprocessor without Interlocked Pipeline Stages)</b>
                <p>
                    MIPS does NOT stand for "Millions for Instructions Per Second".<br>
                    <br>
                    It is an assembly language; it has direct translation to machine code.<br>
                    We use assembler to translate from assembly language to machine code.<br>
                    An assembly language operates directly on the registers in the CPU, so it is tied to the hardware.<br>
                    <br>
                    In MIPS, we have 32 registers labeled with 0 to 31.<br>
                </p>
                <br>
                <b>Special Registers</b>
                <ul>
                    <li>Program Counter (PC) holds the address of the next instruction to execute</li>
                    <li>Register 0 ($0): constant 0</li>
                    <li>Conversion $31: return address</li>
                    <li>Conversions $28, $29, $30: global, stack, frame, etc.; our emulator uses $30 for stack pointer (SP)</li>
                </ul>
                <br>
                <b>Instructions</b>
                <p>
                    They have up to 3 operands, often registers.<br>
                    When using 3 operands, the first one is the destination, the other two are sources.<br>
                    <br>
                    Example: Addition<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>add $8, $9, $10<br>
                    </code></pre>
                </span>
                <p>
                    This instruction add the values stored in register 9 and register 10 together, then store the result in register 8.<br>
                    <br>
                    The general form for these R-type instruction (register instruction) is:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>add $d, $s, $t<br>
                    </code></pre>
                </span>
                <p>
                    <code>$d</code> is the destination register (Rd); <code>$s</code> and <code>$t</code> are the source registers, which are denoted as Rs and Rt.<br>
                    The instruction <span class="add">add</span> means <span class="math"> d = s + t</span> and the values stored in those registers.<br>
                    <br>
                    Example: Subtraction<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>sub $d, $s, $t &nbsp;; d = s - t<br>
                    </code></pre>
                </span>
                <p>
                    Note that <code>;</code> is how to start a comment in MIPS.<br>
                    <br>
                    What if we want a value that does not already exist in one of our registers? We can use <span class="key">immediate</span> instruction.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>addi $t, $s, i<br>
                    </code></pre>
                </span>
                <p>
                    In here, <code>$t</code> is the destination register and <code>$s</code> is the source register.<br>
                    How about <code>i</code>? This is an I-type instruction, which means we are using a literal value.<br>
                    <br>
                    Example: Add the value in register 8 to the literal value 42, then store the result in register 15.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>addi $15, $8, 42<br>
                    </code></pre>
                </span>
                <p>
                    Example: Add 10 and 24, subtract 3, store result in $3.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>addi $1, $0, 10 &nbsp;; initialize $1 to 10<br>
                        <span class="cline">02&nbsp;&nbsp;</span>addi $2, $0, 24 &nbsp;; initialize $2 to 24<br>
                        <span class="cline">03&nbsp;&nbsp;</span>add &nbsp;$3, $1, $2 &nbsp;; add the value 10 and 24 in register 1 and register 2, store result in register 3<br>
                        <span class="cline">05&nbsp;&nbsp;</span>addi $3, $3, -3 &nbsp;; subtract 3 from value in register 3, store result in register 3<br>
                        <span class="cline">06&nbsp;&nbsp;</span>jr &nbsp;&nbsp;$31 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; need this to terminate program in emulator<br>
                    </code></pre>
                </span>
                <br>
                <p>
                    <span class="key">Multiplication</span><br>
                    Note that we have 32 bits in our registers.<br>
                    If we multiply 2 32-bit numbers together, the result could have as many as 64 bits.<br>
                    Hence, we have the special registers "hi" and "lo" to store the result.<br>
                </p>
                <table>
                    <tr>
                        <td>&nbsp;hi</td>
                        <td colspan="5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
                        <td>&nbsp;lo</td>
                        <td colspan="5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
                    </tr>
                    <tr>
                        <td colspan="6" class="tableBox">&nbsp;32 bits&nbsp;</td>
                        <td colspan="6" class="tableBox">&nbsp;32 bits&nbsp;</td>
                    </tr>
                </table>
                <br>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>mul $s, $t &nbsp;; $s&times;$t, place result in hi and lo<br>
                    </code></pre>
                </span>
                <p>
                    <span class="key">Special instructions to copy from hi and lo:</span><br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>mfhi $d &nbsp;; "move from hi" and copy the value in $hi to $d<br>
                        <span class="cline">02&nbsp;&nbsp;</span>mflo $d &nbsp;; "move from lo" and copy the value in $lo to $d<br>
                    </code></pre>
                </span>
                <p>
                    <span class="key">Division</span>: <code>div $s, $t  ; $s / $t</code><br>
                    It is always integer division; it place the quotient in $lo and the remainder in $hi.<br>
                    <br>
                    Example: Calculate average of 3 numbers stored in $3, $4 and $5, then store result in #3.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>; calculate ($3 + $4 + $5) / $3<br>
                        <span class="cline">02&nbsp;&nbsp;</span>add &nbsp;$3, $4, $3<br>
                        <span class="cline">03&nbsp;&nbsp;</span>add &nbsp;$3, $5, $3<br>
                        <span class="cline">04&nbsp;&nbsp;</span>addi $6, $0, 3<br>
                        <span class="cline">05&nbsp;&nbsp;</span>div &nbsp;$3, $6<br>
                        <span class="cline">06&nbsp;&nbsp;</span>mflo $3<br>
                        <span class="cline">07&nbsp;&nbsp;</span>jr &nbsp;&nbsp;$31<br>
                    </code></pre>
                </span>
                <p>
                    So now we can do basic math. Yeah!<br>
                    But what if we cant to do basic math lots of times?<br>
                    In Python, we have constructs like while loop, for loop, recursion for repetition.<br>
                    If we want repetition in MIPS, we need to manipulate $PC.<br>
                    <br>
                    <span class="key">Conditional Branches</span><br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>beq $s, $t, label &nbsp;; branch if equal<br>
                        <span class="cline">02&nbsp;&nbsp;</span>; if $s == $t, then goto label<br>
                        <span class="cline">03&nbsp;&nbsp;</span>; overwrite $pc with the address of the instruction at label<br>
                        <span class="cline">04&nbsp;&nbsp;</span><br>
                        <span class="cline">05&nbsp;&nbsp;</span>bne $s, $t, label &nbsp;; branch if not equal<br>
                        <span class="cline">06&nbsp;&nbsp;</span>; if $s != $t, then goto label<br>
                    </code></pre>
                </span>
                <p>
                    Example: Write a loop with MIPS.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>addi $1, $0, 10<br>
                        <span class="cline">02&nbsp;&nbsp;</span>loopStart:<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;addi $1, $1, -1<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;; loop body<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;bne $1, $0, loopStart<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;jr $31<br>
                    </code></pre>
                </span>
                <p>
                    Example: Calculate <span class="math">0 + 1 + ... + n</span> where <span class="math">n</span> is stored in $8, and store result in $7.<br>
                    In Python...<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>;; assume n already initialized<br>
                        <span class="cline">02&nbsp;&nbsp;</span>iter = n<br>
                        <span class="cline">03&nbsp;&nbsp;</span>y = 0<br>
                        <span class="cline">04&nbsp;&nbsp;</span>while (iter != 0):<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;y = y + iter<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;iter = iter - 1<br>
                    </code></pre>
                </span>
                <p>
                    In MIPS: assume n = $8, y = $7 and iter = $9<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>add $9, $8, $0 &nbsp;&nbsp;; iter = n<br>
                        <span class="cline">02&nbsp;&nbsp;</span>add $7, $0, $0 &nbsp;&nbsp;; y = 0<br>
                        <span class="cline">03&nbsp;&nbsp;</span>beq $9, $0, end &nbsp;; skip if iter == 0<br>
                        <span class="cline">04&nbsp;&nbsp;</span>loopStart:<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;add &nbsp;$7, $7, $8  ; y = y + iter<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;addi $9, $9, -1  ; iter = iter - 1<br>
                        <span class="cline">07&nbsp;&nbsp;</span>&nbsp;&nbsp;bne &nbsp;$9, $0, loopStart<br>
                        <span class="cline">08&nbsp;&nbsp;</span>end:<br>
                        <span class="cline">09&nbsp;&nbsp;</span>&nbsp;&nbsp;jr $31<br>
                    </code></pre>
                </span>
                <p>
                    There are more instructions. For example...<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>slt $d, $s, $t<br>
                    </code></pre>
                </span>
                <p>
                    This instruction is "set less than".<br>
                    If $s &lt; $t, then $d := 1, otherwise $d := 0.<br>
                    It is just a comparison operator with the result (T/F) store in $d.<br>
                    So we can combine this with branches to simulate conditional.<br>
                    <br>
                    Example: if x &lt; y, set x := x - y<br>
                    In Python, we do...<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>if (x &lt; y):<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;x = x - y<br>
                    </code></pre>
                </span>
                <p>
                    In MIPS, let x = $7, y = $8<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>slt $6, $7, $8<br>
                        <span class="cline">02&nbsp;&nbsp;</span>beq $6, $0, done<br>
                        <span class="cline">03&nbsp;&nbsp;</span>sub $7, $7, $8<br>
                        <span class="cline">04&nbsp;&nbsp;</span>done:<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;jr $31<br>
                    </code></pre>
                </span>
                <br>
                <b>Memory</b>
                <p>
                    Memory region forms in MIPS is 2<sup>32</sup> bytes (4GiB).<br>
                    Note that <span class="math">2<sup>30</sup> = 1</span> gibibyte and so <span class="math">2<sup>30</sup> &times; 4 = 4</span> gibibytes <span class="math">= 2<sup>32</sup></span>.<br>
                    Memory is essentially a huge array, addresses are the indices or rather always are small bits of memory, indices are address offsets.<br>
                    <br>
                    In this course, we use word-aligned memory access/addressing (4-byte).<br>
                    MIPS word = 32 bits<br>
                </p>
                <table>
                    <tr>
                        <td>&nbsp;</td>
                        <td colspan="4" class="textTable">32 bits</td>
                    </tr>
                    <tr>
                        <td>0</td>
                        <td class="tableBox">0</td>
                        <td class="tableBox">1</td>
                        <td class="tableBox">2</td>
                        <td class="tableBox">3</td>
                    </tr>
                    <tr>
                        <td>4</td>
                        <td class="tableBox">0</td>
                        <td class="tableBox">1</td>
                        <td class="tableBox">2</td>
                        <td class="tableBox">3</td>
                    </tr>
                    <tr>
                        <td>8</td>
                        <td class="tableBox">0</td>
                        <td class="tableBox">1</td>
                        <td class="tableBox">2</td>
                        <td class="tableBox">3</td>
                    </tr>
                    <tr>
                        <td>...</td>
                        <td class="tableBox">...</td>
                        <td class="tableBox">...</td>
                        <td class="tableBox">...</td>
                        <td class="tableBox">...</td>
                    </tr>
                </table>
                <p>
                    Accessing Memory: <code>lw $t, i($s)  ; load word</code><br>
                    It treats the value in register $s as an address for memory, add i to $s.<br>
                    Then the result as an address, copy the word (32 bits) stored at that address into register t.<br>
                    Note that i = $s <span class="key">MUST</span> be word aligned (divisible by 4).<br>
                    <br>
                    Example: <code>lw  $2, 4($1)</code>
                </p>
                <table>
                    <tr>
                        <th colspan="2" class="textTable">&nbsp;Register:&nbsp;</th>
                        <td></td>
                        <th colspan="2" class="textTable">&nbsp;Memory:&nbsp;</th>
                    </tr>
                    <tr>
                        <td class="textTable">&nbsp;0&nbsp;</td>
                        <td class="tableBox">&nbsp;0x00000000&nbsp;</td>
                        <td class="textTable">&nbsp;</td>
                        <td class="textTable">&nbsp;address&nbsp;</td>
                        <td class="textTable">&nbsp;value&nbsp;</td>
                    </tr>
                    <tr>
                        <td class="textTable">&nbsp;1&nbsp;</td>
                        <td class="tableBox">&nbsp;0x00000010&nbsp;</td>
                        <td class="textTable">&nbsp;</td>
                        <td class="textTable">&nbsp;0&nbsp;</td>
                        <td class="textTable">&nbsp;12&nbsp;</td>
                    </tr>
                    <tr>
                        <td class="textTable">&nbsp;2&nbsp;</td>
                        <td class="tableBox">&nbsp;0x00000015&nbsp;</td>
                        <td class="textTable">&nbsp;</td>
                        <td class="textTable">&nbsp;4&nbsp;</td>
                        <td class="textTable">&nbsp;42&nbsp;</td>
                    </tr>
                    <tr class="textTable">
                        <td colspan="3">&nbsp;</td>
                        <td>&nbsp;8&nbsp;</td>
                        <td>&nbsp;9&nbsp;</td>
                    </tr>
                    <tr class="textTable">
                        <td colspan="3">&nbsp;</td>
                        <td>&nbsp;12&nbsp;</td>
                        <td>&nbsp;17&nbsp;</td>
                    </tr>
                    <tr class="textTable">
                        <td colspan="3">&nbsp;</td>
                        <td>&nbsp;16&nbsp;</td>
                        <td>&nbsp;125&nbsp;</td>
                    </tr>
                    <tr class="textTable">
                        <td colspan="3">&nbsp;</td>
                        <td>&nbsp;20&nbsp;</td>
                        <td>&nbsp;21&nbsp;</td>
                    </tr>
                    <tr>
                        <td colspan="3">&nbsp;</td>
                        <td>&nbsp;24&nbsp;</td>
                        <td>&nbsp;100&nbsp;</td>
                    </tr>
                    <tr>
                        <td colspan="3">&nbsp;</td>
                        <td>&nbsp;...&nbsp;</td>
                        <td>&nbsp;...&nbsp;</td>
                    </tr>
                </table>
                <p>
                    Since the value in $1 is 16, then <span class="math">4($1) = 4 + $1 = 4 + 16 = 20</span>.<br>
                    So we are looking for the address 20.<br>
                    Therefore, we need to store the value 21 into $2.<br>
                    <br>
                    Make sure you can differentiate between:<br>
                </p>
                <ul>
                    <li>register <u>number</u> (0 - 31)</li>
                    <li>
                        register value (e.g. $20)
                        <ul>
                            <li>contents of the registers</li>
                        </ul>
                    </li>
                    <li>memory address</li>
                    <li>memory contents (value)</li>
                </ul>
                <p>
                    Example: Read values stored in memory addresses 64 and 72, add them together, store the result in address 80.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>addi &nbsp;$1, $0, 64<br>
                        <span class="cline">02&nbsp;&nbsp;</span>lw &nbsp;&nbsp;&nbsp;$2, 0($1)<br>
                        <span class="cline">03&nbsp;&nbsp;</span>lw &nbsp;&nbsp;&nbsp;$3, 8($1)<br>
                        <span class="cline">04&nbsp;&nbsp;</span>add &nbsp;&nbsp;$4, $2, $3<br>
                        <span class="cline">05&nbsp;&nbsp;</span>sw &nbsp;&nbsp;&nbsp;$4, 16($1) ; save word<br>
                        <span class="cline">06&nbsp;&nbsp;</span>jr &nbsp;&nbsp;$31<br>
                    </code></pre>
                </span>
                <p>
                    Remember a program is just a bunch of machine code instructions (1's and 0's).<br>
                    <br>
                    What do our 32-bit instructions look like in memory?<br>
                    R-type Instructions (e.g. add)<br>
                </p>
                <table class="textTable">
                    <tr>
                        <td>op</td>
                        <td>Rs</td>
                        <td>Rt</td>
                        <td>Rd</td>
                        <td>shamt</td>
                        <td>func</td>
                    </tr>
                    <tr>
                        <td>6 bits</td>
                        <td>5 bits</td>
                        <td>5 bits</td>
                        <td>5 bits</td>
                        <td>5 bits</td>
                        <td>6 bits</td>
                    </tr>
                </table>
                <br>
                <ul>
                    <li>op: op-code</li>
                    <li>Rs, Rt, Td: the source registers and the destination register</li>
                    <li>shamt: shift amount (only used for shift instructions)</li>
                    <li>func: works together with op-code to denote arithmetic instructions</li>
                </ul>
            </section>
            <hr>
            
            <section id="lec6">
                <h3>Lecture 6 - 23/01/2018</h3>
                <hr>
                <p>
                    Recall: A program is just a series of instructions, and instructions are just specific groups of 1's and 0's.<br>
                    <br>
                    So, what does a program look like in memory?<br>
                    In MIPS, we have 32-bit instructions with 3 different instruction types: R-type, I-type and J-type.<br>
                </p>
                <b>R-type Instruction</b>
                <table class="textTable">
                    <tr>
                        <td>Op-code</td>
                        <td>R<sub>s</sub></td>
                        <td>R<sub>t</sub></td>
                        <td>R<sub>d</sub></td>
                        <td>shamt</td>
                        <td>func</td>
                    </tr>
                    <tr>
                        <td>6 bits</td>
                        <td>5 bits</td>
                        <td>5 bits</td>
                        <td>5 bits</td>
                        <td>5 bits</td>
                        <td>6 bits</td>
                    </tr>
                </table>
                <p>
                    R<sub>s</sub>, R<sub>t</sub>: the source registers.<br>
                    R<sub>d</sub>: the destination register.<br>
                    shamt: shift amount, only used for shift operations.<br>
                    func: 6 bits used in tandem with the op-code to denote arithmetic instructions.<br>
                </p>
                <b>I-type Instruction</b>
                <table class="textTable">
                    <tr>
                        <td>Op-code</td>
                        <td>R<sub>s</sub></td>
                        <td>R<sub>t</sub></td>
                        <td>Immediate Value</td>
                    </tr>
                    <tr>
                        <td>6 bits</td>
                        <td>5 bits</td>
                        <td>5 bits</td>
                        <td>16 bits</td>
                    </tr>
                </table>
                <br>
                <b>J-type Instruction</b>
                <table class="textTable">
                    <tr>
                        <td>Op-code</td>
                        <td>Address</td>
                    </tr>
                    <tr>
                        <td>6 bits</td>
                        <td>26 bits</td>
                    </tr>
                </table>
                <br>
                <p>
                    Example: What is the binary represent of <code>add $3, $1, $2</code>?<br>
                    According to our MIPS Reference Sheet, we know that...<br>
                    The op-code binary is <code>000000</code>, the shamt binary is <code>00000</code> and the function binary is <code>100000</code>.<br>
                    Now we need to find the binary of R<sub>s</sub>($1), R<sub>t</sub>($2) and R<sub>d</sub>($3).
                    Notice that the binary of 3 is <code>00011</code>, the binary of 1 is <code>00001</code> and the binary of 2 is <code>00010</code>.<br>
                    Therefore, the binary represent of <code>add $3, $1, $2</code> is <code>0000 0000 0010 0010 0001 1000 0010 0000</code>.<br>
                    <br>
                    Example: Given <code>0000 0000 1000 0101 0011 1000 0010 1010</code>, what is this instruction?<br>
                    The first 6 bits <code>000000</code> is for op-code, so we know that this is a R-type instruction.<br>
                    Then the last 6 bits <code>101010</code> is for function, and according to our MIPS Reference Sheet, the instruction is <code>slt</code>.<br>
                    Then we get 4 from the R<sub>s</sub> bits <code>00100</code>, 5 from the R<sub>t</sub> bits <code>00101</code>, 7 from the R<sub>d</sub> bits <code>00111</code>, and the shamt bits are <code>00000</code>.<br>
                    Therefore, <code>0000 0000 1000 0101 0011 1000 0010 1010</code> is <code>slt $7, $5, %7</code>.<br>
                    <br>
                    Note that the binary represent of shamt is always <code>00000</code> and we don't have to worry/carry about it in this course.<br>
                    <br>
                    Example: Find the binary represent of <code>addi $5, $0, 42</code>.<br>
                    Answer: <code>0010 0000 0000 0101 0000 0000 0010 1010</code> where <code>001000</code> is the op-code, <code>00000</code> is the R<sub>s</sub>($0), <code>00101</code> is the R<sub>t</sub>($5) and <code>0000000000101010</code> is the immediate value 42.<br>
                    <br>
                    In this course, our programs start at memory address 0 - the "top" of memory.<br>
                    That means our program counter(PC) starts at 0 and increments by 4 each instruction.<br>
                </p>
                <table>
                    <tr>
                        <td class="textTable">&nbsp;0&nbsp;</td>
                        <td class="tableBox">&nbsp;instruction 1&nbsp;</td>
                    </tr>
                    <tr>
                        <td class="textTable">&nbsp;4&nbsp;</td>
                        <td class="tableBox">&nbsp;instruction 2&nbsp;</td>
                    </tr>
                    <tr>
                        <td class="textTable">&nbsp;8&nbsp;</td>
                        <td class="tableBox">&nbsp;instruction 3&nbsp;</td>
                    </tr>
                    <tr>
                        <td class="textTable">&nbsp;12&nbsp;</td>
                        <td class="tableBox">&nbsp;instruction 4&nbsp;</td>
                    </tr>
                    <tr>
                        <td class="textTable">&nbsp;...&nbsp;</td>
                        <td class="tableBox">&nbsp;...&nbsp;</td>
                    </tr>
                </table>
                <br>
                <p>
                    Generally, our data is stored after our program.<br>
                    We could put it in the middle and jump over it, but why bother?<br>
                    <br>
                    Immediate instructions limit us to 16-bit immediate value, but we have 32 bits of space in our registers! It seems wasteful.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>lis&nbsp;&nbsp;&nbsp;$d&nbsp;&nbsp;&nbsp;&nbsp;; instruction is 1 word<br>
                        <span class="cline">02&nbsp;&nbsp;</span>.word 4254&nbsp;&nbsp;; value is 1 word<br>
                    </code></pre>
                </span>
                <br>
                <p>
                    The r-type instruction <code>lis $d</code> means "load immediate and skip".<br>
                    It treats the next 32 bits as data, load into <code>$d</code> and skip over that word.<br>
                    In memory...<br>
                </p>
                <table>
                    <tr>
                        <td class="textTable">&nbsp;0&nbsp;</td>
                        <td class="tableBox">&nbsp;instruction 1&nbsp;</td>
                        <td class="textTable">&nbsp;<code>lis $d</code>&nbsp;</td>
                    </tr>
                    <tr>
                        <td class="textTable">&nbsp;4&nbsp;</td>
                        <td class="tableBox">&nbsp;4254&nbsp;</td>
                    </tr>
                    <tr>
                        <td class="textTable">&nbsp;8&nbsp;</td>
                        <td class="tableBox">&nbsp;instruction 3&nbsp;</td>
                    </tr>
                    <tr>
                        <td class="textTable">&nbsp;12&nbsp;</td>
                        <td class="tableBox">&nbsp;instruction 4&nbsp;</td>
                    </tr>
                    <tr>
                        <td class="textTable">&nbsp;...&nbsp;</td>
                        <td class="tableBox">&nbsp;...&nbsp;</td>
                    </tr>
                </table>
                <br>
                <p>
                    Alright, let's talk about I/O (Input/Output).<br>
                    How can we do I/O in MIPS?<br>
                    We have special memory address that lie outside of our "real" memory space, and treat those addresses as the location of our I/O devices.<br>
                    <br>
                    So for us, <code>0xFFFF0004</code> is our input device.<br>
                    <code>lw</code> when used of this address receives 1 byte of our destination register.<br>
                    <br>
                    To write, we use <code>0xFFFF000C</code> as the address of our output device.<br>
                    USe <code>sw $t, i($s)</code> on this address, to put the lowest order byte of your source register, interpreted as an ASCII character to the screen.<br>
                    <br>
                    If you had 65 in one register, and 65+2<sup>24</sup> in another , and printed both - they would both print 'A'.<br>
                    <br>
                    Example: Print out everything you read from input, only stop when you see the ASCII character for ESC.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;lis&nbsp;&nbsp;$1<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0xffff0004&nbsp;&nbsp;&nbsp;&nbsp;; Input address<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;lis&nbsp;&nbsp;$2<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0xffff000c&nbsp;&nbsp;&nbsp;&nbsp;; Output address<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;addi $3, $0, 0x1b&nbsp;&nbsp;&nbsp;; ESC char in ASCII<br>
                        <span class="cline">06&nbsp;&nbsp;</span>loop:<br>
                        <span class="cline">07&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;lw&nbsp;&nbsp;&nbsp;$4, 0($1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Read char from input<br>
                        <span class="cline">08&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;sw&nbsp;&nbsp;&nbsp;$4, 0($2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Print that char back to output<br>
                        <span class="cline">09&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;bne&nbsp;&nbsp;$3, $4, loop&nbsp;&nbsp;&nbsp;; Repeat if ESC not entered<br>
                        <span class="cline">10&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;jr&nbsp;&nbsp;&nbsp;$31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Finish<br>
                    </code></pre>
                </span>
                <br>
                <p>
                    Let's look at storing data in a program as a string and iterating that string: "Hello World"<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;lis&nbsp;&nbsp;$1<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0xffff000c<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;lis&nbsp;&nbsp;$2<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word helloWorld&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Replaced by assembler with address of label<br>
                        <span class="cline">05&nbsp;&nbsp;</span>loop:<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;lw&nbsp;&nbsp;&nbsp;$3, 0($2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Load address character at address stored in $2<br>
                        <span class="cline">07&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;beq&nbsp;&nbsp;$3, $0, end&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; If we read NUL char we are done.<br>
                        <span class="cline">08&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;sw&nbsp;&nbsp;&nbsp;$3, 0($1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Print that character.<br>
                        <span class="cline">09&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;addi $2, $2, 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Point $2 at next char in string.<br>
                        <span class="cline">10&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;beq&nbsp;&nbsp;$0, $0, loop<br>
                        <span class="cline">11&nbsp;&nbsp;</span>end:<br>
                        <span class="cline">12&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;jr&nbsp;&nbsp;&nbsp;$31<br>
                        <span class="cline">13&nbsp;&nbsp;</span>helloWorld:<br>
                        <span class="cline">14&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0x48<br>
                        <span class="cline">15&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0x65<br>
                        <span class="cline">16&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0x6c<br>
                        <span class="cline">17&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0x6c<br>
                        <span class="cline">18&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0x6f<br>
                        <span class="cline">19&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0x20<br>
                        <span class="cline">20&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0x57<br>
                        <span class="cline">21&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0x6f<br>
                        <span class="cline">22&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0x72<br>
                        <span class="cline">23&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0x6c<br>
                        <span class="cline">24&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0x64<br>
                        <span class="cline">25&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0x21<br>
                        <span class="cline">26&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0x0a<br>
                        <span class="cline">27&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0x00<br>
                    </code></pre>
                </span>
                <br>
                <b>Subroutines</b>
                <ul>
                    <li>equivalent to our high level functions</li>
                    <li>
                        makes assembly programming debugging easier
                        <ul>
                            <li>break up our problem into smaller subproblems</li>
                        </ul>
                    </li>
                    <li>can be reusable, callable from anywhere!</li>
                </ul>
                <br>
                <p>What do we need to make these work?<br></p>
                <ul>
                    <li>
                        How to call/return execution from a subroutine?
                        <ul>
                            <li>call is easy; we're always jumping to the same location to run the subroutine (static)</li>
                            <li>called subroutine must return execution to whatever part of the program called it (dynamic)</li>
                        </ul>
                    </li>
                    <li>What about passing arguments and returning values?</li>
                </ul>
                <br>
                <p>
                    We already know how to call a subroutine (jump to its label).<br>
                    So how to return execution?<br>
                    If we want dynamic return, we need to know 2 things:<br>
                </p>
                <ul>
                    <li>
                        need to store the address of where to return execution, so the subroutine can jump back to that address
                        <ul>
                            <li>we must store <code>$pc + 4</code> for our return address</li>
                        </ul>
                    </li>
                    <li>
                        jump to the subroutine
                        <ul>
                            <li>luckily, we have an instruction to do just this : <code>jal srLabel ; jump and link</code></li>
                            <li>store the next instruction to execute in <code>$31</code> (next instruction to execute after source register is done</li>
                        </ul>
                    </li>
                    <li>
                        then, jump to srLabel
                        <ul>
                            <li>but we have still got some problems</li>
                            <li>we must be able to store register 31's value before overwriting it or we lose the previous return address</li>
                        </ul>
                    </li>
                    <li>
                        Where to store? Another register? NO!
                        <ul>
                            <li>limited (only 32) and valuable</li>
                            <li>registers are not dynamic - ops that use them are not</li>
                            <li>subroutine might overwrite that register</li>
                        </ul>
                    </li>
                </ul>
                <p>
                    Solution: STACK!!!<br>
                    Finally, we can talk about stack.<br>
                    But what is stack? Stack is just a last in first out (LIFO) data structure.<br>
                </p>
            </section>
            <hr>
            
            <section id="lec7">
                <h3>Lecture 7 - 25/01/2018</h3>
                <hr>
                <p>
                    Problem: We need to store the value of our return address register somewhere and so the value won't be overwritten.<br>
                    Solution: Use the stack.<br>
                    <br>
                    <span class="key">Stack</span>
                    It is a last-in first-out (LIFO) data structure.<br>
                    <br>
                    Example:
                </p>
                <img src="./image/cs230/lec7/7_1.png">
                <br>
                <p>
                    Stacks are a very convenient way of representing/using our memory.<br>
                    Convention: Stack grows up from the bottom of memory (as opposed to our program that went down from the top, address 0).<br>
                    Normally, in MIPS register 29, is the stack pointer register.<br>
                    In our emulator, the stack pointer is in register 30.<br>
                    <br>
                    How to use the stack via the stack pointer?<br>
                    If we want to store something, we must "make room" on the stack by making the stack pointer further away from the bottom of memory however many bytes we need.<br>
                    This is achieved by decrementing.<br>
                    <br>
                    How much must we decrement the stack pointer by to store one register?<br>
                    We must decrement by 4.<br>
                    <br>
                    To store return address on stack, or any other register's value for that matter:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>addi $30, $30, -<br>
                        <span class="cline">02&nbsp;&nbsp;</span>sw&nbsp;&nbsp;&nbsp;$31, 0($30)<br>
                    </code></pre>
                </span>
                <img src="./image/cs230/lec7/7_2.png">
                <p>
                    The value of $31 at the time it was stored.<br>
                    <br>
                    To restore a value from the stack:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>lw&nbsp;&nbsp;&nbsp;$31, 0($30)<br>
                        <span class="cline">02&nbsp;&nbsp;</span>addi $30, $30, 4<br>
                    </code></pre>
                </span>
                <p>
                    Now we know how to dynamically return from a subroutine without losing our return address.<br>
                    So generally to call a subroutine...<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>addi&nbsp;&nbsp;$30, $30, -4<br>
                        <span class="cline">02&nbsp;&nbsp;</span>sw&nbsp;&nbsp;&nbsp;&nbsp;$31, 0($30)<br>
                        <span class="cline">03&nbsp;&nbsp;</span>jal&nbsp;&nbsp;&nbsp;srLabel<br>
                        <span class="cline">04&nbsp;&nbsp;</span>lw&nbsp;&nbsp;&nbsp;&nbsp;$31, 0($30)<br>
                        <span class="cline">05&nbsp;&nbsp;</span>addi&nbsp;&nbsp;$30, $30, 4<br>
                    </code></pre>
                </span>
                <br>
                <p>
                    How to pass values into subroutine as arguments and our as return values?<br>
                    Specific Register Conventions:<br>
                </p>
                <ul>
                    <li>$2 and $3: return values</li>
                    <li>$4 to $7: arguments</li>
                    <li>$8 to $15, $24, $25: unsaved temporaries</li>
                    <li>$16 to $23: saved temporaries</li>
                    <li>rest are special uses</li>
                </ul>
                <p>
                    If you need more than 2 return values or 3 arguments - use the stack!<br>
                    <br>
                    <span class="key">Unsaved Temporaries</span> mean that these registers are <u>NOT</u> preserved when a subroutine is ran.<br>
                    If you are going to call a subroutine and want to keep these values, you MUST save them (this is the caller's job to save), move them to saved temporaries, OR push to stack before call.<br>
                    <br>
                    <span class="key">Saved Temporaries</span> are guaranteed to be preserved across a call, so when a subroutine returns you are promised to still have those values.<br>
                    It is the store register's job (or the caller's job) to save these registers.<br>
                    <br>
                    Let's put it all together in a case study.<br>
                    We will use <code>a2q5.asm</code> from assignment 5 as our case study.<br>
                    Assume we need to print an array of integers separated by commas.<br>
                    We need to break up into 2 tasks...<br>
                </p>
                <ul>
                    <li>
                        printing an integer
                        <ul>
                            <li>need to print each digit in order</li>
                            <li>print a minus sign in front if it its negative</li>
                        </ul>
                    </li>
                    <li>iterating an array printing each element in it</li>
                </ul>
                <p>
                    To figure out digits, repeatedly divide by 10 and look at remainder.<br>
                    Example: <span class="math">2542 / 10 = 254 .. 2</span><br>
                    <br>
                    Do we print that digit as soon as we read it?<br>
                    No, then we will print the string reversal of the number.<br>
                    We need to store digits as we discover them, then print them in the reverse order of discovery!<br>
                    Push them onto stack, them pop them off and print them.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>printInt:<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;; $4 is the int to print<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;add&nbsp;&nbsp;&nbsp;$11, $0, $0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; init $11 to 0<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;add&nbsp;&nbsp;&nbsp;$12, $4, $0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; init $12 to our number<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;addi&nbsp;&nbsp;$13, $0, 10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; init $13 to 10<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;lis&nbsp;&nbsp;&nbsp;$10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; setup $10 as printer<br>
                        <span class="cline">07&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0xFFFF000C<br>
                        <span class="cline">08&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;slt&nbsp;&nbsp;&nbsp;$8,&nbsp;&nbsp;$4, $0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; check if negative number<br>
                        <span class="cline">09&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;beq&nbsp;&nbsp;&nbsp;$8,&nbsp;&nbsp;$0, pushLoop ; if positive just start loop<br>
                        <span class="cline">10&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;sub&nbsp;&nbsp;&nbsp;$12, $0, $4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; convert to positive<br>
                        <span class="cline">11&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;addi&nbsp;&nbsp;$9,&nbsp;&nbsp;$0, 45&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; load 45, ascii -<br>
                        <span class="cline">12&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;sw&nbsp;&nbsp;&nbsp;&nbsp;$9,&nbsp;&nbsp;0($10)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; print minus sign<br>
                        <span class="cline">13&nbsp;&nbsp;</span>pushLoop:<br>
                        <span class="cline">14&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;divu&nbsp;&nbsp;$12, $13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; divide current number by 10<br>
                        <span class="cline">15&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;mfhi&nbsp;&nbsp;$14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; copy remainder into $14<br>
                        <span class="cline">16&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;mflo&nbsp;&nbsp;$12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; update current number to quotient<br>
                        <span class="cline">17&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;addi&nbsp;&nbsp;$11, $11, 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; increment number characters<br>
                        <span class="cline">18&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;addi&nbsp;&nbsp;$30, $30, -4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; make space on stack<br>
                        <span class="cline">19&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;sw&nbsp;&nbsp;&nbsp;&nbsp;$14, 0($30)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; store digit on stack<br>
                        <span class="cline">20&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;bne&nbsp;&nbsp;&nbsp;$12, $0, pushLoop ; keep going it not at 0<br>
                        <span class="cline">21&nbsp;&nbsp;</span>popLoop:<br>
                        <span class="cline">22&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;lw&nbsp;&nbsp;&nbsp;&nbsp;$9,&nbsp;&nbsp;0($30)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; load current digit to print<br>
                        <span class="cline">23&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;addi&nbsp;&nbsp;$9,&nbsp;&nbsp;$9,&nbsp;&nbsp;48&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; set to ASCII value for that digit<br>
                        <span class="cline">24&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;sw&nbsp;&nbsp;&nbsp;&nbsp;$9,&nbsp;&nbsp;0($10)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; print the digit<br>
                        <span class="cline">25&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;addi&nbsp;&nbsp;$30, $30, 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; pop off stack <br>
                        <span class="cline">26&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;addi&nbsp;&nbsp;$11, $11, -1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; decrement count of digits<br>
                        <span class="cline">27&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;bne&nbsp;&nbsp;&nbsp;$11, $0,&nbsp;&nbsp;popLoop ; keep going if not done<br>
                        <span class="cline">28&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;jr&nbsp;&nbsp;&nbsp;&nbsp;$31<br>
                    </code></pre>
                </span>
                <p>
                    So now we can print integers!<br>
                    Let's use that to print our array!<br>
                    <br>
                    There's lots of ways these subroutines could be improved.<br>
                    For example, in <code>pLoop</code> from <code>a2q5.asm</code>, we don't actually need to back up all those registers.<br>
                    We could just initialize before use - not at start.<br>
                    Example: the comma character and the space character<br>
                    We don't need to use that many resisters - we can reuse registers in ways that make sense.<br>
                </p>
            </section>
            <hr>
            
            <section id="lec8">
                <h3>Lecture 8 - 30/01/2018</h3>
                <hr>
                <p>
                    Assignment 2 due this Friday (2<sup>nd</sup> February, 2018) at 5pm!<br>
                    Midterm is next week, Thursday 8<sup>th</sup> February, 2018!<br>
                </p>
                <br>
                <b>Questions from last lecture?</b>
                <p>
                    The stack - controlled (used) through a pointer (a memory address) to the current location of the stack.<br>
                    Our stack pointer is in <code>$30</code>.<br>
                    Stack starts at the BOTTOM (END) of our memory and "grows up" towards the start.<br>
                </p>
                <br>
                <img src="./image/cs230/lec8/8_1.png">
                <p>
                    Note that we can't store store anything in the end of memory - that would go outside the memory space!<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>addi $30, $30, -4<br>
                    </code></pre>
                </span>
                <img src="./image/cs230/lec8/8_2.png">
                <br><br>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>; assume $1 is 0xFB<br>
                        <span class="cline">02&nbsp;&nbsp;</span>sw $1, 0($30)<br>
                    </code></pre>
                </span>
                <img src="./image/cs230/lec8/8_3.png">
                <br><br>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>addi $30, $30, -8<br>
                    </code></pre>
                </span>
                <img src="./image/cs230/lec8/8_4.png">
                <br><br>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>; assume $2 is 0x81, $3 is 0xABC<br>
                        <span class="cline">02&nbsp;&nbsp;</span>sw $2, 0($30)<br>
                        <span class="cline">03&nbsp;&nbsp;</span>sw $3, 4($30)<br>
                    </code></pre>
                </span>
                <img src="./image/cs230/lec8/8_5.png">
                <br><br>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>addi $1, $0, 0xABD ; now $1 is 0xABD<br>
                        <span class="cline">02&nbsp;&nbsp;</span>addi $2, $0, 0xEE&nbsp; ; now $2 is 0xEE<br>
                        <span class="cline">03&nbsp;&nbsp;</span>addi $3, $0, 0xCC&nbsp; ; now $3 is 0xCC<br>
                        <span class="cline">04&nbsp;&nbsp;</span>lw&nbsp;&nbsp; $2, 0($30) &nbsp;&nbsp;&nbsp;; $2 is back to 0x81<br>
                    </code></pre>
                </span>
                <img src="./image/cs230/lec8/8_6.png">
                <br><br>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>addi $30, $30, 4<br>
                    </code></pre>
                </span>
                <img src="./image/cs230/lec8/8_7.png">
                <p>
                    Note that even the value <code>0x81</code> is popped, it still exists in memory until we overwrite something into the memory.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>lw &nbsp;$3, &nbsp;0($30)<br>
                        <span class="cline">02&nbsp;&nbsp;</span>lw &nbsp;$1, &nbsp;4($30)<br>
                        <span class="cline">03&nbsp;&nbsp;</span>; now $3 is 0xABC and $1 is 0xFB<br>
                        <span class="cline">04&nbsp;&nbsp;</span>add $30, $30, 8<br>
                    </code></pre>
                </span>
                <img src="./image/cs230/lec8/8_8.png">
                <br><br>
                <b>Why bother learning assembly?</b>
                <ul>
                    <li>Gain and understanding of what a program actually is (sequence of instructions)</li>
                    <li>Understand how our high level languages can be interpreted by a computer</li>
                    <li>Gain an appreciation for which high level constructs are slower (take more instructions)</li>
                    <li>
                        Understand high level concepts better
                        <ul>
                            <li>example: How is data actually represented?</li>
                        </ul>
                    </li>
                </ul>	
                <br>
                <b>Machine Internals and Performance</b>
                <p>
                    Computers are constructed with a <u>CLOCK</u> that determines the speed at which instructions are done.<br>
                    Basically, it is a metronome for the computer - it keeps time for operations and achieves by sending an alternating signal of high/low voltage (in time).<br>
                </p>
                <img src="./image/cs230/lec8/8_9.png">
                <p>
                    Electric signal propagates pretty fast.<br>
                </p>
                <ul>
                    <li>Not infinitely fast, physical constraints</li>
                    <li>Gate delay, time it takes for a signal to enter a gate and result exit the gate (at a steady state)</li>
                </ul>

                <p>
                    Clock Period (Cycle Time): Duration in seconds of a cycle<br>
                    Clock Frequency (Clock Rate): Cycles per second (1/cycle time) in Hz (hertz)<br>
                    <br>
                    Example: clock period of <span class="math">250ps = 250(10<sup>12</sup>) s/cycle</span>.<br>
                    Note: ps is picoseconds, a.k.a <span class="math">10<sup>-12</sup></span>.<br>
                    What is our clock rate?<br>
                </p>
                <table class="math">
                    <tr>
                        <td>&nbsp;1 / 250(10<sup>-12</sup>)</td>
                        <td>&nbsp;= 10<sup>12</sup> / 250</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= 4(10<sup>9</sup>)</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= 4 GHz</td>
                    </tr>
                </table>
                <p>
                    Our cycles are used to "time" operations.<br>
                </p>
                <br>
                <b>Single Cycle Execution</b>
                <ul>
                    <li>Execute one instruction per cycle</li>
                    <li>
                        Fixed cycle time equal to the time it takes for our slowest instruction
                        <ul>
                            <li>add v.s. multiply</li>
                            <li>memory instructions (slow)</li>
                        </ul>
                    </li>
                    <li>If we want our common cases to be fast - then single cycle execution is not a great choice.</li>
                </ul>
                <br>
                <b>Measuring Performance</b>
                <p>Time</p>
                <ul>
                    <li>
                        Time to execute program (short as possible is goal!) - different ways of measuring this:
                        <ul>
                            <li>
                                Elapsed Time (total response time): total real time it takes the program to execute from an outside perspective<br>
                                It includes wait times (waiting for a resource like memory or hard dist), waiting for input, idle time.<br>
                            </li>
                        </ul>
                    </li>
                    <li>
                        CPU Time is how much time your program actually spends processing instructions and quite often CPU time is less than Elapsed time.<br> 
                    </li>
                </ul>
                <ul>
                    <li>Latency - time to execute one instruction</li>
                    <li>Throughput - number of instructions executed per unit of time</li>
                </ul>
                <b>Metrics of a Program/Hardware Combo</b>
                <ul>
                    <li>Cycles Per Instruction (CPI) - determined by the CPU hardware, probable for different instructions to take different number of cycles</li>
                    <li>Instruction count (IC) - the number of instructions in a program. Affected by primarily the program itself, the instruction set itself (e.g. <code>slt</code> and <code>bne</code> v.s. "branch is less than", the compiler (how much does it optimizes)</li>
                </ul>
                <p>
                    Number of clock cycles for a program: <span class="math">IC &sdot; CPI</span><br>
                    <span class="math">CPU Time = IC &sdot; CPI &sdot; cycleTime</span><br>
                    <br>
                    Example:<br>
                    Computer A has a cycle time 250ps and CPI is 2.0.<br>
                    Computer B has a cycle time 500ps and CPI is 1.2.<br>
                    Both of them use same instruction set, running the same program. Which is faster?<br>
                    <br>
                    <span class="math">CPU TIME<sub>A</sub> = IC &sdot; 20 &sdot; 250ps = IC &sdot; 500ps</span><br>
                    <span class="math">CPU TIME<sub>B</sub> = IC &sdot; 1.2 &sdot; 500ps = IC &sdot; 600ps</span><br>
                    <br>
                    So computer A is faster - how much faster?<br>
                    <span class="math">CPU TIME<sub>B</sub> / CPU TIME<sub>A</sub> = 600ps / 500ps = 1.2</span><br><br>
                    Computer A is 1.2 times faster than computer B.<br>
                    <br>
                    Example: 3 different types of instructions, each takes a different number of cycles, 2 programs X and Y.<br>
                </p>
                <table class="textTable">
                    <tr>
                        <th>I-type</th>
                        <th>A</th>
                        <th>B</th>
                        <th>C</th>
                    </tr>
                    <tr>
                        <td>CPI</td>
                        <td>1</td>
                        <td>2</td>
                        <td>4</td>
                    </tr>
                    <tr>
                        <td>IC<sub>x</sub></td>
                        <td>1</td>
                        <td>1</td>
                        <td>3</td>
                    </tr>
                    <tr>
                        <td>IC<sub>Y</sub></td>
                        <td>2</td>
                        <td>4</td>
                        <td>1</td>
                    </tr>
                </table>
                <p>
                    What is the weighted average CPI for programs X and Y?<br>
                </p>
                <table class="math">
                    <tr>
                        <td>&nbsp;CPI<sub>X</sub></td>
                        <td>&nbsp;= numbers of cycles / numbers of instructions</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= 1 &sdot; 1+2 &sdot; 1+4 &sdot; 3 / (1+1+3)</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= 15 / 5</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= 3.0</td>
                    </tr>
                </table>
                <br>
                <table class="math">
                    <tr>
                        <td>&nbsp;CPI<sub>Y</sub></td>
                        <td>&nbsp;= numbers of cycles / numbers of instructions</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= 1 &sdot; 2+2 &sdot; 4+4 &sdot; 1 / (2+5+1)</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= 14 / 7</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= 2.0</td>
                    </tr>
                </table>
                <br>
                <p>
                    So program Y is using less cycles per instruction than X since it's using quicker instructions.<br>
                    <br>
                    In summary, we can calculate CPU time required for some program as<br>
                    <span class="math">CPUtime = IC &sdot; CPI &sdot; cycleTime = IC &sdot; CPI &sdot; (1/clockRate)</span><br>
                    We can try to reduce CPU time by...<br>
                </p>
                <ul>
                    <li>using less instructions</li>
                    <li>Reduce our CPI time</li>
                    <li>Faster clock (over-clocking)</li>
                </ul>
                <p>
                    Tradeoffs to all of these - we have other ways to increase performance.<br>
                </p>
                <br>
                <b>Pipelining</b>
                <p>
                    The idea behind pipelining is to use all your resources as much possible, not have resources sit waiting.<br>
                    A completely unpipelined task will do each task in sequence waiting for completion before starting the next.<br>
                    A pipelined version will do multiple tasks in parallel, so long as there is no reason why it cannot. (The resource required is not available, or its not ready)<br>
                    <br>
                    The best real life analogy for pipelining is laundry. We have 4 tasks (wash, dry, fold, put away) and 3 resources (washer, dryer, manual labour).<br>
                </p>
                <p>
                    In the pipelined version, we don't wait for one load to be completely finished (folded and put away) before starting the next load.<br>
                    So our pipelined version is faster, by making sure our resources in use as often as possible.<br>
                    In reality, it's not this clean , e.g. we have might have hang dry (take labour resource), can't fold and put away at same time.<br>
                    <br>
                    Under pipelining, can I wash one article of clothing faster than without pipelining?<br>
                    Pipelining does not affect LATENCY; it only affects throughput.<br>
                    <br>
                    In MIPS, we break up our execution into 5 steps, each step takes one cycle, and all 5 can be done in the same cycle (they use different resources). So in theory, we could have 5 instructions currently executing in any one cycle (under ideal conditions).<br>
                    <br>
                    Let's talk about our stages of execution.<br>
                </p>
                <ol>
                    <li>
                        Instruction Fetch (IF)
                        <ul>
                            <li>load instruction from memory into the CPU</li>
                            <li>load from the address in <code>$PC</code></li>
                        </ul>
                    </li>
                    <li>
                        Instruction Decode (ID)
                        <ul>
                            <li>Determine which instruction this is and what registers it is using (decode the bits of the instruction)</li>
                            <li>Read the values from the corresponding registers into the ALU (takes place in the second half of cycle)</li>
                            <li>Also determine if it is a branch instruction</li>
                        </ul>
                    </li>
                    <li>
                        Execute (EX)
                        <ul>
                            <li>Do the operation indicated by the instruction (done in the ALU)</li>
                            <li>For <code>add</code> do addition</li>
                            <li>For <code>mult</code> do multiplication</li>
                            <li>For  <code>lw/sw</code> compute the address  <code>$s + i</code>, etc.</li>
                        </ul>
                    </li>
                </ol>
            </section>
            <hr>
            
            <table class="buttomTable">
                <tr>
                    <td class="buttomLeftTable"><a href="./cs230_1.html">&larr; Go to Module 1 - Arithmetic, Hardware, Data</a></td>
                    <td class="buttomCentreTable"><a href="./cs230.html">&uarr; Go to Index</a></td>
                    <td class="buttomRightTable"><a href="./cs230_3.html">&rarr; Go to Module 3 - Machine Internals&nbsp;</a></td>
                </tr>
            </table>
            <hr>
            
            <p>
                Find a typo or mistake? Feel free to contact me and I will correct it as soon as possible.
            </p>
            <hr>
            
            <div class="footer">
                <p>Thanks For Coming Here. - Calvin Li</p>
                <a href = "mailto: ck6li@edu.uwaterloo.ca" target = "_blank;">
                    <i class = "fa fa-envelope-square"></i>
                </a>
                <a href = "https://www.linkedin.com/in/vertckli/" target = "_blank;">
                    <i class = "fa fa-linkedin-square"></i>
                </a>       
                <a href = "https://www.instagram.com/vert_arts/" target = "_blank;">
                    <i class="fa fa-instagram"></i>
                </a>
                <a href = "https://github.com/vertli" target = "_blank;">
                    <i class="fa fa-github-square"></i>
                </a>
                <br>
                <p><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" /></a> This work by <a xmlns:cc="http://creativecommons.org/ns#" href="https://vertli.github.io/" property="cc:attributionName" rel="cc:attributionURL">Chun Kit (Calvin) Li</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>. Chun Kit (Calvin) Li &copy; 2017 - 2018</p>
            </div>
            <hr>
            
        </div>
        
        <script src="https://code.jquery.com/jquery-2.1.4.js"></script>
        <script src="./bootstrap-3.3.7-dist/js/bootstrap.js"></script>
        
    </body>
    
</html>