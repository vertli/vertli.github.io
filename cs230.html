<!DOCTYPE html>

<html>
    <head>
        <meta charset="utf-8">
        <title>CS230|Calvin Li</title>
        <link rel="stylesheet" href="./bootstrap-3.3.7-dist/css/bootstrap.css">
        <link rel="stylesheet" href="./css/style.css">
        <link rel="stylesheet" href="./css/note.css">
        <link rel="stylesheet" href="./css/cs230use.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:400,800" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Crimson+Text:600,600i" rel="stylesheet"> <!-- for math use -->
        <link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/hack-font/build/web/hack.css'> <!-- HACK!!! -->
        <!-- stylesheet found from w3school. (icon use)-->
        <link rel = "stylesheet" href = "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    </head>
    
    <body class="cs230">
        
        <nav class="navbar navbar-inverse navbar-fixed-top">
            <div class="container-fluid">
                <!-- Brand and toggle get grouped for better mobile display -->
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#topNavbar" aria-expanded="false">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="./index.html">Calvin Li</a>
                </div>

                <!-- Collect the nav links, forms, and other content for toggling -->
                <div class="collapse navbar-collapse" id="topNavbar">
                    <ul class="nav navbar-nav">
                        <li><a href="./doc/NewResume_CKLI.pdf" target="_blank;">Résumé</a></li>
                    </ul>
                    <ul class="nav navbar-nav navbar-right">
                        <li><a href="./about.html">About</a></li>
                        <li><a href="./projects.html">Projects</a></li>
                        <li class="courseNote">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Course Notes<span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <li><a href="./cs230.html">CS 230</a></li>
                                <li><a href="./cs246.html">CS 246</a></li>
                                <li><a href="./econ101.html">ECON 101</a></li>
                            </ul>
                        </li>
                    </ul>
                </div><!-- /.navbar-collapse -->
            </div><!-- /.container-fluid -->
        </nav>
        
        <br><br><br>
        
        <div class="container">
            
            <br>
            <table class="header">
                <tr>
                    <td colspan="100%">
                        <h1 class="title">CS 230 - Introduction to Computers and Computer Systems</h1>
                    </td>
                </tr>
                <tr>
                    <th colspan="5%">Instructor:</th>
                    <td colspan="95%">Rob Hackman</td>
                </tr>
                <tr>
                    <th colspan="5%">Office:</th>
                    <td colspan="95%">DC2551A</td>
                </tr>
                <tr>
                    <th colspan="5%">Email:</th>
                    <td colspan="95%"><a href = "mailto: r2hackma@uwaterloo.ca" target = "_blank;">r2hackma@uwaterloo.ca</a></td>
                </tr>
                <tr>
                    <th colspan="5%">Website:</th>
                    <td colspan="95%">
                        <a href="https://www.student.cs.uwaterloo.ca/~cs230/" target="_blank;">https://www.student.cs.uwaterloo.ca/~cs230/</a>
                    </td>
                </tr>
            </table>
            <hr>
                         
            <div class="lec1">
                <h3>Lecture 1 - 04/01/2018</h3>
                <hr>
                <b>Goals</b>
                <ul>
                    <li>
                        Overview of computer systems
                        <ul>
                            <li>What is a computer?</li>
                            <li>How do they work?</li>
                            <li>Why are they designed as such?</li>
                        </ul>
                    </li>
                    <li>Work from the bottom-up</li>
                    <li>Understand the basic challenges and techniques</li>
                </ul>
                <br>
                <p>
                    In this course, we will use Linux.<br>
                    The student environment is <a href="https://student.cs.uwaterloo.ca" target="_blank;">student.cs.uwaterloo.ca</a>.<br>
                    <br>
                    We will be learning MIPS; we have MIPS assembler and emulator for you to use on the student environments.<br>
                </p>
                <br>
                <b>Overview</b>
                <ul>
                    <li>Arithmetic, Hardware, Data</li>
                    <li>Assembly Language</li>
                    <li>Machine Internals</li>
                    <li>Build and Execute</li>
                    <li>Multiprocessing</li>
                    <li>Operating System (if time allow)</li>
                </ul>
                <br>
                <b>What is a computer?</b>
                <p>
                    Computer is a bunch of logic gates and circuitry; it is designed to complete a task.<br>
                    Let's think of a old stop watch. It can only has functionality to start timing, stop timing, and maybe hold up to 3 lap times.<br>
                    Technically this is a computer; this is not what we think of today.<br>
                    What differentiates it?<br>
                    If we want to reprogram our stop watch, we must change the circuitry.<br>
                    <br>
                    The modern day personal computer is re-programmable without having to change the circuitry.<br>
                    It is called "Von Neumann Architecture".<br>
                </p>
                <br>
                <b>Von Neumann Architecture</b>
                <p>
                    Von Neumann Architecture has the circuitry redefine a set of "instructions" that can be executed by it.<br>
                    Basic arithmetic done by the arithmetic logic unit (ALU); it has a "control unit" (CU) that runs control instructions.<br>
                    These two together define our central processing unit (CPU).<br>
                    <br>
                    Von Neumann Architecture has memory that can be accessed at any location within (random access memory - RAM).<br>
                    This is called our memory unit (MU).<br>
                    We can read/write to our memory unit.<br>
                    Memory unit stores both instructions AND data.<br>
                    <br>
                    Lastly, we require inputer/output devices.<br>
                </p>
                <img src="./image/cs230/lec1/1_1.PNG" width="35%" height="35%">
                <p>
                    Von Neumann Architecture is still the basis for almost all computers today.<br>
                    (Strict Von Neumann Architecture says that data and program must be stored on the same memory unit; this is not always the case Harvard Architecture.)<br>
                    <br>
                    How does a Von Neumann Machine run a program?<br>
                    It keeps track of what address in memory and the next instruction to execute is located.<br>
                    <br>
                    How does our CPU store the address of the next instruction if memory is separate?<br>
                    Special circuits called "registors" which are parts of the CPU.<br>
                    They are memory in that they simply store sets of 1's and 0's for the CPU to interpret and use.<br>
                    <br>
                    Registors begin part of the CPU are can be read from/written to very fast.<br>
                    <br>
                    A special registor called "program counter" or "PC registor" which stores the location of the next instruction.<br>
                    <br>
                    What types of instructions exist? Lots!<br>
                </p>
                <ul>
                    <li>Data transfer/read/write to memory</li>
                    <li>Do some arithmetic</li>
                    <li>Branch (change the address stored in the program counter)</li>
                </ul>
                <p>
                    There are many different hardwares exist: AMD, Intel, Qualcomm, ...<br>
                    They have their own instruction sets!<br>
                    <br>
                    You can write a C program and execute both on a machine with an AMP's CPU and an Intel's CPU.<br>
                    But how does this work if instruction sets are different?<br>
                    The instructions are preset for the circuitry.<br>
                    Instructions are great for circuitry; they're only ones and zeros!<br>
                    Machine Code or Machine Language is the name for the code of a program written in base instructions. It is not friendly to human.<br>
                    <br>
                    We can move one step up to Assembly Language.<br>
                    Assembly instructions have a direct mapping to one or more machine code instructions.<br>
                    We have a tool called "assembler" that takes assembly language programs and generates a machine program which the hardware can execute.<br>
                    <br>
                    Moving one step further away from the machine, there are intermediate languages (essentially a tool for compilers).<br>
                    <br>
                    Lastly, we have high level programming languages: C, C++, Java, ...<br>
                    <br>
                    C/C++ are compiled programming languages.<br>
                    We have a program called "compiler" that takes our C program as input and generates an assembly version of that program.<br>
                    Most compilers also assemble that program immediately to produce a final machine code program (binary file) which your hardware can execute!<br>
                    Hence, programs are stored in memory; data is also stored in memory.<br>
                    Memory is just 1's or 0's.<br>
                    So, what does memory actually look like and how do we interpret it?<br>
                </p>
                <br>
                <b>Number Representation</b>
                <p>
                    What does the number 942 mean?<br>
                </p>
                <ul>
                    <li>Nine hundred forty two</li>
                    <li>Nine hundreds, Four tens, Two ones</li>
                    <li><span class="math">9 * 10<sup>2</sup> + 4 * 10<sup>1</sup> + 2 * 10<sup>0</sup></span></li>
                </ul>
                <p>
                    This is the radix 10 representation of the number 942.<br>
                    Radix is also know as "base".<br>
                    <br>
                    This continues each digit we add to the left we simply increment the exponent.<br>
                    This is why our number system is called "base 10" or "decimal".<br>
                    <br>
                    Radix representation allows us to write natural numbers using a finite alphabet.<br>
                    In base <span class="math">r</span>, we have <span class="math">r</span> characters in <span class="math">r</span> alphabets (digits).<br>
                    Typically, <span class="math">0, 1, 2, ..., r-2, r-1</span>.<br>
                    <br>
                    For any length <i>n</i> word in base <span class="math">r</span>, we have 
                    <span class="math">d<sub>n-1</sub>, d<sub>n-2</sub>, ..., d<sub>2</sub>, d<sub>1</sub>, d<sub>0</sub>.</span><br>
                    <br>
                    We can "calculate" or rather compue the decimal value number by doing<br>
                </p>
                <img src="./image/cs230/lec1/1_2.PNG" width="7%" height="7%">
                <br>
                <p>
                    You can use any number for your base.<br>
                </p>
                <ul>
                    <li>base 2: binary [0,1] (also call bit)</li>
                    <li>base 8: octal [0,7]</li>
                    <li>base 10: decimal [0,9]</li>
                    <li>base 16: hexadecimal[0,1,...,9,A,B,C,D,E,F]</li>
                </ul>
                <p>
                    Humans mostly use base 10 - why? We have 10 fingers!<br>
                    <br>
                    Computer use base 2, binary. Why?<br>
                    Electrical simplicity: On/Off, High/Low, 1/0.<br>
                    <br>
                    Example: Consider the number <span class="math">1440<sub>sept</sub></span> or <span class="math">1440<sub>7</sub></span>.<br>
                    <span class="math">
                        0 * 7<sup>0</sup> + 4 * 7<sup>1</sup> + 4 * 7<sup>2</sup> + 1 * 7<sup>3</sup> = 567<sub>10</sub>
                    </span><br>
                    <br>
                    Example: Consider the number <span class="math">A32<sub>Hex</sub></span>, aka <span class="math">A32<sub>16</sub></span>.<br>
                    <span class="math">
                        2 * 16<sup>0</sup> + 3 * 16<sup>1</sup> + A * 16<sup>2</sup> = 1050<sub>10</sub>
                    </span><br>
                    <br>
                    Same conversion for any base to base 10 (binary included) - just use that summation formula.<br>
                    But what if we have a decimal number and we want to figure out the binary representation?<br>
                    We need to use repeated divisions!<br>
                </p>
                <ul>
                    <li>Step 1: divide the number by 2, the remainder is the current digit (starting at digit 0)</li>
                    <li>Step 2: take the quotient and repeat until the quotient is 0</li>
                </ul>
                <p>
                    Example: Convert <span class="math">4242<sub>10</sub></span> to hexadecimal.<br>
                    <span class="math">4242 / 16 = 265 .. 2</span> &#8592; 2 is the least significant digit<br>
                    <span class="math">
                        265 / 16 = 16 .. 9<br>
                        16 / 16 = 1 .. 0<br>
                        1 / 16 = 0 .. 1<br>
                    </span>
                    So <span class="math">4242<sub>10</sub> = 1092<sub>16</sub></span>.<br>
                    <br>
                    Example: Convert <span class="math">187<sub>10</sub></span> to binary.<br>
                    <span class="math">
                        187 / 2 = 93 .. 1<br>
                        93 / 2 = 46 .. 1<br>
                        46 / 2 = 23 .. 0<br>
                        23 / 2 = 11 .. 1<br>
                        11 / 2 = 5 .. 1<br>
                        5 / 2 = 2 .. 1<br>
                        2 / 2 = 1 .. 0<br>
                        1 / 2 = 0 .. 1<br>
                    </span>
                    So <span class="math">187<sub>10</sub> = 1011101<sub>2</sub></span><br>
                    <br>
                    It took a LOT of divisions to get our binary number, and it was only 187!<br>
                    Luckily, it is trivial to convert between both octal/hexadecimal and binary.<br>
                    So we can always first convert to hexadecimal, the nto binary.<br>
                    <br>
                    To convert hexadecimal to binary, simply look at sets of 4 bits.<br>
                </p>
                <table class="textTable">
                    <tr>
                        <th>&nbsp;Binary&nbsp;</th>
                        <th>&nbsp;Hexadecimal&nbsp;</th>
                    </tr>
                    <tr>
                        <td>0000</td>
                        <td>0</td>
                    </tr>
                    <tr>
                        <td>0001</td>
                        <td>1</td>
                    </tr>
                    <tr>
                        <td>0010</td>
                        <td>2</td>
                    </tr>
                    <tr>
                        <td>0011</td>
                        <td>3</td>
                    </tr>
                    <tr>
                        <td>0100</td>
                        <td>4</td>
                    </tr>
                    <tr>
                        <td>0101</td>
                        <td>5</td>
                    </tr>
                    <tr>
                        <td>0110</td>
                        <td>6</td>
                    </tr>
                    <tr>
                        <td>0111</td>
                        <td>7</td>
                    </tr>
                    <tr>
                        <td>1000</td>
                        <td>8</td>
                    </tr>
                    <tr>
                        <td>1010</td>
                        <td>A</td>
                    </tr>
                    <tr>
                        <td>1011</td>
                        <td>B</td>
                    </tr>
                    <tr>
                        <td>1100</td>
                        <td>C</td>
                    </tr>
                    <tr>
                        <td>1101</td>
                        <td>D</td>
                    </tr>
                    <tr>
                        <td>1110</td>
                        <td>E</td>
                    </tr>
                    <tr>
                        <td>1111</td>
                        <td>F</td>
                    </tr>
                </table>
                <p>
                    So <span class="math">11010111<sub>2</sub> = D7<sub>16</sub></span>
                </p>
            </div>
            <hr>
            
            <div class="lec2">
                <h3>Lecture 2 - 09/01/2018</h3>
                <hr>
                <b>Binary Addition</b>
                <p>
                    Last time, we had learnt how to convert decimal number to binary number.<br>
                    But how do we add two binary numbers together?<br>
                    Binary addition is actually simple textbook addition.<br>
                    <br>
                    However, we have a problem.<br>
                    Unlike writing on paper or doing math in our head, our circuit can only have a certain number of bits (for example, 32-bit).<br>
                    This is what we call <span class="key">fixed-width representation</span>; in fixed-width representation, we have a problem called  <span class="key">overflow</span>.<br>
                    <br>
                    Consider a 4-bit fixed-width representation.<br>
                </p>
                <table class="math">
                    <tr>
                        <td>12<sub>10</sub> + 7<sub>10</sub></td>
                        <td>&nbsp;= 1100<sub>2</sub> + 0111<sub>2</sub></td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= 1 0011<sub>2</sub></td>
                    </tr>
                </table>
                <p>
                    Our answer has 5 bits, but we are working with a 4-bit fixed-width representation!<br>
                    This is an overflow!<br>
                    Hence, we have to omit the leftest bit and so, we can get a 4-bit answer.<br>
                </p>
                <table class="math">
                    <tr>
                        <td>12<sub>10</sub> + 7<sub>10</sub></td>
                        <td>&nbsp;= 1100<sub>2</sub> + 0111<sub>2</sub></td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= 0011<sub>2</sub></td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= 3<sub>10</sub></td>
                    </tr>
                </table>
                <p>
                    So <span class="math">12<sub>10</sub> + 7<sub>10</sub> = 3<sub>10</sub></span> in a 4-bits fixed-width representation<br>
                    <br>
                    We can calculate the result directly modulo 16 (so the largest number we can represent with 4 bits is 15).<br>
                </p>
                <br>
                <b>Binary Subtraction</b>
                <p>
                    Now we know that the addition works with binary, but human is lazy - we don't want to design a subtraction circuit!<br>
                    Subtraction is simply adding a negative number, or adding the negation of the number you are subtracting.<br>
                    <br>
                    Naive Approach:<br>
                    If we have n-bit to store our number, use n-1 bits to just store a regular old binary natural number (magnitude) and use the remaining bit to denote the sign.<br>
                    This is the <span class="key">sign and magnitude approach</span>.<br>
                    But this approach has two problems!<br>
                    <br>
                    The first problem is we have two zeros here!<br>
                    For example, in 4-bit fixed-width representation...<br>
                    <span class="math">1000<sub>2</sub> = -0<sub>10</sub></span> where the first bit <span class="math">1</span> is the sign bit <span class="math">-</span> and the rest of the bits is the magnitude of <span class="math">0<sub>10</sub></span>.<br>
                    <span class="math">0000<sub>2</sub> = +0<sub>10</sub></span> where the first bit <span class="math">0</span> is the sign bit <span class="math">+</span> and the rest of the bits is the magnitude of <span class="math">0<sub>10</sub></span>.<br>
                    <br>
                    The second problem is addition does not work here!<br>
                    For example,<br>
                </p>
                <table class="math">
                    <tr>
                        <td>3<sub>10</sub> - 1<sub>10</sub></td>
                        <td>&nbsp;= 3<sub>10</sub> + (-1<sub>10</sub>)</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= 0011<sub>2</sub> + 1001<sub>2</sub></td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= 1100<sub>2</sub></td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= -4<sub>10</sub></td>
                    </tr>
                </table>
                <p>
                    Clearly, we know that <span class="math">3 - 1 &ne; -4</span>.<br>
                    <br>
                    Attempt 2: <span class="key">1's Complement</span><br>
                    To represent negation of a binary number, simply invert(flip) the bits - 0's become 1's and 1's become 0's.<br>
                    Addition is possible here; the trick is to add any carry over to the sum.<br>
                    Example: <span class="math">7<sub>10</sub> - 4<sub>10</sub></span> in 4-bit fixed-width representation.<br>
                    We know that <span>4<sub>10</sub> = 0100<sub>2</sub></span>, then flip it and we will get <span class="math">1011<sub>2</sub></span> to represent <span class="math">-4</span>.<br>

                </p>
                <table>
                    <tr class="math">
                        <td>7<sub>10</sub> - 4<sub>10</sub></td>
                        <td>&nbsp;= 7<sub>10</sub> + (-4<sub>10</sub>)</td>
                        <td></td>
                    </tr>
                    <tr class="math">
                        <td></td>
                        <td>&nbsp;= 0111<sub>2</sub> + 1011<sub>2</sub></td>
                        <td></td>
                    </tr>
                    <tr class="math">
                        <td></td>
                        <td>&nbsp;= 1 0010<sub>2</sub></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td></td>
                        <td class="math">&nbsp;= 0010<sub>2</sub> + 1<sub>2</sub></td>
                        <td> // add the carry over to the sum</td>
                    </tr>
                    <tr class="math">
                        <td></td>
                        <td>&nbsp;= 0011<sub>2</sub></td>
                        <td></td>
                    </tr>
                    <tr class="math">
                        <td></td>
                        <td>&nbsp;= 3<sub>10</sub></td>
                        <td></td>
                    </tr>
                </table>
                <p>
                    Wait... We still have two zeros here!<br>
                    <span class="math">0000<sub>2</sub> = +0<sub>10</sub></span> and <span class="math">1111<sub>2</sub> = -0<sub>10</sub></span>.<br>
                    Also, this is not our same addition from before; we want to reuse the exact same circuit!<br>
                    <br>
                    Attempt 3: <span class="key">2's Complement</span><br>
                    To negate a number, flip the bits, then add 1.<br>
                    This will only give us one zero.<br>
                </p>
                <table>
                    <tr>
                        <td class="math">+0<sub>10</sub></td>
                        <td class="math">&nbsp;= 0000<sub>2</sub></td>
                        <td>// work in 4-bit fixed-width representation</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td class="math">&nbsp;= 1111<sub>2</sub></td>
                        <td>// flip</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td class="math">&nbsp;= 10000<sub>2</sub></td>
                        <td>// add 1</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td class="math">&nbsp;= 0000<sub>2</sub></td>
                        <td>// remove the overflow bit</td>
                    </tr>
                </table>
                <p>
                    Example: <span class="math">7 - 4</span> in 4-bit fixed-width representation.<br>
                    We know that <span>4<sub>10</sub> = 0100<sub>2</sub></span>, then flip it to get <span class="math">1011<sub>2</sub></span> and add 1 to get <span class="math">1100<sub>2</sub></span> which represents <span class="math">-4</span>.<br>
                </p>
                <table>
                    <tr class="math">
                        <td>7<sub>10</sub> - 4<sub>10</sub></td>
                        <td>&nbsp;= 7<sub>10</sub> + (-4<sub>10</sub>)</td>
                        <td></td>
                    </tr>
                    <tr class="math">
                        <td></td>
                        <td>&nbsp;= 0111<sub>2</sub> + 1100<sub>2</sub></td>
                        <td></td>
                    </tr>
                    <tr class="math">
                        <td></td>
                        <td>&nbsp;= 1 0011<sub>2</sub></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td></td>
                        <td class="math">&nbsp;= 0011<sub>2</sub></td>
                        <td> // remove the overflow bit</td>
                    </tr>
                    <tr class="math">
                        <td></td>
                        <td>&nbsp;= 3<sub>10</sub></td>
                        <td></td>
                    </tr>
                </table>
                <p>
                    The 2's complement solves our problems and it works!<br>
                    This is how all computers today represent negative integers.<br>
                    <br>
                    Beauty is in the eye of the beholder!<br>
                    What does <span class="math">1011<sub>2</sub></span> mean?<br>
                    This could be <span class="math">11<sub>10</sub></span> or <span class="math">-5<sub>10</sub></span>, it depends on how we choose to interpret it.<br>
                    There are other ways to interpret these binary numbers; we will talk about later.<br>
                </p>
                <br>
                <b>Sign Extension</b>
                <p>
                    We were using 4-bit fixed-width representation. If we wanted to move to other fixed-width representation (e.g. 8-bit), fill the extra spaces on the left with 0's for any positive number, or 1's for any negative number.<br>
                    For example...
                </p>
                <table class="textTable">
                    <tr>
                        <th></th>
                        <th>&nbsp;4-bit&nbsp;</th>
                        <th>&nbsp;8-bit&nbsp;</th>
                    </tr>
                    <tr>
                        <td><span class="math">5<sub>10</sub></span>&nbsp;</td>
                        <td>&nbsp;<span class="math">0101<sub>2</sub></span>&nbsp;</td>
                        <td>&nbsp;<span class="math">0000 0101<sub>2</sub></span>&nbsp;</td>
                    </tr>
                    <tr>
                        <td><span class="math">-3<sub>10</sub></span>&nbsp;</td>
                        <td>&nbsp;<span class="math">1101<sub>2</sub></span>&nbsp;</td>
                        <td>&nbsp;<span class="math">1111 1101<sub>2</sub></span>&nbsp;</td>
                    </tr>
                </table>
                <br>
                <b>Range</b>
                <p>
                    For 2's complement, the range of n-bit fixed-width representation is <span class="math">[-2<sup>n-1</sup>, 2<sup>n-1</sup> - 1]</span>.<br>
                    For example, the range of 4-bit fixed-width representation is <span class="math">[-8, 7]</span>.<br>
                    <br>
                    Range for unsigned integers is <span class="math">[0, 2<sup>n</sup> - 1]</span>.<br>
                </p>
                <br>
                <b>Shift Operations</b>
                <p>
                    We can shift a bit string right or left.<br>
                    They are equivalent to division or multiplication by 2.<br>
                    They are very fast machine instructions.<br>
                    When right shifting a negative number, fill the "new" left positions with 1's; for positive number, fill with 0's.<br>
                    For example...<br>
                </p>
                <table>
                    <tr>
                        <td></td>
                        <td class="math">1101 &lt;&lt; 2</td>
                        <td>&nbsp;// shift the bit string <span class="math">1101</span> left 2 positions</td>
                    </tr>
                    <tr>
                        <td>=&nbsp;</td>
                        <td class="math">11 0100</td>
                        <td>&nbsp;// Overflow, omit the 2 leftest bits</td>
                    </tr>
                    <tr class="tableUnderline">
                        <td>=&nbsp;</td>
                        <td class="math">0100</td>
                        <td>&nbsp;// final answer</td>
                    </tr>
                    <tr></tr>
                    <tr>
                        <td></td>
                        <td class="math">0001 &lt;&lt; 2</td>
                        <td>&nbsp;// shift the bit string <span class="math">0001</span> left 2 positions</td>
                    </tr>
                    <tr>
                        <td>=&nbsp;</td>
                        <td class="math">00 0100</td>
                        <td>&nbsp;// Overflow, omit the 2 leftest bits</td>
                    </tr>
                    <tr>
                        <td>=&nbsp;</td>
                        <td class="math">0100</td>
                        <td>&nbsp;// final answer</td>
                    </tr>
                </table>
                <br>
                <b>Binary Multiplication</b>
                <p>
                    Binary multiplication is same as textbook multiplication.<br>
                    For example...<br>
                </p>
                <table>
                    <tr>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td>1</td>
                        <td>0</td>
                        <td>0</td>
                        <td>0</td>
                    </tr>
                    <tr class="tableUnderline">
                        <td>&#10005;</td>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td>1</td>
                        <td>0</td>
                        <td>0</td>
                        <td>0</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td>1</td>
                        <td>0</td>
                        <td>0</td>
                        <td>0</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td></td>
                        <td>1</td>
                        <td>0</td>
                        <td>0</td>
                        <td>0</td>
                        <td>0</td>
                        <td>0</td>
                    </tr>
                    <tr class="tableUnderline">
                        <td>+</td>
                        <td>1</td>
                        <td>0</td>
                        <td>0</td>
                        <td>0</td>
                        <td>0</td>
                        <td>0</td>
                        <td>0</td>
                    </tr>
                    <tr class="tableDoubleUnderline">
                        <td></td>
                        <td>1</td>
                        <td>1</td>
                        <td>0</td>
                        <td>1</td>
                        <td>0</td>
                        <td>0</td>
                        <td>0</td>
                    </tr>
                </table>
                <p>
                    Binary multiplication is done by the processor as shift and add operators.<br>
                    It can be easily parallelized.<br>
                </p>
                <br>
                <b>Binary Division</b>
                <p>
                    Again, it is same as textbook division.<br>
                    For example...<br>
                </p>
                <table>
                    <tr>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">1</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">1</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">0</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">1<sub>2</sub></td>
                    </tr>
                    <tr>
                        <td>1</td>
                        <td>&nbsp;</td>
                        <td>0</td>
                        <td>&nbsp;</td>
                        <td>0</td>
                        <td>&nbsp;</td>
                        <td>0<sub>2</sub></td>
                        <td>&nbsp;</td>
                        <td class="tableLeftLine">1</td>
                        <td>&nbsp;</td>
                        <td>1</td>
                        <td>&nbsp;</td>
                        <td>0</td>
                        <td>&nbsp;</td>
                        <td>1</td>
                        <td>&nbsp;</td>
                        <td>0</td>
                        <td>&nbsp;</td>
                        <td>1</td>
                        <td>&nbsp;</td>
                        <td>0<sub>2</sub></td>
                    </tr>
                    <tr>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td class="tableUnderline">1</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">0</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">0</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">0<sub>2</sub></td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">&nbsp;</td>
                    </tr>
                    <tr>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>1</td>
                        <td>&nbsp;</td>
                        <td>0</td>
                        <td>&nbsp;</td>
                        <td>1</td>
                        <td>&nbsp;</td>
                        <td>0<sub>2</sub></td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                    </tr>
                    <tr>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">1</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">0</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">0</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">0<sub>2</sub></td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">&nbsp;</td>
                    </tr>
                    <tr>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>1</td>
                        <td>&nbsp;</td>
                        <td>0</td>
                        <td>&nbsp;</td>
                        <td>1</td>
                        <td>&nbsp;</td>
                        <td>0<sub>2</sub></td>
                    </tr>
                    <tr>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">1</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">0</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">0</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">0<sub>2</sub></td>
                    </tr>
                    <tr>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td class="tableDoubleUnderline">1</td>
                        <td class="tableDoubleUnderline">&nbsp;</td>
                        <td class="tableDoubleUnderline">0<sub>2</sub></td>
                    </tr>
                </table>
                <p>
                    Binary division is also done by shift and subtract.<br>
                    But each result depends on the previous, division cannot be easily to parallelized.<br>
                    <br>
                    So, the duration of binary multiplication is shorter than the duration of binary division.<br>
                </p>
                <br>
                <b>Boolean Algebra</b>
                <p>
                    How does our computer actually implement binary addition, subtraction, multiplication, division and shifting?<br>
                    How does it work with all these 0's and 1's?<br>
                    <br>
                    The basis of all our computer's circuits today comes from the work of a mathematician who died in 1864 - George Boole.<br>
                    Boole's work is what we call <span class="key">Boolean algebra</span> today.<br>
                    <br>
                    <span class="key">Boolean algebra</span> is a specific branch of algebra dedicated to work with only values <span class="key">true</span> and <span class="key">false</span>.<br>
                    The basic operators of Boolean algebra are <span class="key">AND</span>, <span class="key">OR</span>, <span class="key">NOT</span>.<br>
                    In computers, each of these "logic gates" can be created with a few transistors.<br>
                </p>
                <br>
                <b>OR operator</b>
                <p>
                    It is also called "disjunction".<br>
                    It denotes as x&or;y; it most closely relates to addition(+) in regular algebra, so it can be denoted as x+y.<br>
                    x&or;y is true if either<span class="math">x</span> or <span class="math">y</span> is true, or both.
                </p>
                <table class="textTable">
                    <tr>
                        <th>&nbsp;Logic gate OR for logic circuit diagram:&nbsp;</th>
                        <th colspan="3">&nbsp;Truth Table<br>(0 is false, 1 is true)&nbsp;</th>
                    </tr>
                    <tr>
                        <td rowspan="5"><img src="./image/cs230/lec2/2_1.PNG"></td>
                        <td class="math tableUnderline">&nbsp;x&nbsp;</td>
                        <td class="math tableLeftLine tableUnderline">&nbsp;y&nbsp;</td>
                        <td class="tableLeftLine tableUnderline">&nbsp;output&nbsp;</td>
                    </tr>
                    <tr>
                        <td class="math">0</td>
                        <td class="math tableLeftLine tableUnderline">0</td>
                        <td class="math tableLeftLine tableUnderline">0</td>
                    </tr>
                    <tr>
                        <td class="math">0</td>
                        <td class="math tableLeftLine tableUnderline">1</td>
                        <td class="math tableLeftLine tableUnderline">1</td>
                    </tr>
                    <tr>
                        <td class="math">1</td>
                        <td class="math tableLeftLine tableUnderline">0</td>
                        <td class="math tableLeftLine tableUnderline">1</td>
                    </tr>
                    <tr>
                        <td class="math">1</td>
                        <td class="math tableLeftLine tableUnderline">1</td>
                        <td class="math tableLeftLine tableUnderline">1</td>
                    </tr>
                </table>
                <br>
                <b>AND operator</b>
                <p>
                    It is also called "conjunction".<br>
                    It denotes as x&and;y; it most closely relates to multiplication(*) in regular algebra, so it can be denoted as x*y.<br>
                    AND means both of <span class="math">x</span> and <span class="math">y</span> must be true!<br>
                </p>
                <table class="textTable">
                    <tr>
                        <th>&nbsp;Logic gate AND for logic circuit diagram:&nbsp;</th>
                        <th colspan="3">&nbsp;Truth Table<br>(0 is false, 1 is true)&nbsp;</th>
                    </tr>
                    <tr>
                        <td rowspan="5"><img src="./image/cs230/lec2/2_2.PNG"></td>
                        <td class="math tableUnderline">&nbsp;x&nbsp;</td>
                        <td class="math tableLeftLine tableUnderline">&nbsp;y&nbsp;</td>
                        <td class="tableLeftLine tableUnderline">&nbsp;output&nbsp;</td>
                    </tr>
                    <tr>
                        <td class="math">0</td>
                        <td class="math tableLeftLine tableUnderline">0</td>
                        <td class="math tableLeftLine tableUnderline">0</td>
                    </tr>
                    <tr>
                        <td class="math">0</td>
                        <td class="math tableLeftLine tableUnderline">1</td>
                        <td class="math tableLeftLine tableUnderline">0</td>
                    </tr>
                    <tr>
                        <td class="math">1</td>
                        <td class="math tableLeftLine tableUnderline">0</td>
                        <td class="math tableLeftLine tableUnderline">0</td>
                    </tr>
                    <tr>
                        <td class="math">1</td>
                        <td class="math tableLeftLine tableUnderline">1</td>
                        <td class="math tableLeftLine tableUnderline">1</td>
                    </tr>
                </table>
                <br>
                <b>NOT operator</b>
                <p>
                    It is also called "negation".<br>
                    It denotes as &not;x, x&#772;, ~x or !x.<br>
                    NOT means the opposite of <span class="math">x</span>.<br>
                </p>
                <table class="textTable">
                    <tr>
                        <th>&nbsp;Logic gate NOT for logic circuit diagram:&nbsp;</th>
                        <th colspan="3">&nbsp;Truth Table<br>(0 is false, 1 is true)&nbsp;</th>
                    </tr>
                    <tr>
                        <td rowspan="3"><img src="./image/cs230/lec2/2_3.PNG"></td>
                        <td class="math tableUnderline">&nbsp;x&nbsp;</td>
                        <td class="tableLeftLine tableUnderline">&nbsp;output&nbsp;</td>
                    </tr>
                    <tr>
                        <td class="math">0</td>
                        <td class="math tableLeftLine tableUnderline">1</td>
                    </tr>
                    <tr>
                        <td class="math">1</td>
                        <td class="math tableLeftLine tableUnderline">0</td>
                    </tr>
                </table>
                <br>
                <p>
                    There also exists more specific gates that can be built from combinations of the above three operators.<br>
                    But these are so common and helpful, we use them in our Boolean algebra.<br>
                </p>
                <br>
                <b>XOR operator</b>
                <p>
                    It is also called "exclusive or".<br>
                    It denotes as x&oplus;y or x#y.<br>
                    It means "one or the other, but not both."<br>
                </p>
                <table class="textTable">
                    <tr>
                        <th>&nbsp;Logic gate XOR for logic circuit diagram:&nbsp;</th>
                        <th colspan="3">&nbsp;Truth Table<br>(0 is false, 1 is true)&nbsp;</th>
                    </tr>
                    <tr>
                        <td rowspan="5"><img src="./image/cs230/lec2/2_4.PNG"></td>
                        <td class="math tableUnderline">&nbsp;x&nbsp;</td>
                        <td class="math tableLeftLine tableUnderline">&nbsp;y&nbsp;</td>
                        <td class="tableLeftLine tableUnderline">&nbsp;output&nbsp;</td>
                    </tr>
                    <tr>
                        <td class="math">0</td>
                        <td class="math tableLeftLine tableUnderline">0</td>
                        <td class="math tableLeftLine tableUnderline">0</td>
                    </tr>
                    <tr>
                        <td class="math">0</td>
                        <td class="math tableLeftLine tableUnderline">1</td>
                        <td class="math tableLeftLine tableUnderline">1</td>
                    </tr>
                    <tr>
                        <td class="math">1</td>
                        <td class="math tableLeftLine tableUnderline">0</td>
                        <td class="math tableLeftLine tableUnderline">1</td>
                    </tr>
                    <tr>
                        <td class="math">1</td>
                        <td class="math tableLeftLine tableUnderline">1</td>
                        <td class="math tableLeftLine tableUnderline">0</td>
                    </tr>
                </table>
                <br>
                <img src="./image/cs230/lec2/2_5.PNG">
                <br><br>
                <b>NOR operator</b>
                <p>
                    It denotes as &not;(x&#8897;y) or x&darr;y.<br>
                    It means "neither", aka "NOT OR".<br>
                </p>
                <table class="textTable">
                    <tr>
                        <th>&nbsp;Logic gate NOR for logic circuit diagram:&nbsp;</th>
                        <th colspan="3">&nbsp;Truth Table<br>(0 is false, 1 is true)&nbsp;</th>
                    </tr>
                    <tr>
                        <td rowspan="5"><img src="./image/cs230/lec2/2_6.PNG"></td>
                        <td class="math tableUnderline">&nbsp;x&nbsp;</td>
                        <td class="math tableLeftLine tableUnderline">&nbsp;y&nbsp;</td>
                        <td class="tableLeftLine tableUnderline">&nbsp;output&nbsp;</td>
                    </tr>
                    <tr>
                        <td class="math">0</td>
                        <td class="math tableLeftLine tableUnderline">0</td>
                        <td class="math tableLeftLine tableUnderline">1</td>
                    </tr>
                    <tr>
                        <td class="math">0</td>
                        <td class="math tableLeftLine tableUnderline">1</td>
                        <td class="math tableLeftLine tableUnderline">0</td>
                    </tr>
                    <tr>
                        <td class="math">1</td>
                        <td class="math tableLeftLine tableUnderline">0</td>
                        <td class="math tableLeftLine tableUnderline">0</td>
                    </tr>
                    <tr>
                        <td class="math">1</td>
                        <td class="math tableLeftLine tableUnderline">1</td>
                        <td class="math tableLeftLine tableUnderline">0</td>
                    </tr>
                </table>
                <br>
                <b>NAND operator</b>
                <p>
                    It denotes as &not;(x&#8896;y) or x&uarr;y.<br>
                    It means "not both"; it is simply negation of AND.<br>
                </p>
                <table class="textTable">
                    <tr>
                        <th>&nbsp;Logic gate NOR for logic circuit diagram:&nbsp;</th>
                        <th colspan="3">&nbsp;Truth Table<br>(0 is false, 1 is true)&nbsp;</th>
                    </tr>
                    <tr>
                        <td rowspan="5"><img src="./image/cs230/lec2/2_7.PNG"></td>
                        <td class="math tableUnderline">&nbsp;x&nbsp;</td>
                        <td class="math tableLeftLine tableUnderline">&nbsp;y&nbsp;</td>
                        <td class="tableLeftLin tableUnderline">&nbsp;output&nbsp;</td>
                    </tr>
                    <tr>
                        <td class="math">0</td>
                        <td class="math tableLeftLine tableUnderline">0</td>
                        <td class="math tableLeftLine tableUnderline">1</td>
                    </tr>
                    <tr>
                        <td class="math">0</td>
                        <td class="math tableLeftLine tableUnderline">1</td>
                        <td class="math tableLeftLine tableUnderline">1</td>
                    </tr>
                    <tr>
                        <td class="math">1</td>
                        <td class="math tableLeftLine tableUnderline">0</td>
                        <td class="math tableLeftLine tableUnderline">1</td>
                    </tr>
                    <tr>
                        <td class="math">1</td>
                        <td class="math tableLeftLine tableUnderline">1</td>
                        <td class="math tableLeftLine tableUnderline">0</td>
                    </tr>
                </table>
                <br>
                <p>
                    Since this is Boolean algebra, we can combine these operators to form complex expression and of course, we have rules for how these operators write.<br> 
                </p>
                <table class="textTable">
                    <tr>
                        <th class="tableUnderline">Identity</th>
                        <th class="tableUnderline tableLeftLine">Name</th>
                    </tr>
                    <tr>
                        <td class="tableUnderline">&not;(&not;x) = x</td>
                        <td class="tableUnderline tableLeftLine">Double Negation</td>
                    </tr>
                    <tr>
                        <td>x&and;x = x</td>
                        <td rowspan="2" class="tableUnderline tableLeftLine">Idempotent Law</td>
                    </tr>
                    <tr>
                        <td class="tableUnderline">x&or;x = x</td>
                    </tr>
                    <tr>
                        <td>x&and;1 = x</td>
                        <td rowspan="2" class="tableUnderline tableLeftLine">Identity Law</td>
                    </tr>
                    <tr>
                        <td class="tableUnderline">x&or;0 = x</td>
                    </tr>
                    <tr>
                        <td>x&and;0 = 0</td>
                        <td rowspan="2" class="tableUnderline tableLeftLine">Domination Law</td>
                    </tr>
                    <tr>
                        <td class="tableUnderline">x&or;1 = 1</td>
                    </tr>
                    <tr>
                        <td>x&and;y = y&and;x</td>
                        <td rowspan="2" class="tableUnderline tableLeftLine">&nbsp;Commutative Law</td>
                    </tr>
                    <tr>
                        <td class="tableUnderline">x&or;y = y&or;x</td>
                    </tr>
                </table>
            </div>
            <hr>
            
            <div class="lce3">
                <h3>Lecture 3 - 11/01/2018</h3>
                <hr>
                <p>Example: Convert the following binary to decimal.</p>
                <table class="textTable">
                    <tr>
                        <th>Binary</th>
                        <th>Sign and Magnitude</th>
                        <th>1's Complement</th>
                        <th>2's Complement</th>
                    </tr>
                    <tr>
                        <td>0000<sub>2</sub></td>
                        <td>+0<sub>10</sub></td>
                        <td>+0<sub>10</sub></td>
                        <td>0<sub>10</sub></td>
                    </tr>
                    <tr>
                        <td>0001<sub>2</sub></td>
                        <td>+1<sub>10</sub></td>
                        <td>+1<sub>10</sub></td>
                        <td>1<sub>10</sub></td>
                    </tr>
                    <tr>
                        <td>1000<sub>2</sub></td>
                        <td>-0<sub>10</sub></td>
                        <td>-7<sub>10</sub></td>
                        <td>-8<sub>10</sub></td>
                    </tr>
                    <tr>
                        <td>1001<sub>2</sub></td>
                        <td>-1<sub>10</sub></td>
                        <td>-6<sub>10</sub></td>
                        <td>-7<sub>10</sub></td>
                    </tr>
                    <tr>
                        <td>1011<sub>2</sub></td>
                        <td>-3<sub>10</sub></td>
                        <td>-4<sub>10</sub></td>
                        <td>-5<sub>10</sub></td>
                    </tr>
                </table>
                <br>
                <p>
                    In human mind, t oconver binary to decimal under 2's complement, we can use the following formula:<br>
                </p>
                <img src="./image/cs230/lec3/3_sum.png" width="15%" height="15%">
                <br>
                <p>
                    For example: <span class="math">1001<sub>2</sub></span>
                </p>
                <table>
                    <tr>
                        <td>1001<sub>2</sub></td>
                        <td>= -2<sup>3</sup> + 0&times;2<sup>2</sup> + 0&times;2<sup>1</sup> + 1&times;2<sup>0</sup></td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>= -8<sub>10</sub> + 1<sub>10</sub></td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>= -7<sub>10</sub></td>
                    </tr>
                </table>
                <br>
                <b>Boolean Algebra</b>
                <table class="textTable">
                    <tr>
                        <th>Identity</th>
                        <th>Name</th>
                    </tr>
                    <tr>
                        <td>&not;(&not;x) = x</td>
                        <td>Law of the Double Complement</td>
                    </tr>
                    <tr>
                        <td>x&and;x = x</td>
                        <td rowspan="2">Idempotent Law</td>
                    </tr>
                    <tr>
                        <td>x&or;x = x</td>
                    </tr>
                    <tr>
                        <td>x&and;1 = x</td>
                        <td rowspan="2">Identity Law</td>
                    </tr>
                    <tr>
                        <td>x&or;0 = x</td>
                    </tr>
                    <tr>
                        <td>x&and;0 = 0</td>
                        <td rowspan="2">Domination Law</td>
                    </tr>
                    <tr>
                        <td>x&or;1 = 1</td>
                    </tr>
                    <tr>
                        <td>x&and;y = y&and;x</td>
                        <td rowspan="2">&nbsp;Commutative Law</td>
                    </tr>
                    <tr>
                        <td>x&or;y = y&or;x</td>
                    </tr>
                    <tr>
                        <td>x&or;(y&or;z) = (x&or;y)&or;z</td>
                        <td rowspan="2">Associative Law</td>
                    </tr>
                    <tr>
                        <td>x&and;(y&and;z) = (x&and;y)&and;z</td>
                    </tr>
                    <tr>
                        <td>x&or;(y&and;z) = (x&or;y)&and;(x&or;z)</td>
                        <td rowspan="2">Distributive Law</td>
                    </tr>
                    <tr>
                        <td>x&and;(y&or;z) = (x&and;y)&or;(x&and;z)</td>
                    </tr>
                    <tr>
                        <td>&not;(x&or;y) = (&not;x)&and;(&not;y)</td>
                        <td rowspan="2">DeMorgan's Law</td>
                    </tr>
                    <tr>
                        <td>&not;(x&and;y) = (&not;x)&or;(&not;y)</td>
                    </tr>
                    <tr>
                        <td>x&or;(x&and;y) = x</td>
                        <td rowspan="2">Absorption Law</td>
                    </tr>
                    <tr>
                        <td>x&and;(x&or;y) = x</td>
                    </tr>
                    <tr>
                        <td>x&or;(&not;x) = 1</td>
                        <td rowspan="2">Nonmonotone Law</td>
                    </tr>
                    <tr>
                        <td>x&and;(&not;x) = 0</td>
                    </tr>
                </table>
                <br>
                <p>
                    A Boolean expression represents a logic function.<br>
                    A logic function can be represented also by a logic circuit diagram, or a truth table.<br>
                    Example: (x&or;y)&and;(&not;x)
                </p>
                <table class="textTable">
                    <tr>
                        <th>&nbsp;Logic gate NOR for logic circuit diagram:&nbsp;</th>
                        <th colspan="5">&nbsp;Truth Table<br>(0 is false, 1 is true)&nbsp;</th>
                    </tr>
                    <tr>
                        <td rowspan="5"><img src="./image/cs230/lec3/3_1.png"></td>
                        <td>x</td>
                        <td>y</td>
                        <td>x&or;y</td>
                        <td>&not;x</td>
                        <td>(x&or;y)&and;(&not;x)</td>
                    </tr>
                    <tr>
                        <td>0</td>
                        <td>0</td>
                        <td>0</td>
                        <td>1</td>
                        <td>0</td>
                    </tr>
                    <tr>
                        <td>0</td>
                        <td>1</td>
                        <td>1</td>
                        <td>1</td>
                        <td>1</td>
                    </tr>
                    <tr>
                        <td>1</td>
                        <td>0</td>
                        <td>1</td>
                        <td>0</td>
                        <td>0</td>
                    </tr>
                    <tr>
                        <td>1</td>
                        <td>1</td>
                        <td>1</td>
                        <td>0</td>
                        <td>0</td>
                    </tr>
                </table>
                <br>
                <p>
                    It is worth mentioning that our variables represent logical statements.<br>
                    If you are ever confused about how to apply a law over a larger more complex expression, you can say "let p = (x&or;y&or;z)" and do your manipulations after subbing p into that expression, than resub back the real value to get the final result.<br>
                    <br>
                    Additionally, while drawing circuits, we can choose to draw an AND, OR, NAND, or NOR gate having an numbers of inputs.<br>
                    This is easily replicated in redraw.<br>
                </p>
                <table class="textTable">
                    <tr>
                        <th>x&or;y&or;z</th>
                        <th>x&and;y&and;z</th>
                    </tr>
                    <tr>
                        <td><img src="./image/cs230/lec3/3_2.png"></td>
                        <td><img src="./image/cs230/lec3/3_3.png"></td>
                    </tr>
                </table>
                <br>
                <p>
                    Now, we can draw logic gates and we know logic gates can be easily constructed with only a handful of circuit.<br>
                    So, let's build a circuit to add two bits together.<br>
                    <br>
                    Example: 1-column of Addition<br>
                    We want sum (is there 1 remaining in this column after addition) and carry (do we need to carry a 1 to the next column).<br>
                </p>
                <table class="textTable">
                    <tr>
                        <td>sum = A&oplus;B</td>
                        <td rowspan="2"><img src="./image/cs230/lec3/3_4.png"></td>
                    </tr>
                    <tr>
                        <td>carry = A&and;B</td>
                    </tr>
                </table>
                <br>
                <p>
                    So all of that for one column of addition.<br>
                    This circuit is called a <span class="key">Half-Adder</span>.<br>
                    The half-adder does not take into account the fact a carry bit may have come in from the previous column.<br>
                </p>
                <table class="textTable">
                    <tr>
                        <th>x</th>
                        <th>y</th>
                        <th>Carry<sub>in</sub></th>
                        <th>Carry<sub>out</sub></th>
                        <th>Sum</th>
                    </tr>
                    <tr>
                        <td>0</td>
                        <td>0</td>
                        <td>0</td>
                        <td>0</td>
                        <td>0</td>
                    </tr>
                    <tr>
                        <td>0</td>
                        <td>0</td>
                        <td>1</td>
                        <td>0</td>
                        <td>1</td>
                    </tr>
                    <tr>
                        <td>0</td>
                        <td>1</td>
                        <td>0</td>
                        <td>0</td>
                        <td>1</td>
                    </tr>
                    <tr>
                        <td>0</td>
                        <td>1</td>
                        <td>1</td>
                        <td>1</td>
                        <td>0</td>
                    </tr>
                    <tr>
                        <td>1</td>
                        <td>0</td>
                        <td>0</td>
                        <td>0</td>
                        <td>1</td>
                    </tr>
                    <tr>
                        <td>1</td>
                        <td>0</td>
                        <td>1</td>
                        <td>1</td>
                        <td>0</td>
                    </tr>
                    <tr>
                        <td>1</td>
                        <td>1</td>
                        <td>0</td>
                        <td>1</td>
                        <td>0</td>
                    </tr>
                    <tr>
                        <td>1</td>
                        <td>1</td>
                        <td>1</td>
                        <td>1</td>
                        <td>1</td>
                    </tr>
                </table>
                <br>
                <p>How about <span class="key">full-adder</span>?<br></p>
                <table class="textTable">
                    <tr>
                        <td>sum = x&oplus;y&oplus;Carry<sub>in</sub></td>
                        <td rowspan="2"><img src="./image/cs230/lec3/3_5.png"></td>
                    </tr>
                    <tr>
                        <td>carry = (x&and;y)&or;((x&oplus;y)&and;Carry<sub>in</sub>)</td>
                    </tr>
                </table>
                <br>
                <p>
                    Take away if you can build a truth table or logical expression, you can build a circuit (and all other combos too).<br>
                    So what about adding numbers with a width larger than 1?<br>
                    Stick a bunch of full-adders together!<br>
                </p>
                <img src="./image/cs230/lec3/3_6.png">
                <br><br>
                <p>
                    Example:<br>
                </p>
                <table>
                    <tr>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td><sub>1</sub></td>
                        <td>&nbsp;</td>
                        <td><sub>1</sub></td>
                        <td>&nbsp;</td>
                        <td><sub>1</sub></td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                    </tr>
                    <tr>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>(</td>
                        <td>x<sub>3</sub></td>
                        <td>&nbsp;</td>
                        <td>x<sub>2</sub></td>
                        <td>&nbsp;</td>
                        <td>x<sub>1</sub></td>
                        <td>&nbsp;</td>
                        <td>x<sub>0</sub></td>
                        <td>)</td>
                    </tr>
                    <tr>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>0</td>
                        <td>&nbsp;</td>
                        <td>1</td>
                        <td>&nbsp;</td>
                        <td>0</td>
                        <td>&nbsp;</td>
                        <td>1</td>
                        <td>&nbsp;</td>
                    </tr>
                     <tr>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>(</td>
                        <td>y<sub>3</sub></td>
                        <td>&nbsp;</td>
                        <td>y<sub>2</sub></td>
                        <td>&nbsp;</td>
                        <td>y<sub>1</sub></td>
                        <td>&nbsp;</td>
                        <td>y<sub>0</sub></td>
                        <td>)</td>
                    </tr>
                    <tr>
                        <td class="tableUnderline">+</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline"></td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">0</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">0</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">1</td>
                        <td class="tableUnderline">&nbsp;</td>
                        <td class="tableUnderline">1</td>
                        <td class="tableUnderline">&nbsp;</td>
                    </tr>
                    <tr>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td class="tableDoubleUnderline">1</td>
                        <td class="tableDoubleUnderline">&nbsp;</td>
                        <td class="tableDoubleUnderline">0</td>
                        <td class="tableDoubleUnderline">&nbsp;</td>
                        <td class="tableDoubleUnderline">0</td>
                        <td class="tableDoubleUnderline">&nbsp;</td>
                        <td class="tableDoubleUnderline">0</td>
                        <td>&nbsp;</td>
                    </tr>
                     <tr>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>&nbsp;</td>
                        <td>(</td>
                        <td>d<sub>3</sub></td>
                        <td>&nbsp;</td>
                        <td>d<sub>2</sub></td>
                        <td>&nbsp;</td>
                        <td>d<sub>1</sub></td>
                        <td>&nbsp;</td>
                        <td>d<sub>0</sub></td>
                        <td>)</td>
                    </tr>
                </table>
                <br>
                <p>
                    But there is a problem: this is kind of slow!<br>
                    The carry bit needs to propagate from each column to the next.<br>
                    So, this is linear in number of bits.<br>
                </p>
                <b>Carry-Lookahead Adder</b>
                <p>
                    This is faster than full adder.<br>
                    It is more complex(larger) circuits to determine carry.<br>
                    Trade-off is complexity and speed (example: power, cost, etc.).<br>
                    <br>
                    Now, we know how to represent integers and how basis operations work.<br>
                    But what about other data types?<br>
                    We know that a bit is the smallest piece of information representable - true or false.<br>
                </p>
                <br>
                <b>Byte</b>
                <p>
                    A byte today is 8 bits; it can easily be shown as two hexadecimal digits.<br>
                    <br>
                    A word is the size of instruction on the given architecture.<br>
                    The common architectures for now are 4 bytes (32 bits) and 8 bytes (64 bits).<br>
                    <br>
                    Words can be ordered in different way.<br>
                    What is the most significant byte?<br> This ordering is called <span class="key">Endianness</span>.<br>
                </p>
                <br>
                <b>Endianness</b>
                <p>
                    Big endian which is most significant byte first descending.<br>
                    Little endian which is least significant byte first asscending.<br>
                    <br>
                    If we want to represent the number <span class="math">0xDEADBEEF</span> in one 4-byte word, it looks like this.<br>
                </p>
                <table>
                    <tr class="textTable">
                        <td>&nbsp;Big Endian: </td>
                        <td>0xDE</td>
                        <td>0xAD</td>
                        <td>0xBE</td>
                        <td>0xEF</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&uarr;</td>
                        <td>&uarr;</td>
                        <td>&uarr;</td>
                        <td>&uarr;</td>
                    </tr>
                    <tr class="textTable">
                        <td></td>
                        <td>0x0010&nbsp;</td>
                        <td>0x0020&nbsp;</td>
                        <td>0x0030&nbsp;</td>
                        <td>0x0040&nbsp;</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&darr;</td>
                        <td>&darr;</td>
                        <td>&darr;</td>
                        <td>&darr;</td>
                    </tr>
                    <tr class="textTable">
                        <td>&nbsp;Little Endian: </td>
                        <td>0xEF</td>
                        <td>0xBE</td>
                        <td>0xAD</td>
                        <td>0xDE</td>
                    </tr>
                </table>
                <p>
                    Endianness is important!<br>
                    Think about two computers passing a file.<br>
                    If one computer stores in big endian but the other stores in little endian, they will not understand the file is the same!<br>
                    <br>
                    Endianness is important in network area; the standard for networking is big endian.<br>
                    <br>
                    Okay, so these are bits and bytes.<br>
                    But how do we store staff?<br>
                </p>
                <br>
                <b>Character</b>
                <p>
                    Character is letter!<br>
                    There are two famous character encoding standard.<br>
                    <br>
                    The first one is <span class="key">ASCII</span> (American Standard Code for Information Interchange).<br>
                    In ASCII, 1 byte means 1 character.<br>
                    The normal ASCII codes are using [0,127] and the extended ASCII codes are using [128,255].<br>
                    For example, [0,31] is for special control characters (non-printable), [48,57] is for number 0 to 9, [65,90] is for alphabet A to Z and [97,122] is for alphabet a to z.<br>
                    <br>
                    But... ASCII does not include other languages!<br>
                    So we have other standard called <span class="key">UTF-8</span> (8-bit Unicode Transformation Format).<br>
                    In UTF-8, we use 1 to 4 bytes to represent per character.<br>
                    The 1 byte encoding is compatible as ASCII - characters that tend to occur more frequently store in 1 byte.<br>
                </p>
                <br>
                <b>String</b>
                <p>
                    String is just a collection or array of characters.<br>
                    But how does the computer know the length of a string?<br>
                    Commonly, a string is terminated with the special character NULL(\0): 0x00.<br>
                    For example, "Hello" in ASCII is 0x48 0x65 0x6C 0x6c 0x6F 0x00.<br>
                </p>
            </div>
            <hr>
            
            <div class="lec4">
                <h3>Lecture 4 - 16/01/2018</h3>
                <hr>
                <b>Real Numbers</b>
                <p>
                    What is real number? For example, <span class="math">1.15</span> is real number.<br>
                    <br>
                    How does computer represent real numbers?<br>
                    First of all, let's talk about the <span class="key">Scientific Notation</span>.<br>
                    For example, <span class="math">-3.24&times;10<sup>56</sup></span>, and it is also called as <span class="key">Normalized Scientific Notation</span>.<br>
                    <br>
                    <span class="key">Normalized Scientific Notation</span>: one non-zero digit in front of the decimal point<br>
                    For example, <span class="math">0.002&times;10<sup>4</sup></span> and <span class="math">56.123&times;10<sup>8</sup></span> are not normalized.<br>
                    <br>
                    How do we write a real number in binary with scientific notation?<br>
                    For example, <span class="math">1.01<sub>2</sub> &sdot; 2<sup>1</sup></span> where the <span class="key">.</span> after 1 and before 0 is called a binary point (radix point generally).<br>
                    So what does <span class="math">1.01<sub>2</sub></span> mean?<br>
                    Before we answer this answer, we need to ask ourselves, what does <span class="math">1.01<sub>10</sub></span> mean?<br>
                    <span class="math">1.01<sub>10</sub> = 1 &sdot; 10<sup>0</sup> + 0 &sdot; 10<sup>-1</sup> + 1 &sdot; 10<sup>-2</sup></span><br>
                    With the same idea, we have...<br>
                    <span class="math">1.01<sub>2</sub> = 1 &sdot; 2<sup>0</sup> + 0 &sdot; 2<sup>-1</sup> + 1 &sdot; 2<sup>-2</sup> = 1 +  1/4 = 1.25<sub>10</sub></span><br>
                    <br>
                    How do we represent real numbers in our machines?<br>
                    We use what's called <span class="math">floating point number</span>.<br>
                    The reason it is called this name because it allow the binary point to "float" by changing the exponent.<br>
                    The opposite would be fixed point.<br>
                    <br>
                    Floating point is of the form <span class="math">I.F &sdot; B<sup>E</sup></span> where...<br>
                </p>
                <ul>
                    <li><span class="math">I</span>: Integer</li>
                    <li><span class="math">F</span>: Fractional</li>
                    <li><span class="math">B</span>: Base</li>
                    <li><span class="math">E</span>: Exponent</li>
                    <li><span class="math">I.F</span>: Significand (or "Mantissa")</li>
                </ul>
                <p>
                    Our floats are always normalized, so <span class="math">I</span> is always <span class="math">1</span>.<br>
                </p>
                <ul>
                    <li>left out of our representation is called "implicit/hidden point"</li>
                </ul>
                <p>
                    The base in always <span class="math">2</span> because we are in binary!<br>
                    So these are the components of our floating point.<br>
                    <br>
                    How does float represent in a machine? the standard <span class="key">IEEE 754</span>.<br>
                    We have single precision 32 bits, double precision 64 bits.<br>
                    <br>
                    Single Precision Float: 32 bits<br>
                </p>
                <img src="./image/cs230/lec4/4_1.png">
                <p>
                    We have 1 bit for the sign bit (green box), 8 bits for the exponent (red boxes) and the rest of the boxes (purple) are for the fractional.<br>
                    Note that integer and base are not represented since base is 2 and integer is always 1 except for special subnormal numbers.<br>
                    <br>
                    Also, we need to know that the exponent bits do not represent exactly the exponent <span class="math">e</span> in <span class="math">I.F &sdot; B<sup>e</sup></span>. Why?<br>
                    The standard uses a bias value, so the exponent bits represent an unsigned number and you subtract the bias from it.<br>
                    Bias for single precision is 127.<br>
                    <br>
                    So to calculate the value <span class="math">(-1)<sup>5</sup> &sdot; (I.F)&dot;2<sup>e-127</sup></span>, let's try calculating the decimal value of single precision float:<br>
                    <span class="math">0 10000100 11000000000000000000000</span><br>
                    The first <span class="math">0</span> is the sign bit.<br>
                    Then, <span class="math">10000100</span> are the exponent bits: <span class="math">10000100 = 128 + 4 - bias = 132 - 127 = 5</span><br>
                    The rest of the bits <span class="math">11000000000000000000000</span> are the fractional bits where<br>
                    &nbsp;&nbsp;<span class="math">1.11 = 1 + 2<sup>-1</sup> + 2<sup>-2</sup> = 1 + 0.5 + 0.25 = 1.75</span><br>
                    So, we now have:<br>
                </p>
                <table class="math">
                    <tr>
                        <td>(-1)<sup>S</sup> &sdot; (I.F) &sdot; 2<sup>e-127</sup></td>
                        <td>&nbsp;= (-1)<sup>0</sup> &sdot; (1.11) &sdot; 2<sup>5</sup></td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= 1 &sdot; (1.75) &sdot; 2<sup>5</sup></td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= 56.0</td>
                    </tr>
                </table>
                <p>
                    Let's consider a simplified 8-bit representation for floats: 1 bit for sign bit, 3 bits for exponent (bias = 3) and 4 bits for fractional.<br>
                    Note that bias is a choosing value, so you don't have to worry about it.<br>
                    <br>
                    Example: Express 4.5 in our simplified format.<br>
                    Note that <span class="math">4<sub>10</sub> = 100<sub>2</sub></span> and <span class="math">0.5<sub>10</sub> = 1/2<sub>10</sub> = 2<sup>-1</sup> = 0.1<sub>2</sub></span>.<br>
                    Thus, <span class="math">4.5<sub>10</sub> = 100.1<sub>2</sub></span>.<br>
                    Then we have <span class="math">100.1 &sdot; 2<sup>0</sup></span> and normalize it, we get <span class="math">1.001 &sdot; 2<sup>2</sup></span>.<br>
                    Next, the exponent is <span class="math">e + bias = 2 + 3 = 5 = 101<sub>2</sub></span> and sign bit is 0 since 4.5 is a positive number.<br>
                    So, we get 0 101 0010 as our final answer, where 0 is the sign bit, 101 is the exponent bits and 0010 is the fractional bits.<br>
                    <br>
                    Arithmetic with floats is easy.<br>
                    For addition, just set the exponents the same and add the significands (regular addition).<br>
                    <br>
                    Example: Add 1.25 and 2.125 in our simplified format.<br>
                    Note that <span class="math">1.25 = 1.01 &sdot; 2<sup>0</sup></span>.<br>
                    So we know that <span class="math">F = 0100</span>, <span class="math">E = 0 + 3 = 3 = 011</span> and <span class="math">S = 0</span>.<br>
                    Thus, <span class="math">1.25<sub>10</sub> = 0 011 0100<sub>2</sub></span>.<br>
                    Also, <span class="math">2.125 = 1.0001 &sdot; 2<sup>1</sup></span>.<br>
                    So we know that <span class="math">F = 0001</span>, <span class="math">E = 1 + 3 = 4 = 100</span> and <span class="math">S = 0</span>.<br>
                    Thus, <span class="math">2.125<sub>10</sub> = 0 100 0001<sub>2</sub></span>.<br>
                </p>
                <table class="math">
                    <tr>
                        <td>1.25 + 2.125</td>
                        <td>&nbsp;= 1.01 &sdot; 2<sup>0</sup> + 1.0001 &sdot; 2<sup>1</sup></td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= 1.01 &sdot; 2<sup>0</sup> + 10.001 &sdot; 2<sup>0</sup></td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= 11.011 &sdot; 2<sup>0</sup></td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= 1.1011 &sdot; 2<sup>1</sup></td>
                    </tr>
                </table>
                <p>
                    From the normalized scientific notation <span class="math">1.1011 &sdot; 2<sup>1</sup></span>, we know that <span class="math">F = 1011</span>, <span class="math">E = 1 + 3 = 4 = 100</span> and <span class="math">S = 0</span>.<br>
                    So our final answer is 0 100 1011.<br>
                    <br>
                    For multiplication, we add exponents, then multiply significands.<br>
                    For example, <span class="math">1.5 &sdot; 2.25</span>.<br>
                    Note that <span class="math">1.5 = 0 011 100</span> and <span class="math">2.25 = 0 100 0010</span>.<br>
                    Step 1 - Add Exponents:<br>
                    <span class="math">(E<sub>1.5</sub> - bias) + (E<sub>2.25</sub> - bias) = (011 - 011) + (100 - 011) = 1 = e</span><br>
                    So <span class="math">E = 1 + 3 = 4 = 100<sub>2</sub></span>.<br>
                    Step 2 - Multiply Significands:<br>
                </p>
                <table class="math">
                    <tr>
                        <td>1.1000 &times; 1.0010</td>
                        <td>&nbsp;= (1 &sdot; 1.001) + (0.1 &sdot; 1.001)</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= 1.001 + 0.1001</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= 1.1011</td>
                    </tr>
                </table>
                <p>
                    So our new fractional bits are 1011, new exponent bits are 100 and new sign bit is 0.<br>
                    Therefore, <span class="math">1.5 &sdot; 2.25 = 0 100 1011</span>.<br>
                    <br>
                    However, examining our simplified format we can see the problems that arise in floating point numbers.<br>
                    The first problem is there exists infinite numbers between 0 and 1, but we cannot represent infinite numbers within 32 bits!<br>
                    For example, consider 15.25 in our 8-bit system:<br>
                    <span class="math">15.25 = 1111.01 &sdot; 2<sup>0</sup> = 1.11101 &sdot; 2<sup>3</sup></span><br>
                    We need 5 bits for the fraction but we only have 4 bits to use!<br>
                    So we get an overflow, which is <span class="math">1.1110 &sdot; 2<sup>3</sup></span>.<br>
                    If we round up, we get 15.5; if we round down, we get 15.0.<br>
                    <br>
                    So overflow can happen; they get represented as <span class="key">inf</span> (also occurs for divide by 0).<br>
                    <br>
                    For IEEE 754,<br>
                </p>
                <table class="textTable">
                    <tr>
                        <th>Exponent Bits</th>
                        <th>Fractional Bits</th>
                        <th>Value/Type</th>
                    </tr>
                    <tr>
                        <td>0000 0000</td>
                        <td>00...00</td>
                        <td>0</td>
                    </tr>
                    <tr>
                        <td>0000 0000</td>
                        <td>non-zero</td>
                        <td>subnormal</td>
                    </tr>
                    <tr>
                        <td>0000 0000 1...1111 1110</td>
                        <td>Any</td>
                        <td>normal number</td>
                    </tr>
                    <tr>
                        <td>1111 1111</td>
                        <td>00...00</td>
                        <td>infinity</td>
                    </tr>
                    <tr>
                        <td>1111 1111</td>
                        <td>non-zero</td>
                        <td>NaN</td>
                    </tr>
                </table>
                <p>
                    What is <span class="key">NaN</span>? It means "not a number".<br>
                    For example, &radic;-1, &infin;/&infin; and &infin; &sdot; 0.<br>
                    <br>
                    If we didn't create a special case for subnormal numbers, then the gap between 0 and our smallest representable number would be:<br>
                    <span class="math">0 000 0000<sub>2</sub> = 1.0000 &sdot; 2<sup>-3</sup> = 0.1255</span><br>
                    That is a large gap! Often we talk about small numbers.<br>
                    This also means our gap between adjacent numbers is <span class="math">0.0001 &sdot; 2<sup>-3</sup> = 2<sup>-7</sup></span>.<br>
                    <br>
                    Instead, we treat subnormal numbers as a special case.<br>
                    So, when we would have (0 - bias) exponent instead we do (1 - bias) as exponent and have the implicit bit be 0.<br>
                    This is how to interpret subnormal numbers: <span class="math">(-1)<sup>S</sup> &sdot; (0.F) &sdot; 2<sup>1 - bias</sup></span><br>
                </p>
                <ul>
                    <li>Smallest number (&gt;0) is <span class="math">1.00 &sdot; 2<sup>-2</sup></span></li>
                    <li>Gap between number is <span class="math">0.0001 &sdot; 2<sup>-2</sup></span> (worse)</li>
                    <li>Smallest subnormal number is <span class="math">0.0001 &sdot; 2<sup>-2</sup> = 0.01525</span> (much better!)</li>
                </ul>
                <p>
                    So using subnormal numbers we get a larger gap between our numbers (largest/smallest possible exponent).<br>
                    But we get closer to 0 before losing all our precision.<br>
                    Tradeoff is the gaps between representable numbers and how close to 0 we can get.<br>
                </p>
                <br>
                <b>Gradual Underflow</b>
                <p>
                    Don't forget floating point is not exact, it is only an approximation of real numbers.<br>
                    For example, 0.1 cannot be represented in IEEE 754.<br>
                    Therefore, don't use <code>==</code> on floats.<br>
                    Also, associativity and distribution or arithmetic operators are not guaranteed!<br>
                </p>
                <br>
                <b>Assembly Language</b>
                <p>
                    Recall: Computers only understand set instructions which are group of 1's and 0's (machine code).<br>
                    <br>
                    A assembly language is one step up from that - basis operations that operate on registers.<br>
                    It has a direct translation to machine code.<br>
                    <br>
                    A program called an assembler translates assembly to machine code.<br>
                    <br>
                    In order to understand how computers/programs work, we are going to study <span class="key">MIPS</span> on assembly language.<br>
                    Because assembly languages operate on registers (actual hardware of CPU), assembly languages are tied to hardware.<br>
                    Hence why we use an emulator.<br>
                    <br>
                    <span class="key">MIPS</span> is an acronym for Microprocessor without Interlocked Pipeline Stages; we will talk about the meaning later (someday in the future).<br>
                    <br>
                    In MUPS, we have 32 registers (which are labeled with $0 to $31).<br>
                    Each register is 32 bits.<br>
                    Why we only have 32 registers, not more? More means slower - we need more bits to store a register.<br>
                    For now, we only need 5 bits to store 32 registers.<br>
                    <br>
                    <span class="key">Special Registers</span><br>
                    PC (program counter) holds the memory address of the next instruction; each instruction done increments it by 4, or it can be manipulator.<br>
                    <br>
                    <span class="key">Register 0 ($0)</span>: It is the constant 0; otherwise, the machine will die!<br>
                    <br>
                    <span class="key">Conventions</span><br>
                    $31 is the return address and $30, $29 and $28 are special.<br>
                </p>
            </div>
            <hr>
            
            <div class="lec5">
                <h3>Lecture 5 - 18/01/2018</h3>
                <hr>
                <b>Announcements:</b>
                <p>
                    Assignment 1 is due tomorrow!<br>
                    Midterm is 3 weeks after today!<br>
                </p>
                <br>
                <b>Midterm</b>
                <p>
                    In midterm, you can have one 8.5" &times; 11" (inches) single-sided "cheat sheet".<br>
                    You can write anything on the cheat sheet, but only single sided.<br>
                    It will be taken away during midterm if it is NOT single sided.<br>
                    It will be collected with your midterm paper.<br>
                    One more thing, this cheat sheet must be hand-written.<br>
                </p>
                <br>
                <b>MIPS (Microprocessor without Interlocked Pipeline Stages)</b>
                <p>
                    MIPS does NOT stand for "Millions for Instructions Per Second".<br>
                    <br>
                    It is an assembly language; it has direct translation to machine code.<br>
                    We use assembler to translate from assembly language to machine code.<br>
                    An assembly language operates directly on the registers in the CPU, so it is tied to the hardware.<br>
                    <br>
                    In MIPS, we have 32 registers labeled with 0 to 31.<br>
                </p>
                <br>
                <b>Special Registers</b>
                <ul>
                    <li>Program Counter (PC) holds the address of the next instruction to execute</li>
                    <li>Register 0 ($0): constant 0</li>
                    <li>Conversion $31: return address</li>
                    <li>Conversions $28, $29, $30: global, stack, frame, etc.; our emulator uses $30 for stack pointer (SP)</li>
                </ul>
                <br>
                <b>Instructions</b>
                <p>
                    They have up to 3 operands, often registers.<br>
                    When using 3 operands, the first one is the destination, the other two are sources.<br>
                    <br>
                    Example: Addition<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>add $8, $9, $10<br>
                    </code></pre>
                </span>
                <p>
                    This instruction add the values stored in register 9 and register 10 together, then store the result in register 8.<br>
                    <br>
                    The general form for these R-type instruction (register instruction) is:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>add $d, $s, $t<br>
                    </code></pre>
                </span>
                <p>
                    <code>$d</code> is the destination register (Rd); <code>$s</code> and <code>$t</code> are the source registers, which are denoted as Rs and Rt.<br>
                    The instruction <span class="add">add</span> means <span class="math"> d = s + t</span> and the values stored in those registers.<br>
                    <br>
                    Example: Subtraction<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>sub $d, $s, $t &nbsp;; d = s - t<br>
                    </code></pre>
                </span>
                <p>
                    Note that <code>;</code> is how to start a comment in MIPS.<br>
                    <br>
                    What if we want a value that does not already exist in one of our registers? We can use <span class="key">immediate</span> instruction.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>addi $t, $s, i<br>
                    </code></pre>
                </span>
                <p>
                    In here, <code>$t</code> is the destination register and <code>$s</code> is the source register.<br>
                    How about <code>i</code>? This is an I-type instruction, which means we are using a literal value.<br>
                    <br>
                    Example: Add the value in register 8 to the literal value 42, then store the result in register 15.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>addi $15, $8, 42<br>
                    </code></pre>
                </span>
                <p>
                    Example: Add 10 and 24, subtract 3, store result in $3.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>addi $1, $0, 10 &nbsp;; initialize $1 to 10<br>
                        <span class="cline">02&nbsp;&nbsp;</span>addi $2, $0, 24 &nbsp;; initialize $2 to 24<br>
                        <span class="cline">03&nbsp;&nbsp;</span>add &nbsp;$3, $1, $2 &nbsp;; add the value 10 and 24 in register 1 and register 2, store result in register 3<br>
                        <span class="cline">05&nbsp;&nbsp;</span>addi $3, $3, -3 &nbsp;; subtract 3 from value in register 3, store result in register 3<br>
                        <span class="cline">06&nbsp;&nbsp;</span>jr &nbsp;&nbsp;$31 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; need this to terminate program in emulator<br>
                    </code></pre>
                </span>
                <br>
                <p>
                    <span class="key">Multiplication</span><br>
                    Note that we have 32 bits in our registers.<br>
                    If we multiply 2 32-bit numbers together, the result could have as many as 64 bits.<br>
                    Hence, we have the special registers "hi" and "lo" to store the result.<br>
                </p>
                <table>
                    <tr>
                        <td>&nbsp;hi</td>
                        <td colspan="5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
                        <td>&nbsp;lo</td>
                        <td colspan="5">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
                    </tr>
                    <tr>
                        <td colspan="6" class="tableBox">&nbsp;32 bits&nbsp;</td>
                        <td colspan="6" class="tableBox">&nbsp;32 bits&nbsp;</td>
                    </tr>
                </table>
                <br>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>mul $s, $t &nbsp;; $s&times;$t, place result in hi and lo<br>
                    </code></pre>
                </span>
                <p>
                    <span class="key">Special instructions to copy from hi and lo:</span><br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>mfhi $d &nbsp;; "move from hi" and copy the value in $hi to $d<br>
                        <span class="cline">02&nbsp;&nbsp;</span>mflo $d &nbsp;; "move from lo" and copy the value in $lo to $d<br>
                    </code></pre>
                </span>
                <p>
                    <span class="key">Division</span>: <code>div $s, $t  ; $s / $t</code><br>
                    It is always integer division; it place the quotient in $lo and the remainder in $hi.<br>
                    <br>
                    Example: Calculate average of 3 numbers stored in $3, $4 and $5, then store result in #3.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>; calculate ($3 + $4 + $5) / $3<br>
                        <span class="cline">02&nbsp;&nbsp;</span>add &nbsp;$3, $4, $3<br>
                        <span class="cline">03&nbsp;&nbsp;</span>add &nbsp;$3, $5, $3<br>
                        <span class="cline">04&nbsp;&nbsp;</span>addi $6, $0, 3<br>
                        <span class="cline">05&nbsp;&nbsp;</span>div &nbsp;$3, $6<br>
                        <span class="cline">06&nbsp;&nbsp;</span>mflo $3<br>
                        <span class="cline">07&nbsp;&nbsp;</span>jr &nbsp;&nbsp;$31<br>
                    </code></pre>
                </span>
                <p>
                    So now we can do basic math. Yeah!<br>
                    But what if we cant to do basic math lots of times?<br>
                    In Python, we have constructs like while loop, for loop, recursion for repetition.<br>
                    If we want repetition in MIPS, we need to manipulate $PC.<br>
                    <br>
                    <span class="key">Conditional Branches</span><br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>beq $s, $t, label &nbsp;; branch if equal<br>
                        <span class="cline">02&nbsp;&nbsp;</span>; if $s == $t, then goto label<br>
                        <span class="cline">03&nbsp;&nbsp;</span>; overwrite $pc with the address of the instruction at label<br>
                        <span class="cline">04&nbsp;&nbsp;</span><br>
                        <span class="cline">05&nbsp;&nbsp;</span>bne $s, $t, label &nbsp;; branch if not equal<br>
                        <span class="cline">06&nbsp;&nbsp;</span>; if $s != $t, then goto label<br>
                    </code></pre>
                </span>
                <p>
                    Example: Write a loop with MIPS.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>addi $1, $0, 10<br>
                        <span class="cline">02&nbsp;&nbsp;</span>loopStart:<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;addi $1, $1, -1<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;; loop body<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;bne $1, $0, loopStart<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;jr $31<br>
                    </code></pre>
                </span>
                <p>
                    Example: Calculate <span class="math">0 + 1 + ... + n</span> where <span class="math">n</span> is stored in $8, and store result in $7.<br>
                    In Python...<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>;; assume n already initialized<br>
                        <span class="cline">02&nbsp;&nbsp;</span>iter = n<br>
                        <span class="cline">03&nbsp;&nbsp;</span>y = 0<br>
                        <span class="cline">04&nbsp;&nbsp;</span>while (iter != 0):<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;y = y + iter<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;iter = iter - 1<br>
                    </code></pre>
                </span>
                <p>
                    In MIPS: assume n = $8, y = $7 and iter = $9<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>add $9, $8, $0 &nbsp;&nbsp;; iter = n<br>
                        <span class="cline">02&nbsp;&nbsp;</span>add $7, $0, $0 &nbsp;&nbsp;; y = 0<br>
                        <span class="cline">03&nbsp;&nbsp;</span>beq $9, $0, end &nbsp;; skip if iter == 0<br>
                        <span class="cline">04&nbsp;&nbsp;</span>loopStart:<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;add &nbsp;$7, $7, $8  ; y = y + iter<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;addi $9, $9, -1  ; iter = iter - 1<br>
                        <span class="cline">07&nbsp;&nbsp;</span>&nbsp;&nbsp;bne &nbsp;$9, $0, loopStart<br>
                        <span class="cline">08&nbsp;&nbsp;</span>end:<br>
                        <span class="cline">09&nbsp;&nbsp;</span>&nbsp;&nbsp;jr $31<br>
                    </code></pre>
                </span>
                <p>
                    There are more instructions. For example...<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>slt $d, $s, $t<br>
                    </code></pre>
                </span>
                <p>
                    This instruction is "set less than".<br>
                    If $s &lt; $t, then $d := 1, otherwise $d := 0.<br>
                    It is just a comparison operator with the result (T/F) store in $d.<br>
                    So we can combine this with branches to simulate conditional.<br>
                    <br>
                    Example: if x &lt; y, set x := x - y<br>
                    In Python, we do...<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>if (x &lt; y):<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;x = x - y<br>
                    </code></pre>
                </span>
                <p>
                    In MIPS, let x = $7, y = $8<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>slt $6, $7, $8<br>
                        <span class="cline">02&nbsp;&nbsp;</span>beq $6, $0, done<br>
                        <span class="cline">03&nbsp;&nbsp;</span>sub $7, $7, $8<br>
                        <span class="cline">04&nbsp;&nbsp;</span>done:<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;jr $31<br>
                    </code></pre>
                </span>
                <br>
                <b>Memory</b>
                <p>
                    Memory region forms in MIPS is 2<sup>32</sup> bytes (4GiB).<br>
                    Note that <span class="math">2<sup>30</sup> = 1</span> gibibyte and so <span class="math">2<sup>30</sup> &times; 4 = 4</span> gibibytes <span class="math">= 2<sup>32</sup></span>.<br>
                    Memory is essentially a huge array, addresses are the indices or rather always are small bits of memory, indices are address offsets.<br>
                    <br>
                    In this course, we use word-aligned memory access/addressing (4-byte).<br>
                    MIPS word = 43 bits<br>
                </p>
                <table>
                    <tr>
                        <td>&nbsp;</td>
                        <td colspan="4" class="textTable">32 bits</td>
                    </tr>
                    <tr>
                        <td>0</td>
                        <td class="tableBox">0</td>
                        <td class="tableBox">1</td>
                        <td class="tableBox">2</td>
                        <td class="tableBox">3</td>
                    </tr>
                    <tr>
                        <td>4</td>
                        <td class="tableBox">0</td>
                        <td class="tableBox">1</td>
                        <td class="tableBox">2</td>
                        <td class="tableBox">3</td>
                    </tr>
                    <tr>
                        <td>8</td>
                        <td class="tableBox">0</td>
                        <td class="tableBox">1</td>
                        <td class="tableBox">2</td>
                        <td class="tableBox">3</td>
                    </tr>
                    <tr>
                        <td>...</td>
                        <td class="tableBox">...</td>
                        <td class="tableBox">...</td>
                        <td class="tableBox">...</td>
                        <td class="tableBox">...</td>
                    </tr>
                </table>
                <p>
                    Accessing Memory: <code>lw $t, i($s)  ; load word</code><br>
                    It treats the value in register $s as an address for memory, add i to $s.<br>
                    Then the result as an address, copy the word (32 bits) stored at that address into register t.<br>
                    Note that i = $s <span class="key">MUST</span> be word aligned (divisible by 4).<br>
                    <br>
                    Example: <code>lw  $2, 4($1)</code>
                </p>
                <table>
                    <tr>
                        <th colspan="2" class="textTable">&nbsp;Register:&nbsp;</th>
                        <td></td>
                        <th colspan="2" class="textTable">&nbsp;Memory:&nbsp;</th>
                    </tr>
                    <tr>
                        <td class="textTable">&nbsp;0&nbsp;</td>
                        <td class="tableBox">&nbsp;0x00000000&nbsp;</td>
                        <td class="textTable">&nbsp;</td>
                        <td class="textTable">&nbsp;address&nbsp;</td>
                        <td class="textTable">&nbsp;value&nbsp;</td>
                    </tr>
                    <tr>
                        <td class="textTable">&nbsp;1&nbsp;</td>
                        <td class="tableBox">&nbsp;0x00000010&nbsp;</td>
                        <td class="textTable">&nbsp;</td>
                        <td class="textTable">&nbsp;0&nbsp;</td>
                        <td class="textTable">&nbsp;12&nbsp;</td>
                    </tr>
                    <tr>
                        <td class="textTable">&nbsp;2&nbsp;</td>
                        <td class="tableBox">&nbsp;0x00000015&nbsp;</td>
                        <td class="textTable">&nbsp;</td>
                        <td class="textTable">&nbsp;4&nbsp;</td>
                        <td class="textTable">&nbsp;42&nbsp;</td>
                    </tr>
                    <tr class="textTable">
                        <td colspan="3">&nbsp;</td>
                        <td>&nbsp;8&nbsp;</td>
                        <td>&nbsp;9&nbsp;</td>
                    </tr>
                    <tr class="textTable">
                        <td colspan="3">&nbsp;</td>
                        <td>&nbsp;12&nbsp;</td>
                        <td>&nbsp;17&nbsp;</td>
                    </tr>
                    <tr class="textTable">
                        <td colspan="3">&nbsp;</td>
                        <td>&nbsp;16&nbsp;</td>
                        <td>&nbsp;125&nbsp;</td>
                    </tr>
                    <tr class="textTable">
                        <td colspan="3">&nbsp;</td>
                        <td>&nbsp;20&nbsp;</td>
                        <td>&nbsp;21&nbsp;</td>
                    </tr>
                    <tr>
                        <td colspan="3">&nbsp;</td>
                        <td>&nbsp;24&nbsp;</td>
                        <td>&nbsp;100&nbsp;</td>
                    </tr>
                    <tr>
                        <td colspan="3">&nbsp;</td>
                        <td>&nbsp;...&nbsp;</td>
                        <td>&nbsp;...&nbsp;</td>
                    </tr>
                </table>
                <p>
                    Since the value in $1 is 16, then <span class="math">4($1) = 4 + $1 = 4 + 16 = 20</span>.<br>
                    So we are looking for the address 20.<br>
                    Therefore, we need to store the value 21 into $2.<br>
                    <br>
                    Make sure you can differentiate between:<br>
                </p>
                <ul>
                    <li>register <u>number</u> (0 - 31)</li>
                    <li>
                        register value (e.g. $20)
                        <ul>
                            <li>contents of the registers</li>
                        </ul>
                    </li>
                    <li>memory address</li>
                    <li>memory contents (value)</li>
                </ul>
                <p>
                    Example: Read values stored in memory addresses 64 and 72, add them together, store the result in address 80.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>addi &nbsp;$1, $0, 64<br>
                        <span class="cline">02&nbsp;&nbsp;</span>lw &nbsp;&nbsp;&nbsp;$2, 0($1)<br>
                        <span class="cline">03&nbsp;&nbsp;</span>lw &nbsp;&nbsp;&nbsp;$3, 8($1)<br>
                        <span class="cline">04&nbsp;&nbsp;</span>add &nbsp;&nbsp;$4, $2, $3<br>
                        <span class="cline">05&nbsp;&nbsp;</span>sw &nbsp;&nbsp;&nbsp;$4, 16($1) ; save word<br>
                        <span class="cline">06&nbsp;&nbsp;</span>jr &nbsp;&nbsp;$31<br>
                    </code></pre>
                </span>
                <p>
                    Remember a program is just a bunch of machine code instructions (1's and 0's).<br>
                    <br>
                    What do our 32-bit instructions look like in memory?<br>
                    R-type Instructions (e.g. add)<br>
                </p>
                <table class="textTable">
                    <tr>
                        <td>op</td>
                        <td>Rs</td>
                        <td>Rt</td>
                        <td>Rd</td>
                        <td>shamt</td>
                        <td>func</td>
                    </tr>
                    <tr>
                        <td>6 bits</td>
                        <td>5 bits</td>
                        <td>5 bits</td>
                        <td>5 bits</td>
                        <td>5 bits</td>
                        <td>6 bits</td>
                    </tr>
                </table>
                <br>
                <ul>
                    <li>op: op-code</li>
                    <li>Rs, Rt, Td: the source registers and the destination register</li>
                    <li>shamt: shift amount (only used for shift instructions)</li>
                    <li>func: works together with op-code to denote arithmetic instructions</li>
                </ul>
            </div>
            <hr>
            
            <div class="lec6">
                <h3>Lecture 6 - 23/01/2018</h3>
                <hr>
                <p>
                    Recall: A program is just a series of instructions, and instructions are just specific groups of 1's and 0's.<br>
                    <br>
                    So, what does a program look like in memory?<br>
                    In MIPS, we have 32-bit instructions with 3 different instruction types: R-type, I-type and J-type.<br>
                </p>
                <b>R-type Instruction</b>
                <table class="textTable">
                    <tr>
                        <td>Op-code</td>
                        <td>R<sub>s</sub></td>
                        <td>R<sub>t</sub></td>
                        <td>R<sub>d</sub></td>
                        <td>shamt</td>
                        <td>func</td>
                    </tr>
                    <tr>
                        <td>6 bits</td>
                        <td>5 bits</td>
                        <td>5 bits</td>
                        <td>5 bits</td>
                        <td>5 bits</td>
                        <td>6 bits</td>
                    </tr>
                </table>
                <p>
                    R<sub>s</sub>, R<sub>t</sub>: the source registers.<br>
                    R<sub>d</sub>: the destination register.<br>
                    shamt: shift amount, only used for shift operations.<br>
                    func: 6 bits used in tandem with the op-code to denote arithmetic instructions.<br>
                </p>
                <b>I-type Instruction</b>
                <table class="textTable">
                    <tr>
                        <td>Op-code</td>
                        <td>R<sub>s</sub></td>
                        <td>R<sub>t</sub></td>
                        <td>Immediate Value</td>
                    </tr>
                    <tr>
                        <td>6 bits</td>
                        <td>5 bits</td>
                        <td>5 bits</td>
                        <td>16 bits</td>
                    </tr>
                </table>
                <br>
                <b>J-type Instruction</b>
                <table class="textTable">
                    <tr>
                        <td>Op-code</td>
                        <td>Address</td>
                    </tr>
                    <tr>
                        <td>6 bits</td>
                        <td>26 bits</td>
                    </tr>
                </table>
                <br>
                <p>
                    Example: What is the binary represent of <code>add $3, $1, $2</code>?<br>
                    According to our MIPS Reference Sheet, we know that...<br>
                    The op-code binary is <code>000000</code>, the shamt binary is <code>00000</code> and the function binary is <code>100000</code>.<br>
                    Now we need to find the binary of R<sub>s</sub>($1), R<sub>t</sub>($2) and R<sub>d</sub>($3).
                    Notice that the binary of 3 is <code>00011</code>, the binary of 1 is <code>00001</code> and the binary of 2 is <code>00010</code>.<br>
                    Therefore, the binary represent of <code>add $3, $1, $2</code> is <code>0000 0000 0010 0010 0001 1000 0010 0000</code>.<br>
                    <br>
                    Example: Given <code>0000 0000 1000 0101 0011 1000 0010 1010</code>, what is this instruction?<br>
                    The first 6 bits <code>000000</code> is for op-code, so we know that this is a R-type instruction.<br>
                    Then the last 6 bits <code>101010</code> is for function, and according to our MIPS Reference Sheet, the instruction is <code>slt</code>.<br>
                    Then we get 4 from the R<sub>s</sub> bits <code>00100</code>, 5 from the R<sub>t</sub> bits <code>00101</code>, 7 from the R<sub>d</sub> bits <code>00111</code>, and the shamt bits are <code>00000</code>.<br>
                    Therefore, <code>0000 0000 1000 0101 0011 1000 0010 1010</code> is <code>slt $7, $5, %7</code>.<br>
                    <br>
                    Note that the binary represent of shamt is always <code>00000</code> and we don't have to worry/carry about it in this course.<br>
                    <br>
                    Example: Find the binary represent of <code>addi $5, $0, 42</code>.<br>
                    Answer: <code>0010 0000 0000 0101 0000 0000 0010 1010</code> where <code>001000</code> is the op-code, <code>00000</code> is the R<sub>s</sub>($0), <code>00101</code> is the R<sub>t</sub>($5) and <code>0000000000101010</code> is the immediate value 42.<br>
                    <br>
                    In this course, our programs start at memory address 0 - the "top" of memory.<br>
                    That means our program counter(PC) starts at 0 and increments by 4 each instruction.<br>
                </p>
                <table>
                    <tr>
                        <td class="textTable">&nbsp;0&nbsp;</td>
                        <td class="tableBox">&nbsp;instruction 1&nbsp;</td>
                    </tr>
                    <tr>
                        <td class="textTable">&nbsp;4&nbsp;</td>
                        <td class="tableBox">&nbsp;instruction 2&nbsp;</td>
                    </tr>
                    <tr>
                        <td class="textTable">&nbsp;8&nbsp;</td>
                        <td class="tableBox">&nbsp;instruction 3&nbsp;</td>
                    </tr>
                    <tr>
                        <td class="textTable">&nbsp;12&nbsp;</td>
                        <td class="tableBox">&nbsp;instruction 4&nbsp;</td>
                    </tr>
                    <tr>
                        <td class="textTable">&nbsp;...&nbsp;</td>
                        <td class="tableBox">&nbsp;...&nbsp;</td>
                    </tr>
                </table>
                <br>
                <p>
                    Generally, our data is stored after our program.<br>
                    We could put it in the middle and jump over it, but why bother?<br>
                    <br>
                    Immediate instructions limit us to 16-bit immediate value, but we have 32 bits of space in our registers! It seems wasteful.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>lis&nbsp;&nbsp;&nbsp;$d&nbsp;&nbsp;&nbsp;&nbsp;; instruction is 1 word<br>
                        <span class="cline">02&nbsp;&nbsp;</span>.word 4254&nbsp;&nbsp;; value is 1 word<br>
                    </code></pre>
                </span>
                <br>
                <p>
                    The r-type instruction <code>lis $d</code> means "load immediate and skip".<br>
                    It treats the next 32 bits as data, load into <code>$d</code> and skip over that word.<br>
                    In memory...<br>
                </p>
                <table>
                    <tr>
                        <td class="textTable">&nbsp;0&nbsp;</td>
                        <td class="tableBox">&nbsp;instruction 1&nbsp;</td>
                        <td class="textTable">&nbsp;<code>lis $d</code>&nbsp;</td>
                    </tr>
                    <tr>
                        <td class="textTable">&nbsp;4&nbsp;</td>
                        <td class="tableBox">&nbsp;4254&nbsp;</td>
                    </tr>
                    <tr>
                        <td class="textTable">&nbsp;8&nbsp;</td>
                        <td class="tableBox">&nbsp;instruction 3&nbsp;</td>
                    </tr>
                    <tr>
                        <td class="textTable">&nbsp;12&nbsp;</td>
                        <td class="tableBox">&nbsp;instruction 4&nbsp;</td>
                    </tr>
                    <tr>
                        <td class="textTable">&nbsp;...&nbsp;</td>
                        <td class="tableBox">&nbsp;...&nbsp;</td>
                    </tr>
                </table>
                <br>
                <p>
                    Alright, let's talk about I/O (Input/Output).<br>
                    How can we do I/O in MIPS?<br>
                    We have special memory address that lie outside of our "real" memory space, and treat those addresses as the location of our I/O devices.<br>
                    <br>
                    So for us, <code>0xFFFF0004</code> is our input device.<br>
                    <code>lw</code> when used of this address receives 1 byte of our destination register.<br>
                    <br>
                    To write, we use <code>0xFFFF000C</code> as the address of our output device.<br>
                    USe <code>sw $t, i($s)</code> on this address, to put the lowest order byte of your source register, interpreted as an ASCII character to the screen.<br>
                    <br>
                    If you had 65 in one register, and 65+2<sup>24</sup> in another , and printed both - they would both print 'A'.<br>
                    <br>
                    Example: Print out everything you read from input, only stop when you see the ASCII character for ESC.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;lis&nbsp;&nbsp;$1<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0xffff0004&nbsp;&nbsp;&nbsp;&nbsp;; Input address<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;lis&nbsp;&nbsp;$2<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0xffff000c&nbsp;&nbsp;&nbsp;&nbsp;; Output address<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;addi $3, $0, 0x1b&nbsp;&nbsp;&nbsp;; ESC char in ASCII<br>
                        <span class="cline">06&nbsp;&nbsp;</span>loop:<br>
                        <span class="cline">07&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;lw&nbsp;&nbsp;&nbsp;$4, 0($1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Read char from input<br>
                        <span class="cline">08&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;sw&nbsp;&nbsp;&nbsp;$4, 0($2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Print that char back to output<br>
                        <span class="cline">09&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;bne&nbsp;&nbsp;$3, $4, loop&nbsp;&nbsp;&nbsp;; Repeat if ESC not entered<br>
                        <span class="cline">10&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;jr&nbsp;&nbsp;&nbsp;$31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Finish<br>
                    </code></pre>
                </span>
                <br>
                <p>
                    Let's look at storing data in a program as a string and iterating that string: "Hello World"<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;lis&nbsp;&nbsp;$1<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0xffff000c<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;lis&nbsp;&nbsp;$2<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word helloWorld&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Replaced by assembler with address of label<br>
                        <span class="cline">05&nbsp;&nbsp;</span>loop:<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;lw&nbsp;&nbsp;&nbsp;$3, 0($2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Load address character at address stored in $2<br>
                        <span class="cline">07&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;beq&nbsp;&nbsp;$3, $0, end&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; If we read NUL char we are done.<br>
                        <span class="cline">08&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;sw&nbsp;&nbsp;&nbsp;$3, 0($1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Print that character.<br>
                        <span class="cline">09&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;addi $2, $2, 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Point $2 at next char in string.<br>
                        <span class="cline">10&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;beq&nbsp;&nbsp;$0, $0, loop<br>
                        <span class="cline">11&nbsp;&nbsp;</span>end:<br>
                        <span class="cline">12&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;jr&nbsp;&nbsp;&nbsp;$31<br>
                        <span class="cline">13&nbsp;&nbsp;</span>helloWorld:<br>
                        <span class="cline">14&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0x48<br>
                        <span class="cline">15&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0x65<br>
                        <span class="cline">16&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0x6c<br>
                        <span class="cline">17&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0x6c<br>
                        <span class="cline">18&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0x6f<br>
                        <span class="cline">19&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0x20<br>
                        <span class="cline">20&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0x57<br>
                        <span class="cline">21&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0x6f<br>
                        <span class="cline">22&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0x72<br>
                        <span class="cline">23&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0x6c<br>
                        <span class="cline">24&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0x64<br>
                        <span class="cline">25&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0x21<br>
                        <span class="cline">26&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0x0a<br>
                        <span class="cline">27&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0x00<br>
                    </code></pre>
                </span>
                <br>
                <b>Subroutines</b>
                <ul>
                    <li>equivalent to our high level functions</li>
                    <li>
                        makes assembly programming debugging easier
                        <ul>
                            <li>break up our problem into smaller subproblems</li>
                        </ul>
                    </li>
                    <li>can be reusable, callable from anywhere!</li>
                </ul>
                <br>
                <p>What do we need to make these work?<br></p>
                <ul>
                    <li>
                        How to call/return execution from a subroutine?
                        <ul>
                            <li>call is easy; we're always jumping to the same location to run the subroutine (static)</li>
                            <li>called subroutine must return execution to whatever part of the program called it (dynamic)</li>
                        </ul>
                    </li>
                    <li>What about passing arguments and returning values?</li>
                </ul>
                <br>
                <p>
                    We already know how to call a subroutine (jump to its label).<br>
                    So how to return execution?<br>
                    If we want dynamic return, we need to know 2 things:<br>
                </p>
                <ul>
                    <li>
                        need to store the address of where to return execution, so the subroutine can jump back to that address
                        <ul>
                            <li>we must store <code>$pc + 4</code> for our return address</li>
                        </ul>
                    </li>
                    <li>
                        jump to the subroutine
                        <ul>
                            <li>luckily, we have an instruction to do just this : <code>jal srLabel ; jump and link</code></li>
                            <li>store the next instruction to execute in <code>$31</code> (next instruction to execute after source register is done</li>
                        </ul>
                    </li>
                    <li>
                        then, jump to srLabel
                        <ul>
                            <li>but we have still got some problems</li>
                            <li>we must be able to store register 31's value before overwriting it or we lose the previous return address</li>
                        </ul>
                    </li>
                    <li>
                        Where to store? Another register? NO!
                        <ul>
                            <li>limited (only 32) and valuable</li>
                            <li>registers are not dynamic - ops that use them are not</li>
                            <li>subroutine might overwrite that register</li>
                        </ul>
                    </li>
                </ul>
                <p>
                    Solution: STACK!!!<br>
                    Finally, we can talk about stack.<br>
                    But what is stack? Stack is just a last in first out (LIFO) data structure.<br>
                </p>
            </div>
            <hr>
            
            <div class="lec7">
                <h3>Lecture 7 - 25/01/2018</h3>
                <hr>
                <p>
                    Problem: We need to store the value of our return address register somewhere and so the value won't be overwritten.<br>
                    Solution: Use the stack.<br>
                    <br>
                    <span class="key">Stack</span>
                    It is a last-in first-out (LIFO) data structure.<br>
                    <br>
                    Example:
                </p>
                <img src="./image/cs230/lec7/7_1.png">
                <br>
                <p>
                    Stacks are a very convenient way of representing/using our memory.<br>
                    Convention: Stack grows up from the bottom of memory (as opposed to our program that went down from the top, address 0).<br>
                    Normally, in MIPS register 29, is the stack pointer register.<br>
                    In our emulator, the stack pointer is in register 30.<br>
                    <br>
                    How to use the stack via the stack pointer?<br>
                    If we want to store something, we must "make room" on the stack by making the stack pointer further away from the bottom of memory however many bytes we need.<br>
                    This is achieved by decrementing.<br>
                    <br>
                    How much must we decrement the stack pointer by to store one register?<br>
                    We must decrement by 4.<br>
                    <br>
                    To store return address on stack, or any other register's value for that matter:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>addi $30, $30, -<br>
                        <span class="cline">02&nbsp;&nbsp;</span>sw&nbsp;&nbsp;&nbsp;$31, 0($30)<br>
                    </code></pre>
                </span>
                <img src="./image/cs230/lec7/7_2.png">
                <p>
                    The value of $31 at the time it was stored.<br>
                    <br>
                    To restore a value from the stack:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>lw&nbsp;&nbsp;&nbsp;$31, 0($30)<br>
                        <span class="cline">02&nbsp;&nbsp;</span>addi $30, $30, 4<br>
                    </code></pre>
                </span>
                <p>
                    Now we know how to dynamically return from a subroutine without losing our return address.<br>
                    So generally to call a subroutine...<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>addi&nbsp;&nbsp;$30, $30, -4<br>
                        <span class="cline">02&nbsp;&nbsp;</span>sw&nbsp;&nbsp;&nbsp;&nbsp;$31, 0($30)<br>
                        <span class="cline">03&nbsp;&nbsp;</span>jal&nbsp;&nbsp;&nbsp;srLabel<br>
                        <span class="cline">04&nbsp;&nbsp;</span>lw&nbsp;&nbsp;&nbsp;&nbsp;$31, 0($30)<br>
                        <span class="cline">05&nbsp;&nbsp;</span>addi&nbsp;&nbsp;$30, $30, 4<br>
                    </code></pre>
                </span>
                <br>
                <p>
                    How to pass values into subroutine as arguments and our as return values?<br>
                    Specific Register Conventions:<br>
                </p>
                <ul>
                    <li>$2 and $3: return values</li>
                    <li>$4 to $7: arguments</li>
                    <li>$8 to $15, $24, $25: unsaved temporaries</li>
                    <li>$16 to $23: saved temporaries</li>
                    <li>rest are special uses</li>
                </ul>
                <p>
                    If you need more than 2 return values or 3 arguments - use the stack!<br>
                    <br>
                    <span class="key">Unsaved Temporaries</span> mean that these registers are <u>NOT</u> preserved when a subroutine is ran.<br>
                    If you are going to call a subroutine and want to keep these values, you MUST save them (this is the caller's job to save), move them to saved temporaries, OR push to stack before call.<br>
                    <br>
                    <span class="key">Saved Temporaries</span> are guaranteed to be preserved across a call, so when a subroutine returns you are promised to still have those values.<br>
                    It is the store register's job (or the caller's job) to save these registers.<br>
                    <br>
                    Let's put it all together in a case study.<br>
                    We will use <code>a2q5.asm</code> from assignment 5 as our case study.<br>
                    Assume we need to print an array of integers separated by commas.<br>
                    We need to break up into 2 tasks...<br>
                </p>
                <ul>
                    <li>
                        printing an integer
                        <ul>
                            <li>need to print each digit in order</li>
                            <li>print a minus sign in front if it its negative</li>
                        </ul>
                    </li>
                    <li>iterating an array printing each element in it</li>
                </ul>
                <p>
                    To figure out digits, repeatedly divide by 10 and look at remainder.<br>
                    Example: <span class="math">2542 / 10 = 254 .. 2</span><br>
                    <br>
                    Do we print that digit as soon as we read it?<br>
                    No, then we will print the string reversal of the number.<br>
                    We need to store digits as we discover them, then print them in the reverse order of discovery!<br>
                    Push them onto stack, them pop them off and print them.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>printInt:<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;; $4 is the int to print<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;add&nbsp;&nbsp;&nbsp;$11, $0, $0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; init $11 to 0<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;add&nbsp;&nbsp;&nbsp;$12, $4, $0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; init $12 to our number<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;addi&nbsp;&nbsp;$13, $0, 10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; init $13 to 10<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;lis&nbsp;&nbsp;&nbsp;$10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; setup $10 as printer<br>
                        <span class="cline">07&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;.word 0xFFFF000C<br>
                        <span class="cline">08&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;slt&nbsp;&nbsp;&nbsp;$8,&nbsp;&nbsp;$4, $0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; check if negative number<br>
                        <span class="cline">09&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;beq&nbsp;&nbsp;&nbsp;$8,&nbsp;&nbsp;$0, pushLoop ; if positive just start loop<br>
                        <span class="cline">10&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;sub&nbsp;&nbsp;&nbsp;$12, $0, $4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; convert to positive<br>
                        <span class="cline">11&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;addi&nbsp;&nbsp;$9,&nbsp;&nbsp;$0, 45&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; load 45, ascii -<br>
                        <span class="cline">12&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;sw&nbsp;&nbsp;&nbsp;&nbsp;$9,&nbsp;&nbsp;0($10)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; print minus sign<br>
                        <span class="cline">13&nbsp;&nbsp;</span>pushLoop:<br>
                        <span class="cline">14&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;divu&nbsp;&nbsp;$12, $13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; divide current number by 10<br>
                        <span class="cline">15&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;mfhi&nbsp;&nbsp;$14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; copy remainder into $14<br>
                        <span class="cline">16&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;mflo&nbsp;&nbsp;$12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; update current number to quotient<br>
                        <span class="cline">17&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;addi&nbsp;&nbsp;$11, $11, 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; increment number characters<br>
                        <span class="cline">18&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;addi&nbsp;&nbsp;$30, $30, -4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; make space on stack<br>
                        <span class="cline">19&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;sw&nbsp;&nbsp;&nbsp;&nbsp;$14, 0($30)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; store digit on stack<br>
                        <span class="cline">20&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;bne&nbsp;&nbsp;&nbsp;$12, $0, pushLoop ; keep going it not at 0<br>
                        <span class="cline">21&nbsp;&nbsp;</span>popLoop:<br>
                        <span class="cline">22&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;lw&nbsp;&nbsp;&nbsp;&nbsp;$9,&nbsp;&nbsp;0($30)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; load current digit to print<br>
                        <span class="cline">23&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;addi&nbsp;&nbsp;$9,&nbsp;&nbsp;$9,&nbsp;&nbsp;48&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; set to ASCII value for that digit<br>
                        <span class="cline">24&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;sw&nbsp;&nbsp;&nbsp;&nbsp;$9,&nbsp;&nbsp;0($10)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; print the digit<br>
                        <span class="cline">25&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;addi&nbsp;&nbsp;$30, $30, 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; pop off stack <br>
                        <span class="cline">26&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;addi&nbsp;&nbsp;$11, $11, -1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; decrement count of digits<br>
                        <span class="cline">27&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;bne&nbsp;&nbsp;&nbsp;$11, $0,&nbsp;&nbsp;popLoop ; keep going if not done<br>
                        <span class="cline">28&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;jr&nbsp;&nbsp;&nbsp;&nbsp;$31<br>
                    </code></pre>
                </span>
                <p>
                    So now we can print integers!<br>
                    Let's use that to print our array!<br>
                    <br>
                    There's lots of ways these subroutines could be improved.<br>
                    For example, in <code>pLoop</code> from <code>a2q5.asm</code>, we don't actually need to back up all those registers.<br>
                    We could just initialize before use - not at start.<br>
                    Example: the comma character and the space character<br>
                    We don't need to use that many resisters - we can reuse registers in ways that make sense.<br>
                </p>
            </div>
            <hr>
            
            <div class="lec8">
                <h3>Lecture 8 - 30/01/2018</h3>
                <hr>
                <p>
                    Assignment 2 due this Friday (2<sup>nd</sup> February, 2018) at 5pm!<br>
                    Midterm is next week, Thursday 8<sup>th</sup> February, 2018!<br>
                </p>
                <br>
                <b>Questions from last lecture?</b>
                <p>
                    The stack - controlled (used) through a pointer (a memory address) to the current location of the stack.<br>
                    Our stack pointer is in <code>$30</code>.<br>
                    Stack starts at the BOTTOM (END) of our memory and "grows up" towards the start.<br>
                </p>
                <br>
                <img src="./image/cs230/lec8/8_1.png">
                <p>
                    Note that we can't store store anything in the end of memory - that would go outside the memory space!<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>addi $30, $30, -4<br>
                    </code></pre>
                </span>
                <img src="./image/cs230/lec8/8_2.png">
                <br><br>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>; assume $1 is 0xFB<br>
                        <span class="cline">02&nbsp;&nbsp;</span>sw $1, 0($30)<br>
                    </code></pre>
                </span>
                <img src="./image/cs230/lec8/8_3.png">
                <br><br>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>addi $30, $30, -8<br>
                    </code></pre>
                </span>
                <img src="./image/cs230/lec8/8_4.png">
                <br><br>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>; assume $2 is 0x81, $3 is 0xABC<br>
                        <span class="cline">02&nbsp;&nbsp;</span>sw $2, 0($30)<br>
                        <span class="cline">03&nbsp;&nbsp;</span>sw $3, 4($30)<br>
                    </code></pre>
                </span>
                <img src="./image/cs230/lec8/8_5.png">
                <br><br>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>addi $1, $0, 0xABD ; now $1 is 0xABD<br>
                        <span class="cline">02&nbsp;&nbsp;</span>addi $2, $0, 0xEE&nbsp; ; now $2 is 0xEE<br>
                        <span class="cline">03&nbsp;&nbsp;</span>addi $3, $0, 0xCC&nbsp; ; now $3 is 0xCC<br>
                        <span class="cline">04&nbsp;&nbsp;</span>lw&nbsp;&nbsp; $2, 0($30) &nbsp;&nbsp;&nbsp;; $2 is back to 0x81<br>
                    </code></pre>
                </span>
                <img src="./image/cs230/lec8/8_6.png">
                <br><br>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>addi $30, $30, 4<br>
                    </code></pre>
                </span>
                <img src="./image/cs230/lec8/8_7.png">
                <p>
                    Note that even the value <code>0x81</code> is popped, it still exists in memory until we overwrite something into the memory.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>lw &nbsp;$3, &nbsp;0($30)<br>
                        <span class="cline">02&nbsp;&nbsp;</span>lw &nbsp;$1, &nbsp;4($30)<br>
                        <span class="cline">03&nbsp;&nbsp;</span>; now $3 is 0xABC and $1 is 0xFB<br>
                        <span class="cline">04&nbsp;&nbsp;</span>add $30, $30, 8<br>
                    </code></pre>
                </span>
                <img src="./image/cs230/lec8/8_8.png">
                <br><br>
                <b>Why bother learning assembly?</b>
                <ul>
                    <li>Gain and understanding of what a program actually is (sequence of instructions)</li>
                    <li>Understand how our high level languages can be interpreted by a computer</li>
                    <li>Gain an appreciation for which high level constructs are slower (take more instructions)</li>
                    <li>
                        Understand high level concepts better
                        <ul>
                            <li>example: How is data actually represented?</li>
                        </ul>
                    </li>
                </ul>	
                <br>
                <b>Machine Internals and Performance</b>
                <p>
                    Computers are constructed with a <u>CLOCK</u> that determines the speed at which instructions are done.<br>
                    Basically, it is a metronome for the computer - it keeps time for operations and achieves by sending an alternating signal of high/low voltage (in time).<br>
                </p>
                <img src="./image/cs230/lec8/8_9.png">
                <p>
                    Electric signal propagates pretty fast.<br>
                </p>
                <ul>
                    <li>Not infinitely fast, physical constraints</li>
                    <li>Gate delay, time it takes for a signal to enter a gate and result exit the gate (at a steady state)</li>
                </ul>

                <p>
                    Clock Period (Cycle Time)<br>: Duration in seconds of a cycle<br>
                    Clock Frequency (Clock Rate)<br>: Cycles per second (1/cycle time) in Hz (hertz)<br>
                    <br>
                    Example: clock period of <span class="math">250ps = 250(10<sup>12</sup>) s/cycle</span>.<br>
                    Note: ps is picoseconds, a.k.a <span class="math">10<sup>-12</sup></span>.<br>
                    What is our clock rate?<br>
                </p>
                <table class="math">
                    <tr>
                        <td>&nbsp;1 / 250(10<sup>-12</sup>)</td>
                        <td>&nbsp;= 10<sup>12</sup> / 250</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= 4(10<sup>9</sup>)</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= 4 GHz</td>
                    </tr>
                </table>
                <p>
                    Our cycles are used to "time" operations.<br>
                </p>
                <br>
                <b>Single Cycle Execution</b>
                <ul>
                    <li>Execute one instruction per cycle</li>
                    <li>
                        Fixed cycle time equal to the time it takes for our slowest instruction
                        <ul>
                            <li>add v.s. multiply</li>
                            <li>memory instructions (slow)</li>
                        </ul>
                    </li>
                    <li>If we want our common cases to be fast - then single cycle execution is not a great choice.</li>
                </ul>
                <br>
                <b>Measuring Performance</b>
                <p>Time</p>
                <ul>
                    <li>
                        Time to execute program (short as possible is goal!) - different ways of measuring this:
                        <ul>
                            <li>
                                Elapsed Time (total response time): total real time it takes the program to execute from an outside perspective<br>
                                It includes wait times (waiting for a resource like memory or hard dist), waiting for input, idle time.<br>
                            </li>
                        </ul>
                    </li>
                    <li>
                        CPU Time is how much time your program actually spends processing instructions and quite often CPU time is less than Elapsed time.<br> 
                    </li>
                </ul>
                <ul>
                    <li>Latency - time to execute one instruction</li>
                    <li>Throughput - number of instructions executed per unit of time</li>
                </ul>
                <b>Metrics of a Program/Hardware Combo</b>
                <ul>
                    <li>Cycles Per Instruction (PCI) - determined by the CPU hardware, probable for different instructions to take different number of cycles</li>
                    <li>Instruction count (IC) - the number of instructions in a program. Affected by primarily the program itself, the instruction set itself (e.g. <code>slt</code> and <code>bne</code> v.s. "branch is less than", the compiler (how much does it optimizes)</li>
                </ul>
                <p>
                    Number of clock cycles for a program: <span class="math">IC &sdot; CPI</span><br>
                    <span class="math">CPU Time = IC &sdot; CPI &sdot; cycleTime</span><br>
                    <br>
                    Example:<br>
                    Computer A has a cycle time 250ps and CPI is 2.0.<br>
                    Computer B has a cycle time 500ps and CPI is 1.2.<br>
                    Both of them use same instruction set, running the same program. Which is faster?<br>
                    <br>
                    <span class="math">CPU TIME<sub>A</sub> = IC &sdot; 20 &sdot; 250ps = IC &sdot; 500ps</span><br>
                    <span class="math">CPU TIME<sub>B</sub> = IC &sdot; 1.2 &sdot; 500ps = IC &sdot; 600ps</span><br>
                    <br>
                    So computer A is faster - how much faster?<br>
                    <span class="math">CPU TIME<sub>B</sub> / CPU TIME<sub>A</sub> = 600ps / 500ps = 1.2</span><br><br>
                    Computer A is 1.2 times faster than computer B.<br>
                    <br>
                    Example: 3 different types of instructions, each takes a different number of cycles, 2 programs X and Y.<br>
                </p>
                <table class="textTable">
                    <tr>
                        <th>I-type</th>
                        <th>A</th>
                        <th>B</th>
                        <th>C</th>
                    </tr>
                    <tr>
                        <td>CPI</td>
                        <td>1</td>
                        <td>2</td>
                        <td>4</td>
                    </tr>
                    <tr>
                        <td>IC<sub>x</sub></td>
                        <td>1</td>
                        <td>1</td>
                        <td>3</td>
                    </tr>
                    <tr>
                        <td>IC<sub>Y</sub></td>
                        <td>2</td>
                        <td>4</td>
                        <td>1</td>
                    </tr>
                </table>
                <p>
                    What is the weighted average CPI for programs X and Y?<br>
                </p>
                <table class="math">
                    <tr>
                        <td>&nbsp;CPI<sub>X</sub></td>
                        <td>&nbsp;= numbers of cycles / numbers of instructions</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= 1 &sdot; 1+2 &sdot; 1+4 &sdot; 3 / (1+1+3)</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= 15 / 5</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= 3.0</td>
                    </tr>
                </table>
                <br>
                <table class="math">
                    <tr>
                        <td>&nbsp;CPI<sub>Y</sub></td>
                        <td>&nbsp;= numbers of cycles / numbers of instructions</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= 1 &sdot; 2+2 &sdot; 4+4 &sdot; 1 / (2+5+1)</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= 14 / 7</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>&nbsp;= 2.0</td>
                    </tr>
                </table>
                <br>
                <p>
                    So program Y is using less cycles per instruction than X since it's using quicker instructions.<br>
                    <br>
                    In summary, we can calculate CPU time required for some program as<br>
                    <span class="math">CPUtime = IC &sdot; CPI &sdot; cycleTime = IC &sdot; CPI &sdot; (1/clockRate)</span><br>
                    We can try to reduce CPU time by...<br>
                </p>
                <ul>
                    <li>using less instructions</li>
                    <li>Reduce our CPI time</li>
                    <li>Faster clock (over-clocking)</li>
                </ul>
                <p>
                    Tradeoffs to all of these - we have other ways to increase performance.<br>
                </p>
                <br>
                <b>Pipelining</b>
                <p>
                    The idea behind pipelining is to use all your resources as much possible, not have resources sit waiting.<br>
                    A completely unpipelined task will do each task in sequence waiting for completion before starting the next.<br>
                    A pipelined version will do multiple tasks in parallel, so long as there is no reason why it cannot. (The resource required is not available, or its not ready)<br>
                    <br>
                    The best real life analogy for pipelining is laundry. We have 4 tasks (wash, dry, fold, put away) and 3 resources (washer, dryer, manual labour).<br>
                </p>
                <p>
                    In the pipelined version, we don't wait for one load to be completely finished (folded and put away) before starting the next load.<br>
                    So our pipelined version is faster, by making sure our resources in use as often as possible.<br>
                    In reality, it's not this clean , e.g. we have might have hang dry (take labour resource), can't fold and put away at same time.<br>
                    <br>
                    Under pipelining, can I wash one article of clothing faster than without pipelining?<br>
                    Pipelining does not affect LATENCY; it only affects throughput.<br>
                    <br>
                    In MIPS, we break up our execution into 5 steps, each step takes one cycle, and all 5 can be done in the same cycle (they use different resources). So in theory, we could have 5 instructions currently executing in any one cycle (under ideal conditions).<br>
                    <br>
                    Let's talk about our stages of execution.<br>
                </p>
                <ol>
                    <li>
                        Instruction Fetch (IF)
                        <ul>
                            <li>load instruction from memory into the CPU</li>
                            <li>load from the address in <code>$PC</code></li>
                        </ul>
                    </li>
                    <li>
                        Instruction Decode (ID)
                        <ul>
                            <li>Determine which instruction this is and what registers it is using (decode the bits of the instruction)</li>
                            <li>Read the values from the corresponding registers into the ALU (takes place in the second half of cycle)</li>
                            <li>Also determine if it is a branch instruction</li>
                        </ul>
                    </li>
                    <li>
                        Execute (EX)
                        <ul>
                            <li>Do the operation indicated by the instruction (done in the ALU)</li>
                            <li>For <code>add</code> do addition</li>
                            <li>For <code>mult</code> do multiplication</li>
                            <li>For  <code>lw/sw</code> compute the address  <code>$s + i</code>, etc.</li>
                        </ul>
                    </li>
                </ol>
            </div>
            <hr>
            
            <div class="lec9">
                <h3>Lecture 9 - 01/02/2018</h3>
                <hr>
                <b>Five Stages of MIPS Execution Pipeline</b>
                <ol>
                    <li>
                        Instruction Fetch (IF)
                        <ul>
                            <li>load the instruction from memory into CPU</li>
                            <li>load from address in <code>$PC</code> (program counter register)</li>
                        </ul>
                    </li>
                    <li>
                        Instruction Decode (ID)
                        <ul>
                            <li>determine which instruction this is (decoding the bits of the instruction</li>
                            <li>read the values from the corresponding registers into the ALU (takes place in the second half of the cycle)</li>
                            <li>also, determine if a branch is taken (extra hardware)</li>
                        </ul>
                    </li>
                    <li>
                        Execute (EX)
                        <ul>
                            <li>do the operation the instruction says to do (done in ALU)</li>
                            <li>for <code>add</code>, do the addition</li>
                            <li>for <code>mult</code>, do the multiplication</li>
                            <li>for <code>sw/lw</code>, compute the address <code>$w + i</code></li>
                        </ul>
                    </li>
                    <li>
                        Memory Address (MEM)
                        <ul>
                            <li>accessing memory</li>
                            <li>only used for <code>lw/sw</code> instructions</li>
                        </ul>
                    </li>
                    <li>
                        Write Back (WB)
                        <ul>
                            <li>write results into the destination register</li>
                            <li>this happens in the first half of the clock cycle</li>
                        </ul>
                    </li>
                </ol>
                <br>
                <p>
                    Let's look at what stages of execution.<br>
                    Some of our different instructions use and how long they take.<br>
                </p>
                <table class="textTable">
                    <tr>
                        <th>instruction Class</th>
                        <th>IF</th>
                        <th>ID</th>
                        <th>EX</th>
                        <th>MEM</th>
                        <th>WB</th>
                        <th>Total</th>
                    </tr>
                    <tr>
                        <td><code>lw</code> (load word)</td>
                        <td>200ps</td>
                        <td>100ps</td>
                        <td>200ps</td>
                        <td>200ps</td>
                        <td>100ps</td>
                        <td>800ps</td>
                    </tr>
                    <tr>
                        <td><code>sw</code> (store word)</td>
                        <td>200ps</td>
                        <td>100ps</td>
                        <td>200ps</td>
                        <td>200ps</td>
                        <td>-</td>
                        <td>700ps</td>
                    </tr>
                    <tr>
                        <td>R-Format</td>
                        <td>200ps</td>
                        <td>100ps</td>
                        <td>200ps</td>
                        <td>-</td>
                        <td>100ps</td>
                        <td>600ps</td>
                    </tr>
                    <tr>
                        <td>Branch</td>
                        <td>200ps</td>
                        <td>100ps</td>
                        <td>200ps (jump to)</td>
                        <td>-</td>
                        <td>-</td>
                        <td>500ps</td>
                    </tr>
                </table>
                <br>
                <p>
                    What is the actual speedup gained from pipelining?<br>
                    Under perfect conditions with all stages balanced (take the same time), then the speedup is equal to the number of stages.<br>
                    <br>
                    Of course, if the stages aren't balanced (or we don't have perfect conditions), then the speedup is less.<br>
                    <br>
                    In our example, we experienced a speedup <span class="math"> 800ps / 200ps = 4 times as fast</span><br>
                    <br>
                    Example:<br>
                </p>
                <table class="textTable">
                    <tr>
                        <th></th>
                        <th>cycle</th>
                        <th>1</th>
                        <th>2</th>
                        <th>3</th>
                        <th>4</th>
                        <th>5</th>
                        <th>6</th>
                    </tr>
                    <tr>
                        <td>(1)</td>
                        <td><code>addi $8, $0, 2</code></td>
                        <td>IF</td>
                        <td>ID</td>
                        <td>EX</td>
                        <td><del>MEM</del></td>
                        <td>WB</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>(2)</td>
                        <td><code>sub $9, $9, $10</code></td>
                        <td></td>
                        <td>IF</td>
                        <td>ID</td>
                        <td>EX</td>
                        <td><del>MEM</del></td>
                        <td>WB</td>
                    </tr>
                </table>
                <br>
                <p>
                    Note that MEM does nothing in our example, so we just crossed it out.<br>
                    <br>
                    Question: What if in our example above, instruction (2) was instead <code>sub $9, $8, $10</code>?<br>
                </p>
                <br>
                <b>Pipeline Hazards</b>
                <p>
                    <span class="key">Hazard</span>: a condition which blocks the flow of the pipeline<br>
                </p>
                <ul>
                    <li>instructions are (often) not completely independent</li>
                    <li>
                        we have 3 types of Hazards:
                        <ol>
                            <li>Data Hazard</li>
                            <li>Control Hazard</li>
                            <li>Structural Hazard</li>
                        </ol>
                    </li>
                </ul>
                <br>
                <p>
                    A <span class="key">data hazard</span> is when data that is required for the execution of an instruction is not available yet. This is the problem we have above if we changed the subtract instruction to read from <code>$8</code>.<br>
                </p>
                <table class="textTable">
                    <tr>
                        <th></th>
                        <th>1</th>
                        <th>2</th>
                        <th>3</th>
                        <th>4</th>
                        <th colspan="2">5</th>
                        <th>6</th>
                        <th>7</th>
                        <th>8</th>
                    </tr>
                    <tr>
                        <td><code>add $8, $9, $10</code></td>
                        <td>IF</td>
                        <td>ID</td>
                        <td>EX</td>
                        <td>MEM</td>
                        <td class="borderRightDashed">WB</td>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td><code>add $11, $8, $2</code></td>
                        <td></td>
                        <td>IF</td>
                        <td>-</td>
                        <td>-</td>
                        <td class="borderRightDashed"></td>
                        <td>ID</td>
                        <td>EX</td>
                        <td>MUM</td>
                        <td>WB</td>
                    </tr>
                </table>
                <br>
                <p>
                    Note that the two <code>-</code>s in row 3 are stalls (do nothing).<br>
                    <br>
                    This is an example of data hazard; it is called a "Read After Write" or "RAW" hazard.<br>
                    <br>
                    Example:<br>
                </p>
                <table class="textTable">
                    <tr>
                        <th></th>
                        <th>1</th>
                        <th>2</th>
                        <th>3</th>
                        <th>4</th>
                        <th>5</th>
                        <th>6</th>
                    </tr>
                        <td><code>add $8, $9, $10</code></td>
                        <td>IF</td>
                        <td>ID</td>
                        <td>EX</td>
                        <td>MEM</td>
                        <td>WB</td>
                        <td></td>
                    <tr>
                    </tr>
                    <tr>
                        <td><code>slt $8, $12, $13</code></td>
                        <td></td>
                        <td>IF</td>
                        <td>ID</td>
                        <td>EX</td>
                        <td>MEM</td>
                        <td>WB</td>
                    </tr>
                </table>
                <br>
                <p>
                    This is not a pipeline hazard.<br>
                    This iteration is called "write after write".<br>
                    <br>
                    In our first example, we had to delay the ID phase of instruction 2 until instruction had written back its result into <code>$8</code>; the data was not ready yet. We could do IF for instruction 2 in cycle 5, because ID reads the values from the source registers in the second half of the cycle, while WB is written them in the first half.<br>
                </p>
                <br>
                <p>
                    <span class="key">Control Hazards</span> are when we don't know which instruction we should execute next. Most simple example is a branch we don't know if the branch is taken or not, so we don't know if we should execute the immediately following instruction or the one the branch would jump us to.<br>
                    To mitigate this problem extra hardware is put in so that result of the branch condition can be determined in the ID phase (mentioned above).<br>
                    <br>
                    It is still not perfect though.<br>
                    <br>
                    Example:<br>
                </p>
                <table class="textTable">
                    <tr>
                        <th></th>
                        <th>1</th>
                        <th>2</th>
                        <th>3</th>
                        <th>4</th>
                        <th>5</th>
                        <th>6</th>
                        <th>7</th>
                        <th>8</th>
                    </tr>
                    <tr>
                        <td><code>add $8, $9, $10</code></td>
                        <td>IF</td>
                        <td>ID</td>
                        <td>EX</td>
                        <td>MEM</td>
                        <td>WB</td>
                        <td></td>
                        <td></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td><code>beq $11, $12, label</code></td>
                        <td></td>
                        <td>IF</td>
                        <td>ID</td>
                        <td>EX</td>
                        <td>MEM</td>
                        <td>WB</td>
                        <td></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td><code>sub $14, $0, $13</code></td>
                        <td></td>
                        <td></td>
                        <td>-</td>
                        <td>IF</td>
                        <td>ID</td>
                        <td>EX</td>
                        <td>MEM</td>
                        <td>WB</td>
                    </tr>
                </table>
                <br>
                <p>
                    Note that we don't know if the <code>sub</code> instruction is the real next instruction, so we put <code>-</code> in row 4 column 3.<br>
                    <br>
                    Also, for row 4 column 4 <code>IF</code>, ID of branch determined branch condition was false, we can now execute this instruction.<br>
                    <br>
                    Only had to stall for 1 cycle sine extra hardware allowed branch conditions to be evaluated in ID phase.<br>
                    <br>
                    It is still had to stall though...<br>
                </p>
                <br>
                <p>
                    A <span class="key">structural hazard</span> occurs when two or more instructions need the same resource at the same time.<br>
                    <br>
                    Most common example is when the IF stage of one instruction needs to access the same memory as the MEM stage of another instruction. Or, not even the same memory but asking the memory resource for memory values maybe it can only process one request at a time.<br>
                    <br>
                    For now, we'll assume memory is fast enough to do both in one cycle.<br>
                </p>
                <br>
                <b>Solving Hazards</b>
                <p>
                    <span class="class">Forwarding</span>: send data from an intermediate pipeline stage directly to another stage. (Instead of writing result back to register and waiting to read from that register send data directly to next pipeline.)<br>
                    <br>
                    Example with data forwarding:<br>
                </p>
                <table class="textTable">
                    <tr>
                        <th></th>
                        <th>1</th>
                        <th>2</th>
                        <th>3</th>
                        <th>4</th>
                        <th>5</th>
                        <th>6</th>
                    </tr>
                    <tr>
                        <td><code>add $8, $9, $10</code></td>
                        <td>IF</td>
                        <td>ID</td>
                        <td>EX</td>
                        <td>MEM</td>
                        <td>WB</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td><code>add $11, <u>$8</u>, $12</code></td>
                        <td></td>
                        <td>IF</td>
                        <td><u>ID</u></td>
                        <td>EX</td>
                        <td>MEM</td>
                        <td>WB</td>
                    </tr>
                </table>
                <br>
                <p>
                    The data was forwarded directly from the EX phase of instruction 1 to the EX phase of instruction 2 in the next cycle.<br>
                    <br>
                    This takes extra hardware. Thus, with forwarding:<br>
                </p>
                <ul>
                    <li>saved two stall cycles in this example</li>
                    <li>implementing forwarding increase hardware complexity</li>
                    <li>we can't always avoid stalls by forwarding; if the value isn't ready in time we can't forward backward in the time</li>
                </ul>
                <br>
                <p>
                    Example: Loading into a register immediately before usage load-use data hazard.
                </p>
                <table class="textTable">
                    <tr>
                        <th></th>
                        <th>1</th>
                        <th>2</th>
                        <th>3</th>
                        <th>4</th>
                        <th>5</th>
                        <th>6</th>
                        <th>7</th>
                    </tr>
                    <tr>
                        <td><code>lw $16, 0($8)</code></td>
                        <td>IF</td>
                        <td>ID</td>
                        <td>EX (0 + $8)</td>
                        <td>MEM</td>
                        <td>WB</td>
                        <td></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td><code>sub $9, $16, $10</code></td>
                        <td></td>
                        <td>IF</td>
                        <td>ID</td>
                        <td>- (stall)</td>
                        <td>EX</td>
                        <td>MEM</td>
                        <td>WB</td>
                    </tr>
                </table>
                <br>
                <p>
                    Note that the <code>MEM</code> in row 2 is linked to the <code>EX</code> in row 3. (That is, MEM &harr; EX.)<br>
                    <br>
                    Load from memory the value is not ready until it is actually loaded from MEM at the end of MEM stage. Hence we still must stall. We did save one stall cycle from the case without forwarding.<br>
                </p>
                <br>
                <b>Branch Prediction</b>
                <p>
                    It tries to predict to the best of our abilities the outcome of the branch condition. Then, we're only wasted time if the guess was wrong.<br>
                </p>
                <ul>
                    <li>
                        (1) Simple Branch Prediction
                        <ul>
                            <li>predict the branch is never taken</li>
                            <li>fetch the instruction (no delay)</li>
                            <li>stall only when we guessed wrong</li>
                        </ul>
                    </li>
                </ul>
                <p>
                    Example: Wrong Prediction<br>
                </p>
                <table class="textTable">
                    <tr>
                        <th></th>
                        <th>1</th>
                        <th>2</th>
                        <th>3</th>
                        <th>4</th>
                        <th>5</th>
                    </tr>
                    <tr>
                        <td><code>beq $0, $0, label</code></td>
                        <td>IF</td>
                        <td>ID</td>
                        <td>EX</td>
                        <td>MEM</td>
                        <td>WB</td>
                    </tr>
                    <tr>
                        <td><code>next instruction</code></td>
                        <td></td>
                        <td>IF</td>
                        <td colspan="3">---(flush)---&rarr;</td>
                    </tr>
                </table>
                <br>
                <p>
                    If we guessed correctly, no stall!<br>
                </p>
                <table class="textTable">
                    <tr>
                        <th></th>
                        <th>1</th>
                        <th>2</th>
                        <th>3</th>
                        <th>4</th>
                        <th>5</th>
                        <th>6</th>
                    </tr>
                    <tr>
                        <td><code>bne $0, $0, label</code></td>
                        <td>IF</td>
                        <td>ID</td>
                        <td>EX</td>
                        <td>MEM</td>
                        <td>WB</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td><code>next instruction</code></td>
                        <td></td>
                        <td>IF</td>
                        <td>ID</td>
                        <td>EX</td>
                        <td>MEM</td>
                        <td>WB</td>
                    </tr>
                </table>
                <br>
                <ul>
                    <li>
                        (2) Static Branch Prediction
                        <ul>
                            <li>base predictions on typical branch behaviour</li>
                        </ul>
                    </li>
                </ul>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>loop:<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;...<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;bne $4, $0, loop<br>
                    </code></pre>
                </span>
                <p>
                    Backwards branches are often used for loops; loops are often ran more than once, so always guess the branch will be taken for backwards branches.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>&nbsp;&nbsp;beq $3, $0, else<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;...<br>
                        <span class="cline">03&nbsp;&nbsp;</span>else:<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;...<br>
                    </code></pre>
                </span>
                <p>
                    Forward branches are often used for if statement and if-else statement. Guess that forward loops are not taken, if you have an <code>if, elif, elif, ..., else</code> chain, all but one are NOT taken!<br>
                </p>
            </div>
            <hr>
               
            <div class="lec10">

                <h3>Lecture 10 - 06/02/2018</h3>
                <hr>

                <b>Midterm Review</b>
                <p>
                    Office hours for this week: Today 16:30 - 18:30 <br>
                    Normally Thursdays 16:30 - 18:30<br>
                    <br>
                    Midterm Thursday 16:30 - 18:20, check seating online (link posted on Piazza if you don't know where to look)<br>
                    <br>
                    You don't have to know the proof of Boolean algebra. (But you do need to put those Boolean algebra on you cheat sheet!)<br>
                    <br>
                    You won't ask for doing math with 32-bit fixed width. (32-bit is too big and you only have 2 hours to write your midterm!)<br>
                    <br>
                    You won't ask for drawing a terrible circuit diagram.<br>
                    <br>
                    By the way, we still have class before the midterm on this Thursday!<br>
                </p>
            </div>
            <hr>
            
            <p>
                Find a typo or mistake? Feel free to contact me and I will correct it as soon as possible.
            </p>
            <hr>
            
            <div class="footer">
                <p>Thanks For Coming Here. - Calvin Li</p>
                <a href = "mailto: ck6li@edu.uwaterloo.ca" target = "_blank;">
                    <i class = "fa fa-envelope-square"></i>
                </a>
                <a href = "https://www.linkedin.com/in/vertckli/" target = "_blank;">
                    <i class = "fa fa-linkedin-square"></i>
                </a>       
                <a href = "https://www.instagram.com/vert_arts/" target = "_blank;">
                    <i class="fa fa-instagram"></i>
                </a>
                <a href = "https://github.com/vertli" target = "_blank;">
                    <i class="fa fa-github-square"></i>
                </a>
                <br>
                <p><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" /></a> This work by <a xmlns:cc="http://creativecommons.org/ns#" href="https://vertli.github.io/" property="cc:attributionName" rel="cc:attributionURL">Chun Kit (Calvin) Li</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>. Chun Kit (Calvin) Li &copy; 2017 - 2018</p>
                <br>
            </div>
            
        </div>
        
        <script src="https://code.jquery.com/jquery-2.1.4.js"></script>
        <script src="./bootstrap-3.3.7-dist/js/bootstrap.js"></script>
        
    </body>
    
</html>