<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    <title>CS230|Calvin Li</title>
    <link rel="stylesheet" href="./bootstrap-3.3.7-dist/css/bootstrap.css">
    <link rel="stylesheet" href="./css/style.css">
    <link rel="stylesheet" href="./css/newNote.css">
    <!-- Code Display use -->
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?skin=desert"></script>
    <link rel="stylesheet" href="./css/skin.css">
    <!-- Google Fonts: Noto Sans-->
    <link href="https://fonts.googleapis.com/css?family=Noto+Sans:400,700" rel="stylesheet">
    <!-- stylesheet found from w3school. (icon use)-->
    <link rel = "stylesheet" href = "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  </head>
    
  <body>
        
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#topNavbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="./index.html">Calvin Li</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="topNavbar">
          <ul class="nav navbar-nav">
            <li><a href="./doc/NewResume_CKLI.pdf" target="_blank;">Résumé</a></li>
          </ul>
          <ul class="nav navbar-nav navbar-right">
            <li><a href="./about.html">About</a></li>
            <li><a href="./projects.html">Projects</a></li>
            <li class="courseNote">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Course Notes<span class="caret"></span></a>
              <ul class="dropdown-menu">
                <li><a href="./cs230.html">CS 230</a></li>
                <li><a href="./cs246.html">CS 246</a></li>
              </ul>
            </li>
          </ul>
        </div><!-- /.navbar-collapse -->
      </div><!-- /.container-fluid -->
    </nav>
        
    <br><br><br>
        
    <div class="container">     
    <br>
      <table class="header">
        <tr>
          <td colspan="100%">
            <h1 class="title">CS 230 - Introduction to Computers and Computer Systems</h1>
          </td>
        </tr>
        <tr>
          <th colspan="5%">Instructor:</th>
          <td colspan="95%">Rob Hackman</td>
        </tr>
        <tr>
          <th colspan="5%">Office:</th>
          <td colspan="95%">DC2551A</td>
        </tr>
        <tr>
          <th colspan="5%">Email:</th>
          <td colspan="95%"><a href = "mailto: r2hackma@uwaterloo.ca" target = "_blank;">r2hackma@uwaterloo.ca</a></td>
        </tr>
        <tr>
          <th colspan="5%">Website:</th>
          <td colspan="95%">
            <a href="https://www.student.cs.uwaterloo.ca/~cs230/" target="_blank;">https://www.student.cs.uwaterloo.ca/~cs230/</a>
          </td>
        </tr>
        <tr>
          <th colspan="5%">Note:</th>
          <td>All program codes in this course notes are provided by Prof. Hackman during class.</td>
        </tr>
      </table>
      <hr>
      
      <section id="lec1">
        <h3>Lecture 1 - 04/01/2018</h3>
        <hr>
        <h4>Goals</h4>
        <ul>
          <li>
            Overview of computer systems
            <ul>
              <li>What is a computer?</li>
              <li>How do they work?</li>
              <li>Why are they designed as such?</li>
            </ul>
          </li>
          <li>Work from the bottom-up</li>
          <li>Understand the basic challenges and techniques</li>
        </ul>

        <p>
          In this course, we will use Linux.<br>
          The student environment is <a href="https://student.cs.uwaterloo.ca" target="_blank;">student.cs.uwaterloo.ca</a>.
        </p>
        <p>
          We will be learning MIPS; we have MIPS assembler and emulator for you to use on the student environments.
        </p>
        <br>
        <h4>Overview</h4>
        <ul>
          <li>Arithmetic, Hardware, Data</li>
          <li>Assembly Language</li>
          <li>Machine Internals</li>
          <li>Build and Execute</li>
          <li>Multiprocessing</li>
          <li>Operating System (if time allow)</li>
        </ul>
        <br>
        <h4>What is a computer?</h4>
        <p>
          Computer is a bunch of logic gates and circuitry; it is designed to complete a task.<br>
          Let's think of a old stop watch. It can only has functionality to start timing, stop timing, and maybe hold up to 3 lap times.<br>
          Technically this is a computer; this is not what we think of today.<br>
          What differentiates it?<br>
          If we want to reprogram our stop watch, we must change the circuitry.<br>
        </p>
        <p>
          The modern day personal computer is re-programmable without having to change the circuitry.<br>
          It is called "Von Neumann Architecture".<br>
        </p>
        <br>
        <h4>Von Neumann Architecture</h4>
        <p>
          Von Neumann Architecture has the circuitry redefine a set of "instructions" that can be executed by it.<br>
          Basic arithmetic done by the arithmetic logic unit (ALU); it has a "control unit" (CU) that runs control instructions.<br>
          These two together define our central processing unit (CPU).<br>
        </p>
        <p>
          Von Neumann Architecture has memory that can be accessed at any location within (random access memory - RAM).<br>
          This is called our memory unit (MU).<br>
          We can read/write to our memory unit.<br>
          Memory unit stores both instructions AND data.<br>
          <br>
          Lastly, we require inputer/output devices.<br>
        </p>
        <img src="./image/cs230/lec1/1_1.PNG" align="left" class="imgRightMargin">
        <p>
          Von Neumann Architecture is still the basis for almost all computers today.<br>
          (Strict Von Neumann Architecture says that data and program must be stored on the same memory unit; this is not always the case Harvard Architecture.)
        </p>
        <p>
          How does a Von Neumann Machine run a program?<br>
          It keeps track of what address in memory and the next instruction to execute is located.
        </p>
        <p>
          How does our CPU store the address of the next instruction if memory is separate?<br>
          Special circuits called "registors" which are parts of the CPU.<br>
          They are memory in that they simply store sets of \(1\)'s and \(0\)'s for the CPU to interpret and use.
        </p>
        <p>
          Registors begin part of the CPU are can be read from/written to very fast.
        </p>
        <p>
          A special registor called "program counter" or "PC registor" which stores the location of the next instruction.
        </p>
        <p>What types of instructions exist? Lots!</p>
        <ul>
          <li>Data transfer/read/write to memory</li>
          <li>Do some arithmetic</li>
          <li>Branch (change the address stored in the program counter)</li>
        </ul>
        <p>
          There are many different hardwares exist: AMD, Intel, Qualcomm, ...<br>
          They have their own instruction sets!
        </p>
        <p>
          You can write a C program and execute both on a machine with an AMP's CPU and an Intel's CPU.<br>
          But how does this work if instruction sets are different?<br>
          The instructions are preset for the circuitry.<br>
          Instructions are great for circuitry; they're only ones and zeros!<br>
          Machine Code or Machine Language is the name for the code of a program written in base instructions. It is not friendly to human.
        </p>
        <p>
          We can move one step up to Assembly Language.<br>
          Assembly instructions have a direct mapping to one or more machine code instructions.<br>
          We have a tool called "assembler" that takes assembly language programs and generates a machine program which the hardware can execute.
        </p>
        <p>
          Moving one step further away from the machine, there are intermediate languages (essentially a tool for compilers).
        </p>
        <p>Lastly, we have high level programming languages: C, C++, Java, ...</p>
        <p>
          C/C++ are compiled programming languages.<br>
          We have a program called "compiler" that takes our C program as input and generates an assembly version of that program.<br>
          Most compilers also assemble that program immediately to produce a final machine code program (binary file) which your hardware can execute!<br>
          Hence, programs are stored in memory; data is also stored in memory.<br>
          Memory is just \(1\)'s or \(0\)'s.<br>
          So, what does memory actually look like and how do we interpret it?
        </p>
        <br>
        <h4>Number Representation</h4>
        <p>What does the number \(924\) mean?</p>
        <ul>
          <li>Nine hundred forty two</li>
          <li>Nine hundreds, Four tens, Two ones</li>
          <li>\(9 \times 10^2 + 4 \times 10^1 + 2 \times 10^0\)</li>
        </ul>
        <p>
          This is the radix \(10\) representation of the number \(942\).<br>
          Radix is also know as "base".
        </p>
        <p>
          This continues each digit we add to the left we simply increment the exponent.<br>
          This is why our number system is called "base \(10\)" or "decimal".
        </p>
        <p>
          Radix representation allows us to write natural numbers using a finite alphabet.<br>
          In base \(r\), we have \(r\) characters in \(r\) alphabets (digits).<br>
          Typically, \(0, 1, 2, \dots, r-2, r-1\).
        </p>
        <p>
          For any length \(n\) word in base \(r\), we have 
          \(d_{n-1}, d_{n-2}, \dots, d_{2}, d_{1}, d_{0}\).
        </p>
        <p>
          We can "calculate" or rather compue the decimal value number by doing 
          \(\displaystyle\sum_{i=0}^{n-1} d_i r^i\)<br>
          You can use any number for your base.
        </p>
        <ul>
          <li>base \(2\): binary [\(0\), \(1\)] (also call bit)</li>
          <li>base \(8\): octal [\(0, 7\)]</li>
          <li>base \(10\): decimal [\(0, 9\)]</li>
          <li>base \(16\): hexadecimal [\(0, 1, \dots , 9, A, B, C, D, E, F\)]</li>
        </ul>
        <p>Humans mostly use base \(10\) - why? We have \(10\) fingers!</p>
        <p>
          Computer use base \(2\), binary. Why?<br>
          Electrical simplicity: On/Off, High/Low, \(1\)/\(0\)
        </p>
        <p>
          Example: Consider the number \(1440_{sept}\) or \(1440_{7}\).<br>
          \(0 \times 7^{0} + 4 \times 7^{1} + 4 \times 7^{2} + 1 \times 7^{3} = 567_{10}\)
        </p>
        <p>
          Example: Consider the number \(A32_{Hex}\), a.k.a. \(A32_{16}\).<br>
          \(2 \times 16^{0} + 3 \times 16^{1} + A \times 16^{2} = 1050_{10}\)
        </p>
        <p>
          Same conversion for any base to base 10 (binary included) - just use that summation formula.<br>
          But what if we have a decimal number and we want to figure out the binary representation?<br>
          We need to use repeated divisions!
        </p>
        <ul>
          <li>Step 1: divide the number by 2, the remainder is the current digit (starting at digit 0)</li>
          <li>Step 2: take the quotient and repeat until the quotient is 0</li>
        </ul>
        <p>
          Example: Convert \(4242_{10}\) to hexadecimal.<br>
          \begin{align*}
            4242 / 16 &amp;= \phantom{0}265 \dots 2 &amp; \leftarrow 2 \text{ is the least significant digit}\\
            265 / 16 &amp;= \phantom{00}16 \dots 9 &amp; \\
            16 / 16 &amp;= \phantom{000}1 \dots 0 &amp; \\
            1 / 16 &amp;= \phantom{000}0 \dots 1 &amp; \\
            \text{So } 4242_{10} &amp;= 1092_{16}
          \end{align*}
        </p>
        <p>
          Example: Convert \(187_{10}\) to binary.<br>
          \begin{align*}
            187 / 2 &amp;= 93 \dots 1\\
            93 / 2 &amp;= 46 \dots 1\\
            46 / 2 &amp;= 23 \dots 0\\
            23 / 2 &amp;= 11 \dots 1\\
            11 / 2 &amp;= \phantom{0}5 \dots 1\\
            5 / 2 &amp;= \phantom{0}2 \dots 1\\
            2 / 2 &amp;= \phantom{0}1 \dots 0\\
            1 / 2 &amp;= \phantom{0}0 \dots 1\\
          \text{So } 187_{10} &amp;= 101\:1101_{2}
          \end{align*}
        </p>
        <p>
          It took a LOT of divisions to get our binary number, and it was only \(187\)!<br>
          Luckily, it is trivial to convert between both octal/hexadecimal and binary.<br>
          So we can always first convert to hexadecimal, the nto binary.
        </p>
        <p>
          To convert hexadecimal to binary, simply look at sets of \(4\) bits.
        </p>
        <table class="cs">
          <tr>
            <th>Binary</th>
            <th>Hexadecimal</th>
          </tr>
          <tr>
            <td>0000</td>
            <td>0</td>
          </tr>
          <tr>
            <td>0001</td>
            <td>1</td>
          </tr>
          <tr>
            <td>0010</td>
            <td>2</td>
          </tr>
          <tr>
            <td>0011</td>
            <td>3</td>
          </tr>
          <tr>
              <td>0100</td>
              <td>4</td>
          </tr>
          <tr>
            <td>0101</td>
            <td>5</td>
          </tr>
          <tr>
            <td>0110</td>
            <td>6</td>
          </tr>
          <tr>
            <td>0111</td>
            <td>7</td>
          </tr>
          <tr>
            <td>1000</td>
            <td>8</td>
          </tr>
          <tr>
            <td>1010</td>
            <td>A</td>
          </tr>
          <tr>
            <td>1011</td>
            <td>B</td>
          </tr>
          <tr>
            <td>1100</td>
            <td>C</td>
          </tr>
          <tr>
            <td>1101</td>
            <td>D</td>
          </tr>
          <tr>
            <td>1110</td>
            <td>E</td>
          </tr>
          <tr>
            <td>1111</td>
            <td>F</td>
          </tr>
        </table>
        <br>
        <p>So \(1101\:0111_{2} = D7_{16}\)</p>
      </section>
      <hr>

      <section id="lec2">
        <h3>Lecture 2 - 09/01/2018</h3>
        <hr>
        <h4>Binary Addition</h4>
        <p>
          Last time, we had learnt how to convert decimal number to binary number.<br>
          But how do we add two binary numbers together?<br>
          Binary addition is actually simple textbook addition.
        </p>
        <p>
          However, we have a problem.<br>
          Unlike writing on paper or doing math in our head, our circuit can only have a certain number of bits (for example, \(32\)-bit).<br>
          This is what we call <strong>fixed-width representation</strong>; in fixed-width representation, we have a problem called <strong>overflow</strong>.
        </p>
        <p>
          Consider a \(4\)-bit fixed-width representation.
          \begin{align*}
            12_{10} + 7_{10} &amp;= 1100_{2} + 0111_{2}\\
                             &amp;= 1\:0011_{2}
          \end{align*}
        </p>
        <p>
            Our answer has \(5\) bits, but we are working with a \(4\)-bit fixed-width representation!<br>
            This is an overflow!<br>
            Hence, we have to omit the leftest bit and so, we can get a 4-bit answer.
            \begin{align*}
              12_{10} + 7_{10} &amp;= 1100_{2} + 0111_{2}\\
                               &amp;= 0011_{2}\\
                               &amp;= 3_{10}
            \end{align*}
        </p>
        <p>
          So \(12_{10} + 7_{10} = 7_{10}\) in a \(4\)-bits fixed-width representation.
        </p>
        <p>
          We can calculate the result directly modulo \(16\) (so the largest number we can represent with \(4\) bits is \(15\).
        </p>
        <br>
        <h4>Binary Subtraction</h4>
        <p>
          Now we know that the addition works with binary, but human is lazy - we don't want to design a subtraction circuit!<br>
          Subtraction is simply adding a negative number, or adding the negation of the number you are subtracting.
        </p>
        <p>
          Naive Approach:<br>
          If we have n-bit to store our number, use n-1 bits to just store a regular old binary natural number (magnitude) and use the remaining bit to denote the sign.<br>
          This is the <strong>sign and magnitude approach</strong>.<br>
          But this approach has two problems!
        </p>
        <p>
          The first problem is we have two zeros here!<br>
          For example, in \(4\)-bit fixed-width representation...<br>
          \(1000_{2} = -0_{10}\) where the first bit \(1\) is the sign bit \(-\) and the rest of the bits is the magnitude of \(0_{10}\).<br>
          \(0000_{2} = +0_{10}\) where the first bit \(0\) is the sign bit \(+\) and the rest of the bits is the magnitude of \(0_{10}\).
        </p>
        <p>
          The second problem is addition does not work here!<br>
          For example,
          \begin{align*}
            3_{10} - 1_{10} &amp;= 3_{10} + (-1_{10})\\
                            &amp;= 0011_{2} + 1001_{2}\\
                            &amp;= 1100_{2}\\
                            &amp;= -4_{10}
          \end{align*}
          Clearly, we know that \(3 - 1 \neq -4\).
        </p>
        <p>
          Attempt 2: <strong>\(1\)'s Complement</strong><br>
          To represent negation of a binary number, simply invert(flip) the bits - \(0\)'s become \(1\)'s and \(1\)'s become \(0\)'s.<br>
          Addition is possible here; the trick is to add any carry over to the sum.<br>
          Example: \(7_{10} - 4_{10}\) in \(4\)-bit fixed-width representation.<br>
          We know that \(4_{10} = 0100_{2}\), then flip it and we will get \(1011_{2}\) to represent \(-4\).
          \begin{align*}
            7_{10} - 4_{10} &amp;= 7_{10} + (-4_{10})\\
                            &amp;= 0111_{2} + 1011_{2}\\
                            &amp;= 1\:0010_{2}\\
                            &amp;= 0010_{2} + 1_{2} \text{ // add the carry over to the sum}\\
                            &amp;= 0011_{2}\\
                            &amp;= 3_{10}
          \end{align*}
        </p>
        <p>
          Wait... We still have two zeros here!<br>
          \(0000_{2} = +0_{10}\) and \(1111_{2} = -0_{10}\).<br>
          Also, this is not our same addition from before; we want to reuse the exact same circuit!
        </p>
        <p>
          Attempt 3: <strong>\(2\)'s Complement</strong><br>
          To negate a number, flip the bits, then add \(1\).<br>
          This will only give us one zero.
          \begin{align*}
            +0_{10} &amp;= \phantom{0\:}0000_{2} \text{ // work in 4-bit fixed-width representation}\\
                    &amp;= \phantom{0\:}1111_{2} \text{ // flip}\\
                    &amp;= 1\:0000_{2} \text{ // add 1 }\\
                    &amp;= \phantom{0\:}0000_{2} \text{ // remove the overflow bit}
          \end{align*}
        </p>
        <p>
          Example: \(7 - 4\) in \(4\)-bit fixed-width representation.<br>
          We know that \(4_{10} = 0100_{2}\), then flip it to get \(1011_{2}\) and add \(1\) to get \(1100_{2}\) which represents \(-4\).
          \begin{align*}
            7_{10} - 4_{10} &amp;= 7_{10} + (-4_{10})\\ 	
                            &amp;= 0111_{2} + 1100_{2}\\ 	
                            &amp;= 1\:0011_{2}\\	
                            &amp;= 0011_{2} \text{ // remove the overflow bit}\\
                            &amp;= 3_{10} 
          \end{align*}
        </p>
        <p>
          The \(2\)'s complement solves our problems and it works!<br>
          This is how all computers today represent negative integers.
        </p>
        <p>
          Beauty is in the eye of the beholder!<br>
          What does \(1011_{2}\) mean?<br>
          This could be \(11_{10}\)or \(-5_{10}\), it depends on how we choose to interpret it.<br>
          There are other ways to interpret these binary numbers; we will talk about later.
        </p>
        <br>
        <h4>Sign Extension</h4>
        <p>
          We were using \(4\)-bit fixed-width representation. If we wanted to move to other fixed-width representation (e.g. \(8\)-bit), fill the extra spaces on the left with 0's for any positive number, or 1's for any negative number.<br>
          For example...
        </p>
        <table class="cs">
          <tr>
            <th></th>
            <th>\(4\)-bit</th>
            <th>\(8\)-bit</th>
          </tr>
          <tr>
            <td>\(5_{10}\)</td>
            <td>\(0101_{2}\)</td>
            <td>\(0000\:0101_{2}\)</td>
          </tr>
          <tr>
            <td>\(-3_{10}\)</td>
            <td>\(1101_{2}\)</td>
            <td>\(1111\:1101_{2}\)</td>
          </tr>
        </table>
        <br>
        <h4>Range</h4>
        <p>
          For \(2\)'s complement, the range of \(n\)-bit fixed-width representation is \([-2^{n-1}, 2^{n-1} - 1]\).<br>
          For example, the range of \(4\)-bit fixed-width representation is \([-8, 7]\).<br>
        </p>
        <p>
          Range for unsigned integers is \([0, 2^{n} - 1]\).
        </p>
        <br>
        <h4>Shift Operations</h4>
        <p>
          We can shift a bit string right or left.<br>
          They are equivalent to division or multiplication by 2.<br>
          They are very fast machine instructions.<br>
          When right shifting a negative number, fill the "new" left positions with 1's; for positive number, fill with 0's.<br>
          For example...
          \begin{align*}
            \begin{array}{rll}
              &amp; \phantom{=}\:1101_{2} \ll 2 &amp;&amp; \text{ // shift the bit string } 1101_{2} \text{ left 2 positions}\\
              &amp;= 11\:0100_{2} &amp;&amp; \text{ // Overflow, omit the 2 leftest bits}\\
              &amp;= 0100_{2} &amp;&amp; \text{ // final answer}
            \end{array}
          \end{align*}
          \begin{align*}
            \begin{array}{rll}
              &amp; \phantom{=}\:0001_{2} \ll 2 &amp;&amp; \text{ // shift the bit string } 0001_{2} \text{ left 2 positions}\\
              &amp;= 00\:0100_{2} &amp;&amp; \text{ // Overflow, omit the 2 leftest bits}\\
              &amp;= 0100_{2} &amp;&amp; \text{ // final answer}
            \end{array}
          \end{align*}
        </p>
        <br>
        <h4>Binary Multiplication</h4>
        <p>
          Binary multiplication is same as textbook multiplication.<br>
          For example...
          \begin{align*}
            \def\doubleunderline#1{\underline{\underline{#1}}}
            \begin{array}{rll}
              1000_{2}\\
              \underline{\times \phantom{0000}1000_{2}}\\
              \phantom{0000}1000_{2}\\
              \phantom{00}10\:0000_{2}\\
              \underline{+ \phantom{0}100\:0000_{2}}\\
              \doubleunderline{110\:1000_{2}}
            \end{array}
          \end{align*}
        </p>
        <p>
            Binary multiplication is done by the processor as shift and add operators.<br>
            It can be easily parallelized.
        </p>
        <br>
        <h4>Binary Division</h4>
        <p>
          Again, it is same as textbook division.<br>
          For example...
          \begin{align*}
            \require{enclose}
            \def\doubleunderline#1{\underline{\underline{#1}}}
            \begin{array}{rll}
              1101_{2}\\
              1000_{2} \enclose{longdiv}{110\:1010_{2}}\kern-.2ex \\
              \underline{100\:0_{2}\phantom{000}}\\
              \phantom{0}10\:10_{2}\phantom{00}\\
              \underline{\phantom{0}10\:00_{2}\phantom{00}}\\
              \phantom{000}1010_{2}\\
              \underline{\phantom{000}1000_{2}}\\
              \doubleunderline{\phantom{00000}10_{2}}
            \end{array}
          \end{align*}
        </p>
        <p>
          Binary division is also done by shift and subtract.<br>
          But each result depends on the previous, division cannot be easily to parallelized.
        </p>
        <p>
          So, the duration of binary multiplication is shorter than the duration of binary division.
        </p>
        <br>
        <h4>Boolean Algebra</h4>
        <p>
          How does our computer actually implement binary addition, subtraction, multiplication, division and shifting?<br>
          How does it work with all these \(0\)'s and \(1\)'s?
        </p>
        <p>
          The basis of all our computer's circuits today comes from the work of a mathematician who died in 1864 - George Boole.<br>
          Boole's work is what we call <strong>Boolean algebra</strong> today.
        </p>
        <p>
          <strong>Boolean algebra</strong> is a specific branch of algebra dedicated to work with only values <strong>true</strong> and <strong>false</strong>.<br>
          The basic operators of Boolean algebra are <strong>AND</strong>, <strong>OR</strong>, <strong>NOT</strong>.<br>
          In computers, each of these "logic gates" can be created with a few transistors.
        </p>
        <br>
        <h4>OR operator</h4>
        <p>
          It is also called "disjunction".<br>
          It denotes as \(x \lor y\); it most closely relates to addition\((+)\) in regular algebra, so it can be denoted as \(x+y\).<br>
          \(x \lor y\) is true if either \(x\) or \(y\) is true, or both.
        </p>
        <table class="cs">
          <tr>
            <th>Logic gate OR for logic circuit diagram:</th>
            <th colspan="3">Truth Table<br>(\(0\) is false, \(1\) is true)</th>
          </tr>
          <tr>
            <td rowspan="5"><img src="./image/cs230/lec2/2_1.PNG"></td>
            <td>\(x\)</td>
            <td>\(y\)</td>
            <td>output</td>
          </tr>
          <tr>
            <td>\(0\)</td>
            <td>\(0\)</td>
            <td>\(0\)</td>
          </tr>
          <tr>
            <td>\(0\)</td>
            <td>\(1\)</td>
            <td>\(1\)</td>
          </tr>
          <tr>
            <td>\(1\)</td>
            <td>\(0\)</td>
            <td>\(1\)</td>
          </tr>
          <tr>
            <td>\(1\)</td>
            <td>\(1\)</td>
            <td>\(1\)</td>
          </tr>
        </table>
        <br>
        <h4>AND operator</h4>
        <p>
            It is also called "conjunction".<br>
            It denotes as \(x \land y\); it most closely relates to multiplication(\(*)\) in regular algebra, so it can be denoted as \(x*y\).<br>
            AND means both of \(x\) and \(y\) must be true!
        </p>
        <table class="cs">
          <tr>
            <th>Logic gate AND for logic circuit diagram:</th>
            <th colspan="3">Truth Table<br>(\(0\) is false, \(1\) is true)</th>
          </tr>
          <tr>
            <td rowspan="5"><img src="./image/cs230/lec2/2_2.PNG"></td>
            <td>\(x\)</td>
            <td>\(y\)</td>
            <td>output</td>
          </tr>
          <tr>
            <td>\(0\)</td>
            <td>\(0\)</td>
            <td>\(0\)</td>
          </tr>
          <tr>
            <td>\(0\)</td>
            <td>\(1\)</td>
            <td>\(0\)</td>
          </tr>
          <tr>
            <td>\(1\)</td>
            <td>\(0\)</td>
            <td>\(0\)</td>
          </tr>
          <tr>
            <td>\(1\)</td>
            <td>\(1\)</td>
            <td>\(1\)</td>
          </tr>
        </table>
        <br>
        <h4>NOT operator</h4>
        <p>
            It is also called "negation".<br>
            It denotes as \(\neg x\), \(\tilde{x}\), \(\text{~}x\) or \(!x\).<br>
            NOT means the opposite of \(x\).
        </p>
        <table class="cs">
          <tr>
            <th>Logic gate NOT for logic circuit diagram:</th>
            <th colspan="3">Truth Table<br>(\(0\) is false, \(1\) is true)</th>
          </tr>
          <tr>
            <td rowspan="3"><img src="./image/cs230/lec2/2_3.PNG"></td>
            <td>\(x\)</td>
            <td>output</td>
          </tr>
          <tr>
            <td>\(0\)</td>
            <td>\(1\)</td>
          </tr>
          <tr>
            <td>\(1\)</td>
            <td>\(0\)</td>
          </tr>
        </table>
        <br>
        <p>
          There also exists more specific gates that can be built from combinations of the above three operators.<br>
          But these are so common and helpful, we use them in our Boolean algebra.
        </p>
        <br>
        <h4>XOR operator</h4>
        <p>
            It is also called "exclusive or".<br>
            It denotes as \(x \oplus y\) or \(x \# y\).<br>
            It means "one or the other, but not both."
        </p>
        <table class="cs">
          <tr>
            <th>Logic gate XOR for logic circuit diagram:</th>
            <th colspan="3">Truth Table<br>(\(0\) is false, \(1\) is true)</th>
          </tr>
          <tr>
            <td rowspan="5"><img src="./image/cs230/lec2/2_4.PNG"></td>
            <td>\(x\)</td>
            <td>\(y\)</td>
            <td>output</td>
          </tr>
          <tr>
            <td>\(0\)</td>
            <td>\(0\)</td>
            <td>\(0\)</td>
          </tr>
          <tr>
            <td>\(0\)</td>
            <td>\(1\)</td>
            <td>\(1\)</td>
          </tr>
          <tr>
            <td>\(1\)</td>
            <td>\(0\)</td>
            <td>\(1\)</td>
          </tr>
          <tr>
            <td>\(1\)</td>
            <td>\(1\)</td>
            <td>\(0\)</td>
          </tr>
        </table>
        <br>
        <img src="./image/cs230/lec2/2_5.PNG" class="imgCentre">
        <br>
        <h4>NOR operator</h4>
        <p>
          It denotes as \(\neg (x \lor y)\) or \(x \downarrow y\).<br>
          It means "neither", aka "NOT OR".
        </p>
        <table class="cs">
          <tr>
            <th>Logic gate NOR for logic circuit diagram:</th>
            <th colspan="3">Truth Table<br>(\(0\) is false, \(1\) is true)</th>
          </tr>
          <tr>
            <td rowspan="5"><img src="./image/cs230/lec2/2_6.PNG"></td>
            <td>\(x\)</td>
            <td>\(y\)</td>
            <td>output</td>
          </tr>
          <tr>
            <td>\(0\)</td>
            <td>\(0\)</td>
            <td>\(1\)</td>
          </tr>
          <tr>
            <td>\(0\)</td>
            <td>\(1\)</td>
            <td>\(0\)</td>
          </tr>
          <tr>
            <td>\(1\)</td>
            <td>\(0\)</td>
            <td>\(0\)</td>
          </tr>
          <tr>
            <td>\(1\)</td>
            <td>\(1\)</td>
            <td>\(0\)</td>
          </tr>
        </table>
        <br>
        <h4>NAND operator</h4>
        <p>
          It denotes as \(\neg(x \land y)\) or \(x \uparrow y\).<br>
          It means "not both"; it is simply negation of AND.
        </p>
        <table class="cs">
          <tr>
            <th>Logic gate NOR for logic circuit diagram:</th>
            <th colspan="3">&nbsp;Truth Table<br>(\(0\) is false, \(1\) is true)&nbsp;</th>
          </tr>
          <tr>
            <td rowspan="5"><img src="./image/cs230/lec2/2_7.PNG"></td>
            <td>\(x\)</td>
            <td>\(y\)</td>
            <td>output</td>
          </tr>
          <tr>
            <td>\(0\)</td>
            <td>\(0\)</td>
            <td>\(1\)</td>
          </tr>
          <tr>
            <td>\(0\)</td>
            <td>\(1\)</td>
            <td>\(1\)</td>
          </tr>
          <tr>
            <td>\(1\)</td>
            <td>\(0\)</td>
            <td>\(1\)</td>
          </tr>
          <tr>
            <td>\(1\)</td>
            <td>\(1\)</td>
            <td>\(0\)</td>
          </tr>
        </table>
        <br>
        <p>
            Since this is Boolean algebra, we can combine these operators to form complex expression and of course, we have rules for how these operators write.
        </p>
        <table class="cs">
          <tr>
            <th>Identity</th>
            <th>Name</th>
          </tr>
          <tr>
            <td>\(\neg(\neg x) = x\)</td>
            <td>Double Negation</td>
          </tr>
          <tr>
            <td>\(x \land x = x\)</td>
            <td rowspan="2">Idempotent Law</td>
          </tr>
          <tr>
            <td>\(x \lor x = x\)</td>
          </tr>
          <tr>
            <td>\(x \land 1 = x\)</td>
            <td rowspan="2">Identity Law</td>
          </tr>
          <tr>
            <td>\(x \lor 0 = x\)</td>
          </tr>
          <tr>
            <td>\(x \land 0 = 0\)</td>
            <td rowspan="2">Domination Law</td>
          </tr>
          <tr>
            <td>\(x \lor 1 = 1\)</td>
          </tr>
          <tr>
            <td>\(x \land y = y \land x\)</td>
            <td rowspan="2">&nbsp;Commutative Law</td>
          </tr>
          <tr>
            <td>\(x \lor y = y \lor x\)</td>
          </tr>
        </table>
      </section>
      <hr>

      <section id="lec3">
        <h3>Lecture 3 - 11/01/2018</h3>
        <hr>
        <p>Example: Convert the following binary to decimal.</p>
        <table class="cs">
          <tr>
            <th>Binary</th>
            <th>Sign and Magnitude</th>
            <th>1's Complement</th>
            <th>2's Complement</th>
          </tr>
          <tr>
            <td>\(0000_2\)</td>
            <td>\(+0_{10}\)</td>
            <td>\(+0_{10}\)</td>
            <td>0_{10}\)</td>
          </tr>
          <tr>
            <td>\(0001_2\)</td>
            <td>\(+1_{10}\)</td>
            <td>\(+1_{10}\)</td>
            <td>\(1_{10}\)</td>
          </tr>
          <tr>
            <td>\(1000_2\)</td>
            <td>\(-0_{10}\)</td>
            <td>\(-7_{10}\)</td>
            <td>\(-8_{10}\)</td>
          </tr>
          <tr>
            <td>\(1001_2\)</td>
            <td>\(-1_{10}\)</td>
            <td>\(-6_{10}\)</td>
            <td>\(-7_{10}\)</td>
          </tr>
          <tr>
            <td>\(1011_2\)</td>
            <td>\(-3_{10}\)</td>
            <td>\(-4_{10}\)</td>
            <td>\(-5_{10}\)</td>
          </tr>
        </table>
        <br>
        <p>
          In human mind, to conver binary to decimal under \(2\)'s complement, we can use the following formula: \(-2^{n-1} + \displaystyle\sum_{i=0}^{n-2} 2^i \)
        </p>
        <p>
          For example: \(1001_{2}\)
          \begin{align*}
            1001_2 &amp;= -2^3 + 0 \times 2^2 + 0 \times 2^1 + 1 \times 2^0\\
                   &amp;= -8_{10} + 1_{10}\\
                   &amp;= -7_{10}
          \end{align*}
        </p>
        <br>
        <h4>Boolean Algebra</h4>
        <table class="cs">
          <tr>
            <th>Identity</th>
            <th>Name</th>
          </tr>
          <tr>
            <td> \(\neg (\neg x) = x\)</td>
            <td>Law of the Double Complement</td>
          </tr>
          <tr>
            <td>\(x \land x = x\)</td>
            <td rowspan="2">Idempotent Law</td>
          </tr>
          <tr>
            <td>\(x \lor x = x\)</td>
          </tr>
          <tr>
            <td>\(x \land 1 = x\)</td>
            <td rowspan="2">Identity Law</td>
          </tr>
          <tr>
            <td>\(x \lor 0 = x\)</td>
          </tr>
          <tr>
            <td>\(x \land 0 = 0\)</td>
            <td rowspan="2">Domination Law</td>
          </tr>
          <tr>
            <td>\(x \lor 1 = 1\)</td>
          </tr>
          <tr>
            <td>\(x \land y = y \land x\)</td>
            <td rowspan="2">&nbsp;Commutative Law</td>
          </tr>
          <tr>
              <td>\(x \lor y = y \lor x\)</td>
          </tr>
          <tr>
            <td>\(x \lor (y \lor z) = (x \lor y) \lor z\)</td>
            <td rowspan="2">Associative Law</td>
          </tr>
          <tr>
            <td>\(x \land (y \land z) = (x \land y) \land z\)</td>
          </tr>
          <tr>
            <td>\(x \lor (y \land z) = (x \lor y) \land (x \lor z)\)</td>
            <td rowspan="2">Distributive Law</td>
          </tr>
          <tr>
            <td>\(x \land (y \lor z) = (x \land y) \lor (x \land z)\)</td>
          </tr>
          <tr>
            <td>\(\neg (x \lor y) = (\neg x) \land ( \neg y)\)</td>
            <td rowspan="2">DeMorgan's Law</td>
          </tr>
          <tr>
            <td>\(\neg (x \land y) = (\neg x) \lor (\neg y)\)</td>
          </tr>
          <tr>
            <td>\(x \lor (x \land y) = x\)</td>
            <td rowspan="2">Absorption Law</td>
          </tr>
          <tr>
            <td>\(x \land (x \lor y) = x\)</td>
          </tr>
          <tr>
            <td>\(x \lor (\neg x) = 1\)</td>
            <td rowspan="2">Nonmonotone Law</td>
          </tr>
          <tr>
            <td>\(x \land (\neg x) = 0\)</td>
          </tr>
        </table>
        <br>
        <p>
          A Boolean expression represents a logic function.<br>
          A logic function can be represented also by a logic circuit diagram, or a truth table.<br>
          Example: \((x \lor y) \land (\neq x)\)
        </p>
        <table class="cs">
          <tr>
            <th>Logic gate NOR for logic circuit diagram:</th>
            <th colspan="5">Truth Table<br>(\(0\) is false, \(1\) is true)</th>
          </tr>
          <tr>
            <td rowspan="5"><img src="./image/cs230/lec3/3_1.png"></td>
            <td>\(x\)</td>
            <td>\(y\)</td>
            <td>\(x \lor y\)</td>
            <td>\(\neg x\)</td>
            <td>\((x \lor y) \land (\neg x)\)</td>
          </tr>
          <tr>
            <td>\(0\)</td>
            <td>\(0\)</td>
            <td>\(0\)</td>
            <td>\(1\)</td>
            <td>\(0\)</td>
          </tr>
          <tr>
            <td>\(0\)</td>
            <td>\(1\)</td>
            <td>\(1\)</td>
            <td>\(1\)</td>
            <td>\(1\)</td>
          </tr>
          <tr>
            <td>\(1\)</td>
            <td>\(0\)</td>
            <td>\(1\)</td>
            <td>\(0\)</td>
            <td>\(0\)</td>
          </tr>
          <tr>
            <td>\(1\)</td>
            <td>\(1\)</td>
            <td>\(1\)</td>
            <td>\(0\)</td>
            <td>\(0\)</td>
          </tr>
        </table>
        <br>
        <p>
          It is worth mentioning that our variables represent logical statements.<br>
          If you are ever confused about how to apply a law over a larger more complex expression, you can say "let \(p = (x \lor y \lor z)\)" and do your manipulations after subbing p into that expression, than resub back the real value to get the final result.
        </p>
        <p>
          Additionally, while drawing circuits, we can choose to draw an AND, OR, NAND, or NOR gate having an numbers of inputs.<br>
          This is easily replicated in redraw.
        </p>
        <table class="cs">
          <tr>
            <th>\(x \lor y \lor z\)</th>
            <th>\( x \land y \land z\)</th>
          </tr>
          <tr>
            <td><img src="./image/cs230/lec3/3_2.png"></td>
            <td><img src="./image/cs230/lec3/3_3.png"></td>
          </tr>
        </table>
        <br>
        <p>
          Now, we can draw logic gates and we know logic gates can be easily constructed with only a handful of circuit.<br>
          So, let's build a circuit to add two bits together.
        </p>
        <p>
          Example: \(1\)-column of Addition<br>
          We want sum (is there \(1\) remaining in this column after addition) and carry (do we need to carry a 1 to the next column).
        </p>
        <table class="cs">
          <tr>
            <td>\(sum = A \oplus B\)</td>
            <td rowspan="2"><img src="./image/cs230/lec3/3_4.png"></td>
          </tr>
          <tr>
            <td>\(carry = A \land B\)</td>
          </tr>
        </table>
        <br>
        <p>
          So all of that for one column of addition.<br>
          This circuit is called a <strong>Half-Adder</strong>.<br>
          The half-adder does not take into account the fact a carry bit may have come in from the previous column.
        </p>
        <table class="cs">
          <tr>
            <th>x</th>
            <th>y</th>
            <th>Carry<sub>in</sub></th>
            <th>Carry<sub>out</sub></th>
            <th>Sum</th>
          </tr>
          <tr>
            <td>0</td>
            <td>0</td>
            <td>0</td>
            <td>0</td>
            <td>0</td>
          </tr>
          <tr>
            <td>0</td>
            <td>0</td>
            <td>1</td>
            <td>0</td>
            <td>1</td>
          </tr>
          <tr>
            <td>0</td>
            <td>1</td>
            <td>0</td>
            <td>0</td>
            <td>1</td>
          </tr>
          <tr>
            <td>0</td>
            <td>1</td>
            <td>1</td>
            <td>1</td>
            <td>0</td>
          </tr>
          <tr>
            <td>1</td>
            <td>0</td>
            <td>0</td>
            <td>0</td>
            <td>1</td>
          </tr>
          <tr>
            <td>1</td>
            <td>0</td>
            <td>1</td>
            <td>1</td>
            <td>0</td>
          </tr>
          <tr>
            <td>1</td>
            <td>1</td>
            <td>0</td>
            <td>1</td>
            <td>0</td>
          </tr>
          <tr>
            <td>1</td>
            <td>1</td>
            <td>1</td>
            <td>1</td>
            <td>1</td>
          </tr>
        </table>
        <br>
        <p>How about <strong>full-adder</strong>?</p>
        <table class="cs">
          <tr>
            <td>\(sum = x \oplus y \oplus Carry_{in}\)</td>
            <td rowspan="2"><img src="./image/cs230/lec3/3_5.png"></td>
          </tr>
          <tr>
            <td>\(carry = (x \land y) \lor ((x \oplus y) \land Carry_{in})\)</td>
          </tr>
        </table>
        <br>
        <p>
          Take away if you can build a truth table or logical expression, you can build a circuit (and all other combos too).<br>
          So what about adding numbers with a width larger than 1?<br>
          Stick a bunch of full-adders together!
        </p>
        <img src="./image/cs230/lec3/3_6.png" class="imgCentre"><br>
        <p>
          Example:
          \begin{align*}
          \frac{
            \begin{matrix}
              &amp; _1 &amp; _1 &amp; _1 &amp; \\
              &amp; _{(x_3} &amp; _{x_2} &amp; _{x_1} &amp; _{x_0)} \\
              &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\
              &amp; _{(y_3} &amp; _{y_2} &amp; _{y_1} &amp; _{y_0)} \\
              + &amp; 0 &amp; 0 &amp; 1 &amp; 1
            \end{matrix}
          }{
            \begin{matrix}
              \phantom{=} &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
              &amp; _{(d_3} &amp; _{d_2} &amp; _{d_1} &amp; _{d_0)}
            \end{matrix}
          }
        \end{align*}
        </p>
        <p>
          But there is a problem: this is kind of slow!<br>
          The carry bit needs to propagate from each column to the next.<br>
          So, this is linear in number of bits.
        </p>
        <br>
        <h4>Carry-Lookahead Adder</h4>
        <p>
          This is faster than full adder.<br>
          It is more complex(larger) circuits to determine carry.<br>
          Trade-off is complexity and speed (example: power, cost, etc.).
        </p>
        <p>
          Now, we know how to represent integers and how basis operations work.<br>
          But what about other data types?<br>
          We know that a bit is the smallest piece of information representable - true or false.
        </p>
        <br>
        <h4>Byte</h4>
        <p>
          A byte today is \(8\) bits; it can easily be shown as two hexadecimal digits.
        </p>
        <p>
          A word is the size of instruction on the given architecture.<br>
          The common architectures for now are \(4\) bytes (\(32\) bits) and \(8\) bytes (\(64\) bits).
        </p>
        <p>
          Words can be ordered in different way.<br>
          What is the most significant byte?<br> This ordering is called <strong>Endianness</strong>.
        </p>
        <br>
        <h4>Endianness</h4>
        <p>
          Big endian which is most significant byte first descending.<br>
          Little endian which is least significant byte first asscending.
        </p>
        <p>
          If we want to represent the number \(0xDEADBEEF\) in one \(4\)-byte word, it looks like this.
          \begin{align*}
            \begin{array}
              \text{Big Endian: } &amp; 0xDE &amp; 0xAD &amp; 0xBE &amp; 0xEF \\
              &amp; \uparrow &amp; \uparrow &amp; \uparrow &amp; \uparrow \\
              &amp; 0x0010 &amp; 0x0020 &amp; 0x0030 &amp; 0x0040 \\
              &amp; \downarrow &amp; \downarrow &amp; \downarrow &amp; \downarrow \\
              \text{Little Endian: } &amp; 0xEF &amp; 0xBE &amp; 0xAD &amp; 0xDE
            \end{array}
          \end{align*}
        </p>
        <p>
            Endianness is important!<br>
            Think about two computers passing a file.<br>
            If one computer stores in big endian but the other stores in little endian, they will not understand the file is the same!
        </p>
        <p>
            Endianness is important in network area; the standard for networking is big endian.
        </p>
        <p>
            Okay, so these are bits and bytes.<br>
            But how do we store staff?
        </p>
        <br>
        <h4>Character</h4>
        <p>
          Character is letter!<br>
          There are two famous character encoding standard.
        </p>
        <p>
          The first one is <strong>ASCII</strong> (American Standard Code for Information Interchange).<br>
          In ASCII, 1 byte means 1 character.<br>
          The normal ASCII codes are using \([0, 127]\) and the extended ASCII codes are using \([128, 255]\).<br>
          For example, \([0, 31]\) is for special control characters (non-printable), \([48, 57]\) is for number \(0\) to \(9\), \([65, 90]\) is for alphabet \(A\) to \(Z\) and \([97,122]\) is for alphabet \(a\) to \(z\).
        </p>
        <p>
          But... ASCII does not include other languages!<br>
          So we have other standard called <strong>UTF-8</strong> (8-bit Unicode Transformation Format).<br>
          In UTF-8, we use 1 to 4 bytes to represent per character.<br>
          The 1 byte encoding is compatible as ASCII - characters that tend to occur more frequently store in 1 byte.
        </p>
        <br>
        <h4>String</h4>
        <p>
          String is just a collection or array of characters.<br>
          But how does the computer know the length of a string?<br>
          Commonly, a string is terminated with the special character <code>NULL(\0)</code>: \(0x00\).<br>
          For example, "Hello" in ASCII is \(0x48 \; 0x65 \; 0x6C \; 0x6c \; 0x6F \; 0x00\).
        </p>
      </section>
      <hr>

      <section id="lec4">
        <h3>Lecture 4 - 16/01/2018</h3>
        <hr>
        <h4>Real Numbers</h4>
        <p>
          What is real number? For example, \(1.15\) is real number.
        </p>
        <p>
          How does computer represent real numbers?<br>
          First of all, let's talk about the <strong>Scientific Notation</strong>.<br>
          For example, \(-3.24 \times 10^{56}\), and it is also called as <strong>Normalized Scientific Notation</strong>.
        </p>
        <p>
          <strong>Normalized Scientific Notation</strong>: one non-zero digit in front of the decimal point<br>
          For example, \(0.002 \times 10^{4}\) and \(56.123 \times 10^{8}\) are not normalized.
        </p>
        <p>
          How do we write a real number in binary with scientific notation?<br>
          For example, \(1.01_2 \cdot 2^1\) where the \(.\) after \(1\) and before \(0\) is called a binary point (radix point generally).<br>
          So what does \(1.01_2\) mean?<br>
          Before we answer this answer, we need to ask ourselves, what does \(1.01_{10}\) mean?
          \begin{align*}
            1.01_{10} = 1 \cdot 10^0 + 0 \cdot 10^{-1} + 1 \cdot 10^{-2}
          \end{align*}
          With the same idea, we have...
          \begin{align*}
            1.01_2 &amp;= 1 \cdot 2^0 + 0 \cdot 2^{-1} + 1 \cdot 2^{-2}\\
                   &amp;= 1 + \frac{1}{4}\\
                   &amp;= 1.25_{10}
          \end{align*}
        </p>
        <p>
          How do we represent real numbers in our machines?<br>
          We use what's called <strong>floating point number</strong>.<br>
          The reason it is called this name because it allow the binary point to "float" by changing the exponent.<br>
          The opposite would be fixed point.
        </p>
        <p>
          Floating point is of the form \(I.F \cdot B^E\) where...
        </p>
        <ul>
          <li>\(I\): Integer</li>
          <li>\(F\): Fractional</li>
          <li>\(B\): Base</li>
          <li>\(E\): Exponent</li>
          <li>\(I.F\): Significand (or "Mantissa")</li>
        </ul>
        <p>Our floats are always normalized, so \(I\) is always \(1\).</p>
        <ul>
          <li>left out of our representation is called "implicit/hidden point"</li>
        </ul>
        <p>
          The base in always \(2\) because we are in binary!<br>
          So these are the components of our floating point.
        </p>
        <p>
          How does float represent in a machine? the standard <strong>IEEE 754</strong>.<br>
          We have single precision 32 bits, double precision 64 bits.
        </p>
        <p>
          Single Precision Float: 32 bits
        </p>
        <img src="./image/cs230/lec4/4_1.png" class="imgCentre"><br>
        <p>
          We have 1 bit for the sign bit (green box), 8 bits for the exponent (red boxes) and the rest of the boxes (purple) are for the fractional.<br>
          Note that integer and base are not represented since base is 2 and integer is always 1 except for special subnormal numbers.
        </p>
        <p>
          Also, we need to know that the exponent bits do not represent exactly the exponent \(e\) in \(I.F \cdot B^e\). Why?<br>
          The standard uses a bias value, so the exponent bits represent an unsigned number and you subtract the bias from it.<br>
          Bias for single precision is \(127\).
        </p>
        <p>
          So to calculate the value \((-1)^5 \cdot (I.F) \cdot 2^{e-127}\), let's try calculating the decimal value of single precision float:
          \begin{align*}
            0 \: 10000100 \: 11000000000000000000000
          \end{align*}
          The first \(0\) is the sign bit.<br>
          Then, \(10000100\) are the exponent bits:
          \begin{align*}
            10000100 &amp;= 128 + 4 - bias\\
                     &amp;= 132 - 127\\
                     &amp;= 5
          \end{align*}
          The rest of the bits \(11000000000000000000000\) are the fractional bits where
          \begin{align*}
            1.11 &amp;= 1 + 2^{-1} + 2^{-2}\\
                 &amp;= 1 + 0.5 + 0.25\\ 
                 &amp;= 1.75
          \end{align*}
          So, we now have:
          \begin{align*}
            (-1)^S \cdot (I.F) \cdot 2^{e-127} &amp;= (-1)^0 \cdot (1.11) \cdot 2^5\\
                                               &amp;= 1 \cdot (1.75) \cdot 2^5\\
                                               &amp;=56.0
          \end{align*}
        </p>
        <p>
          Let's consider a simplified 8-bit representation for floats: 1 bit for sign bit, 3 bits for exponent (bias = 3) and 4 bits for fractional.<br>
          Note that bias is a choosing value, so you don't have to worry about it.
        </p>
        <p>
          Example: Express \(4.5\) in our simplified format.<br>
          Note that \(4_{10} = 100_{2}\) and \(0.5_{10} = \frac{1}{2}_{10} = 2^{-1} = 0.1_{2}\).<br>
          Thus, \(4.5_{10} = 100.1_{2}\).<br>
          Then we have \(100.1\cdot 2^0\) and normalise it, we get \(1.001 \cdot 2^2\).<br>
          Next, the exponent is \(e + bias = 2 + 3 = 5 = 101_2\) and sign bit is \(0\) since \(4.5\) is a positive number.<br>
          So, we get \(0 \: 101 \: 0010\) as our final answer, where \(0\) is the sign bit, \(101\) is the exponent bits and \(0010\) is the fractional bits.
        </p>
        <p>
          Arithmetic with floats is easy.<br>
          For addition, just set the exponents the same and add the significands (regular addition).
        </p>
        <p>
          Example: Add \(1.25\) and \(2.125\) in our simplified format.<br>
          Note that \(1.25 = 1.01 \cdot 2^0\).<br>
          So we know that \(F = 0100\), \(E = 0 + 3 = 3 = 011\) and \(S = 0\).<br>
          Thus, \(1.25_{10} = 0 \: 011 \: 0100^{2}\).<br>
          Also, \(2.125 = 1.0001 \cdot 2^1\).<br>
          So we know that \(F = 0001\), \(E = 1 + 3 = 4 = 100\) and \(S = 0\).<br>
          Thus, \(2.125_{10} = 0 \: 100 \: 0001_{2}\).
          \begin{align*}
            1.25 + 2.125 &amp;= 1.01 \cdot 2^0 + 1.0001 \cdot 2^1 \\
                         &amp;= 1.01 \cdot 2^0 + 10.001 \cdot 2^0 \\
                         &amp;= 11.011 \cdot 2^0 \\
                         &amp;= 1.1011 \cdot 2^1
          \end{align*}
        </p>
        <p>
          From the normalized scientific notation \(1.1011 \cdot 2^{1}\), we know that \(F = 1011\), \(E = 1 + 3 = 4 = 100\) and <\(S = 0\).<br>
          So our final answer is \(0 \: 100 \: 1011\).
        </p>
        <p>
          For multiplication, we add exponents, then multiply significands.<br>
          For example, \(1.5 \cdot 2.25\).<br>
          Note that \(1.5 = 0 \: 011 \: 100\) and \(2.25 = 0 \: 100 \: 0010\).
        </p>
        <p>
          Step 1 - Add Exponents:<br>
          \((E_{1.5} - bias) + (E_{2.25} - bias) = (011 - 011) + (100 - 011) = 1 = e\)<br>
          So \(E = 1 + 3 = 4 = 100_{2}\).
        </p>
        <p>
          Step 2 - Multiply Significands:
          \begin{align*}
            1.1000 \times 1.0010 &amp;= (1 \cdot 1.001) + (0.1 \cdot 1.001) \\
                                 &amp;= 1.001 + 0.1001 \\
                                 &amp;= 1.1011
          \end{align*}
        </p>
        <p>
          So our new fractional bits are \(1011\), new exponent bits are \(100\) and new sign bit is \(0\).<br>
          Therefore, \(1.5 \cdot 2.25 = 0 \: 100 \: 1011\).
        </p>
        <p>
          However, examining our simplified format we can see the problems that arise in floating point numbers.<br>
          The first problem is there exists infinite numbers between 0 and 1, but we cannot represent infinite numbers within 32 bits!<br>
          For example, consider \(15.25\) in our 8-bit system:<br>
          \(15.25 = 1111.01 \cdot 2^{0} = 1.11101 \cdot 2^{3}\)<br>
          We need 5 bits for the fraction but we only have 4 bits to use!<br>
          So we get an overflow, which is \(1.1110 \cdot 2^{3}\).<br>
          If we round up, we get \(15.5\); if we round down, we get \(15.0\).
        </p>
        <p>
          So overflow can happen; they get represented as <strong>inf</strong> (also occurs for divide by 0).
        </p>
        <p>For IEEE 754,</p>
        <table class="cs">
          <tr>
            <th>Exponent Bits</th>
            <th>Fractional Bits</th>
            <th>Value/Type</th>
          </tr>
          <tr>
            <td>0000 0000</td>
            <td>00...00</td>
            <td>0</td>
          </tr>
          <tr>
            <td>0000 0000</td>
            <td>non-zero</td>
            <td>subnormal</td>
          </tr>
          <tr>
            <td>0000 0000 1...1111 1110</td>
            <td>Any</td>
            <td>normal number</td>
          </tr>
          <tr>
            <td>1111 1111</td>
            <td>00...00</td>
            <td>infinity</td>
          </tr>
          <tr>
            <td>1111 1111</td>
            <td>non-zero</td>
            <td>NaN</td>
          </tr>
        </table>
        <p>
          What is <strong>NaN</strong>? It means "not a number".<br>
          For example, \(\sqrt{-1}\), \(\frac{\infty}{\infty}\) and \(\infty \cdot 0\).
        </p>
        <p>
          If we didn't create a special case for subnormal numbers, then the gap between \(0\) and our smallest representable number would be:
          \begin{align*}
            0 \: 000 \: 0000_2 &amp;= 1.0000 \cdot 2^{-3}\\
                               &amp;= 0.1255
          \end{align*}
          That is a large gap! Often we talk about small numbers.<br>
          This also means our gap between adjacent numbers is \(0.0001 \cdot 2^{-3} = 2^{-7}\).
        </p>
        <p>
          Instead, we treat subnormal numbers as a special case.<br>
          So, when we would have \((0 - bias)\) exponent instead we do \((1 - bias)\) as exponent and have the implicit bit be \(0\).<br>
          This is how to interpret subnormal numbers: \((-1)^{S} \cdot (0.F) \cdot 2^{1 - bias}\)
        </p>
        <ul>
          <li>Smallest number \(&gt;0\) is \(1.00 \cdot 2^{-2}\)</li>
          <li>Gap between number is \(0.0001 \cdot 2^{-2}\) (worse)</li>
          <li>Smallest subnormal number is \(0.0001 \cdot 2^{-2} = 0.01525\) (much better!)</li>
        </ul>
        <p>
          So using subnormal numbers we get a larger gap between our numbers (largest/smallest possible exponent).<br>
          But we get closer to 0 before losing all our precision.<br>
          Tradeoff is the gaps between representable numbers and how close to 0 we can get.
        </p>
        <br>
        <h4>Gradual Underflow</h4>
        <p>
          Don't forget floating point is not exact, it is only an approximation of real numbers.<br>
          For example, \(0.1\) cannot be represented in IEEE 754.<br>
          Therefore, don't use <code>==</code> on floats.<br>
          Also, associativity and distribution or arithmetic operators are not guaranteed!
        </p>
        <br>
        <h4>Module 2 - Assembly Language</h4>
        <p>Recall: Computers only understand set instructions which are group of \(1\)'s and \(0\)'s (machine code).</p>
        <p>
          A assembly language is one step up from that - basis operations that operate on registers.<br>
          It has a direct translation to machine code.
        </p>
        <p>
        A program called an assembler translates assembly to machine code.
        </p>
        <p>
          In order to understand how computers/programs work, we are going to study <strong>MIPS</strong> on assembly language.<br>
          Because assembly languages operate on registers (actual hardware of CPU), assembly languages are tied to hardware.<br>
          Hence why we use an emulator.
        </p>
        <p>
          <strong>MIPS</strong> is an acronym for Microprocessor without Interlocked Pipeline Stages; we will talk about the meaning later (someday in the future).
        </p>
        <p>
          In MUPS, we have 32 registers (which are labeled with <code>$0</code> to <code>$31</code>).<br>
          Each register is 32 bits.<br>
          Why we only have 32 registers, not more? More means slower - we need more bits to store a register.<br>
          For now, we only need 5 bits to store 32 registers.
        </p>
        <p>
          <strong>Special Registers</strong><br>
          PC (program counter) holds the memory address of the next instruction; each instruction done increments it by 4, or it can be manipulator.
        </p>
        <p>
          <strong>Register 0 (<code>$0</code>)</strong>: It is the constant \(0\); otherwise, the machine will die!<br>
          <br>
          <strong>Conventions</strong><br>
          <code>$31</code> is the return address and <code>$30</code>, <code>$29</code> and <code>$28</code> are special.
        </p>
      </section>
      <hr>
      
      <table class="buttomTable">
        <tr>
          <td class="buttomLeftTable"></td>
          <td class="buttomCentreTable"><a href="./cs230.html">&uarr; Go to Index</a></td>
          <td class="buttomRightTable"><a href="./cs230_2.html">&rarr; Go to Module 2 - Assembly Language&nbsp;</a></td>
        </tr>
      </table>
      <hr>

      <p>Find a typo or mistake? Feel free to contact me and I will correct it as soon as possible.</p>
      <hr>

      <div class="footer">
        <p>Thanks For Coming Here. - Calvin Li</p>
        <a href = "mailto: ck6li@edu.uwaterloo.ca" target = "_blank;"><i class = "fa fa-envelope-square"></i></a>
        <a href = "https://www.linkedin.com/in/vertckli/" target = "_blank;"><i class = "fa fa-linkedin-square"></i></a>       
        <a href = "https://www.instagram.com/vert_arts/" target = "_blank;"><i class="fa fa-instagram"></i></a>
        <a href = "https://github.com/vertli" target = "_blank;"><i class="fa fa-github-square"></i></a>
        <br>
        <p><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" /></a> This work by <a xmlns:cc="http://creativecommons.org/ns#" href="https://vertli.github.io/" property="cc:attributionName" rel="cc:attributionURL">Chun Kit (Calvin) Li</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>. Chun Kit (Calvin) Li &copy; 2017 - 2018</p>
      </div>
      <hr>

    </div>

    <script src="https://code.jquery.com/jquery-2.1.4.js"></script>
    <script src="./bootstrap-3.3.7-dist/js/bootstrap.js"></script>
    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML"></script>

  </body>

</html>