<!DOCTYPE html>

<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>CS246|Calvin Li</title>
        <link rel="stylesheet" href="./css/style.css">
        <link rel="stylesheet" href="./css/notes.css">
        <link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/hack-font/build/web/hack.css'> <!-- HACK!!! -->
        <link rel="stylesheet" href="./css/font-awesome-5.8.1/all.css" />
        <!-- Code Display use -->
        <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?skin=desert"></script>
        <link rel="stylesheet" href="./css/skin.css">
    </head>
    
    <body>
        <div class="topnav" id="myTopnav">
            <a href="./index.html" class="active">Calvin Li</a>
            <a href="./about.html">About</a>
            <a href="./projects.html">Projects</a>
            <a href="./arts.html">Arts</a>
            <a href="./contact.html">Contact</a>
            <div class="topnav-right">
              <a href="./doc/NewResume_CKLI.pdf">Résumé</a>
            </div>
            <a href="javascript:void(0);" class="icon" onclick="navbarUse()">
              <i class="fa fa-bars"></i>
            </a>
        </div>

        <div class="container">
            <div class="row">
                <div class="col=12">
                    <table class="header">
                        <tr>
                            <td colspan="100%">
                                <h1 class="title">CS 246 - Object-Oriented Development</h1>
                            </td>
                        </tr>
                        <tr>
                            <th colspan="5%">Instructor:</th>
                            <td colspan="95%">Brad Lushman</td>
                        </tr>
                        <tr>
                            <th colspan="5%">Office:</th>
                            <td colspan="95%">DC3110</td>
                        </tr>
                        <tr>
                            <th colspan="5%">Email:</th>
                            <td colspan="95%"><a href = "mailto: brad.lushman@uwaterloo.ca" target = "_blank;">brad.lushman@uwaterloo.ca</a></td>
                        </tr>
                        <tr>
                            <th colspan="5%">Website:</th>
                            <td colspan="95%">
                                <a href="https://www.student.cs.uwaterloo.ca/~cs246/" target="_blank;">https://www.student.cs.uwaterloo.ca/~cs246/</a>
                            </td>
                        </tr>
                        <tr>
                            <th colspan="5%">Note:</th>
                            <td>All program codes below are provided by Prof. Lushman during class.</td>
                        </tr>
                    </table>
                </div>
            </div>
            <hr>
           <div class="row">
               <div class="col-12">
                    <div class="lec7">
                    <h3>Lecture 7 - 28/09/2017</h3>
                    <hr>
                    <h4 class="title">Module 3 - C++ (Part 2) and Introduction to OOP</h4>
                    <p>
                       Recall: Overloading <code>&lt;&lt;</code> and <code>&gt;&gt;</code>
                    </p>
<pre class="prettyprint linenums lang-cpp">struct Grade {
    int theGrade;
};

ostream &amp;operator&lt;&lt;(ostream &amp;out, const Grade &amp;g) {
    return out &lt;&lt; g.theGrade &lt;&lt; '%';
}

istream &amp;operator&gt;&gt;(istream &amp;in, Grade &amp;g) {
    in &gt;&gt; g.theGrade;
    if (g.theGrade &lt; 0) g.theGrade = 0;
    if (g.theGrade &gt; 100) g.theGrade = 100;
    return in;
}</pre>
                    <br>
                    <b>The Preprocessor</b>
                    <p>
                        The preprocessor transforms the program before the compiler sees it.<br>
                        <code>#______</code> is the preprocessor directive.<br>
                        For example, <code>#inlcude</code>.<br>
                        It includes old C headers into C++: new naming convention.<br>
                        For example, instead of using <code>#include &lt;stdio.h&gt;</code>, we use <code>#include &lt;cstdio&gt;</code> in C++.<br>
                        <br>
                        <code>#define var val</code><br>
                        This code sets a preprocessor variable, then all occurrences of <code>var</code> in the source file are replaced with <code>val</code>.<br>
                        Example:<br>
                    </p>
<pre class="prettyprint linenums lang-cpp">#define MAX 10
int a[MAX];
// transformed to int a[10]</pre>

                    <p>Instead of doing this, you can just use constant.</p>

<pre class="prettyprint linenums lang-cpp">#define ever ;;
...
for (ever) {...}</pre>

                    <p>
                        Yes... You can actually do that...<br>
                        <br>
                        <code>#define FLAG</code><br>
                        This code sets the variable FLAG and the value is the empty string.<br>
                        <br>
                        Define constants good for conditional compilation.
                    </p>
<pre class="prettyprint linenums lang-cpp">#if SECURITYLEVEL == 1 // remove if SECURITYLEVEL != 1
    short int
#elif SECURITYLEVEL == 2 // removed if SECURITYLEVEL != 2
    long long int
#endif
    publickey;</pre>
      
                    <p>Special Case:</p>
<pre class="prettyprint linenums lang-cpp">#if 0
    ... 
#endif</pre>
                    <p>0 is false, so never true, all inner text is removed before it gets to the compiler.<br>
                        You can use if for <strong>industrial strength "comment out"</strong>.</p>
                    <br>
                    <b>Comment</b>
                    <p>
                        Way 1: <code> // I am a comment</code><br>
                        Way 2: <code>/* I am a comment */</code><br>
                        Notice that way 2 doesn't nest. In other word,<code>/* /* I am a comment */ I am out of the comment */</code> doesn't work.<br>
                        But our special case is nests properly!<br>
                        <br>
                        We can define symbols via compiler arguments.<br>
                        Example:
                    </p>
                    <span>
<pre class="prettyprint linenums lang-cpp">// define.cc
int main () {
    cout &lt;&lt; X &lt;&lt; endl;
}

g++14 -DX=15 define.cc -o define
./define
// then we will get 15</pre>

                    <p>
                        <code>#ifdef NAME</code> true if <code>NAME</code> has been defined.<br>
                        <code>#ifndef NAME</code> true if <code>NAME</code> has not been defined.<br>
                        <br>
                        Example:
                    </p>
<pre class="prettyprint linenums lang-cpp">int main () {
    #ifdef DEBUG
        cout &lt;&lt; "setting x = 1" &lt;&lt; endl;
    #endif
    int x = 1;
    while (x &lt; 10) {
        ++x;
        #ifdef DEBUG
            cout &lt;&lt; "x is now" &lt;&lt; endl;
        #endif
    }
    cout &lt;&lt; x &lt;&lt; end;
}

g++14 debug.cc -o debug // no debugging output
g++14 -DDEBUG debug.cc -o debug // enables debugging output</pre>
                    <br>
                    <b>Separate Compilation</b>
                    <p>
                        Split programs into composable <u>modules</u>, which each provide<br>
                    </p>
                    <ul>
                        <li>
                            interface<br>
                            <ul><li>type definitions, prototypes for functions (in .h file)</li></ul>
                        </li>
                        <li>
                            implementation<br>
                            <ul><li>full definition for every provided function (in .cc file)</li></ul>
                        </li>
                    </ul>
                    <p>
                        Recall:<br>
                        Declaration - asserts existence<br>
                        Definition - full details: allocates space (variables/functions)<br>
                        Example:
                    </p>
<pre class="prettyprint linenums lang-cpp">// interface vec.h
struct Vec {
    int x, y;
}
Vec operator+(const Vec &amp;v1, const Vec &amp;v2);

// implementation vec.cc
#include "vec.h" // so that we get the struct definition
Vec operator+(cons Vec &amp;v1, const Vec &amp;v2) {
    return {v1.x + v2.x, v1.y + v2.y};
}

// main.cc
#include "vec.h"
int main () {
    Vec v {1, 2};
    v = v + v;
    ...
}</pre>
                    <p>Recall: an entity can be declared many times, but defined at most once.</p>
                    <br>
                    <b>Compiling Separately</b>
<pre class="prettyprint linenums lang-cpp">g++14 -c vec.cc
// compile only, do not link
// creates vec.o ("object file")

g++14 -c main.cc

g++14 vec.o main.o -o main
// links object files into executable</pre>

                    <p>
                        What if we want a module to provide a global variable?<br>
                        Example:
                    </p>
<pre class="prettyprint linenums lang-cpp">// abc.h
int globalNum; // definition and declaration</pre>

                    <p>
                        Every file athat includes <code>abc.h</code> defines a separate <code>globalNum</code>.<br>
                        You cannot have more than one global variable with the same name; the program will not link.<br>
                        Solution:
                    </p>
<pre class="prettyprint linenums lang-cpp">// abc.h
extern int globalNum; // declaration, but not definition

// abc.cc
int globalNum; // definition</pre>

                    <p>Suppose we write a linear algebra module:</p>
<pre class="prettyprint linenums lang-cpp">// linalg.h
#include "vector.h"
...

// linalg.cc
#include "linalg.h"
#include "vector.h"
...</pre>
                    <p>
                        The program won't compile.<br>
                        <code>linalg.cc</code> includes <code>linalg.h</code> and <code>vector.h</code>.<br>
                        But <code>linalg.h</code> includes <code>vector.h</code> too.<br>
                        So we have 2 copies of <code>vector.h</code>.<br>
                        The struct <code>Vec</code> defined twice!!!<br>
                        <br>
                        We need to prevent files from being included more than once.<br>
                        Solution: <code>#inlucde</code> guard.<br>
                    </p>
<pre class="prettyprint linenums lang-cpp">// vec.h
#ifndef VEC_H // pick any unique symbol (suggest: based on file name)
    #define VEC_H
    ... // file contents
#endif</pre>
                    <p>
                        First time <code>vec.h</code> is included.<br>
                        The symbol <code>VEC_H</code> is not defined, so the file is included it.<br>
                        After that, <code>VEC_H</code> is defined, so the contents of <code>vec.h</code> are suppressed.<br>
                        <strong>Always</strong> put <code>#include</code> guards in .h files!<br>
                        <strong>Never ever ever *100</strong> compile .h files and include .cc files.<br>
                        <strong>Never</strong> put <code>using namespace std;</code> in headers; this forces the client to open up the namespace, so always use the <code>std::</code> prefix in headers.<br>
                    </p>
                    </div>
                    <hr>
               </div>
           </div>
           <div class="row">
               <div class="col-12">
                    <div class="lec8">
                        <h3>Lecture 8 - 03/10/2017</h3>
                        <hr>
                        <p>Recall:<br></p>
<pre class="prettyprint linenums lang-cpp">Node *np = new Node();
...
delete np;</pre>
                        <p>Or in array:</p>
<pre class="prettyprint linenums lang-cpp">int *p = new int [40]; // arry of 40 integers
delete [] p;</pre>
                        <p>The form of <code>new</code> must match the form of <code>delete</code>.</p>
                        <br>
                        <b>Classes</b>
                        <p>
                            We can put functions inside of structres.<br>
                            Example:
                        </p>
<pre class="prettyprint linenums lang-cpp">struct Student {
    int assn, mt, final;
    float grade {
        return assn * 0.4 + mt * 0.2 + final * 0.4;
    }
};
Student s{70, 80, 90};
cout &lt;&lt; s.grade() &lt;&lt; endl;</pre>
                        <p>
                            Class is the structure type that can contain functions.<br>
                            C++ has a <u>class</u> keyword (will use later).<br>
                            <br>
                            Object: an instance of a class<br>
                            <br>
                            The function <code>grade()</code> is called a <i>member function</i> (or <i>method</i>).<br>
                            <br>
                            What do <code>assn</code>, <code>mt</code> and <code>final</code> mean insider of <code>grade(){...}</code>?<br>
                            They are fields of the <u>current</u> object - the object upon which grade was invoked.<br>
                            <br>
                            Example:
                        </p>
<pre class="prettyprint linenums lang-cpp">Student billy{...};
billy.grade(); // uses Billy's assn, mt and final</pre>
                        <p>
                            Formally, methods take a hidden extra parameter called <code>this</code>.<br>
                            <code>this</code>: pointer to the object on which the method was called<br>
                            Example: <code>billy.grade(); // this == &amp;billy</code><br>
                            So we can write as<br>
                        </p>
<pre class="prettyprint linenums lang-cpp">struct Student {
    ...
    float grade() {
        return this-&gt;assn * 0.4 + this-&gt;mt * 0.2 + this-&gt; * 0.4;
    }
};</pre>
                        <br>
                        <b>Initialising Objects</b>
                        <p>
                            <code>Student billy{60, 70, 80}; // this is okay, but limited</code><br>
                            The better way to do is have a method that does initialisation - a <u>constructor</u>.
                        </p>
<pre class="prettyprint linenums lang-cpp">struct Student {
    int assn, mt, final;
    float grade() {…}
    Student(int assn, int mt, int final) {
        this-&gt;assns = assns;
        this-&gt;mt = mt;
        this-&gt;final = final;
    }
};
Student billy{60, 70, 80}; // better</pre>
                        <p>
                            If a constructor has been defined, these are passed as arguments to the constructor.<br>
                            It no constructor has been defined, tehse initialise the individual fields of <code>Student</code>.<br>
                            <br>
                            <code>Studnet billy = Student {60, 70, 80};</code><br>
                            Heap allocation: <code>Student *pbilly = new Student {60, 70, 80};</code><br>
                            <br>
                            Advantages of Constructor: (1) default parameters, (2) overloading and (3) sanity checks.
                        </p>
<pre class="prettyprint linenums lang-cpp">struct Student {
    ...
    Studnet(int assn = 0; int mt = 0; int final = 0) {
        this-&gt;assn = assn;
        // etc.
    }
};
Student jane{60, 70}; // 60, 70, 0
Student newKid; // 0, 0, 0</pre>

                        <p>
                            Note:<br>
                            Every class comes with a built-in default (i.e. no arguments) constructor.<br>
                            (It is ject a default, constructs all fields that are objects.)<br>
                            Example:<br>
                            <code>Vec v; // default constructor (does nothing in this case)</code><br>
                            <br>
                            But the built-in default constructor goes away if you provide a constructor.<br>
                            Example:
                        </p>
<pre class="prettyprint linenums lang-cpp">struct Vec {
    int x, y;
    Vec(int x, int y) {
        this-&gt;x = x;
        this-&gt;y = y;
    }
};
Vec v; // Error, no default constructor
Vec v{1,2}; // this is okay

int x = 5; // work
int x{5}; // work
int x(5); // work
struct Vec v{1,2}; // work
string s = "Hello"; // work
string s{"Hello"}; // work
ifstream f("file.txt"); // work
ifstream f = "file.txt"; // you cannot do this</pre>
                        <p>
                            This <code>{}</code> is called "uniform initialisation". (99% work in C++!!!!)<br>
                            <br>
                            What if a structure contians constants or references?
                        </p>
<pre class="prettyprint linenums lang-cpp">struct myStruct{
    const int myConst;
    int &amp;myRef;
};</pre>
                        <p>The whole thing must be initialised. So initialise:</p>
<pre class="prettyprint linenums lang-cpp">int z;
struct myStruct {
    const int myConst = 5;
    int &amp;myRef = z;
};</pre>
                        <p>
                            This is not a full solution...<br>
                            But does <u>every</u> instance of <code>myStruct</code> need to have the <u>same</u> value of <code>myConst</code>, etc.?<br>
                            Example:
                        </p>
<pre class="prettyprint linenums lang-cpp">struct Student {
    const int id;
    // constant (doesn't change), but not the same for all students!
    ...
};</pre>
                        <p>

                            Where do we initialise?<br>
                            Constructor body? Too late, fields must be fully constructed by then.<br>
                            <br>
                            What happens when an object is created?
                        </p>
                        <ol>
                            <li>Space is allocated</li>
                            <li>Fields are constructed in declaration order</li>
                            <li>Constructor body runs</li>
                        </ol>
                        <p>
                            We need to put our initialisation in declaration. But How?<br>
                            <strong>Member Initialisation List (MIL)</strong>
                        </p>
<pre class="prettyprint linenums lang-cpp">struct Student {
    const int id;
    int assn, mt, final;
    Student(int id, int assn, int mt, int final):
        id{id}, assn{assn}, mt{mt}, final{final} {
            ...
        }
    };</pre>
                        <p>
                            <code>id{id}, assn{assn}, mt{mt}, final{final}</code><br>
                            Each of them are <code>field{parameter}</code>
                        </p>
<pre class="prettyprint linenums lang-cpp">struct Student {
    string name;
    Student(string name) {
        this-&gt;name = name;
    }
};</pre>
                        <p>
                            <code>name</code> is default.<br>
                            It constructed to step 2, then reassigned in step 3.<br>
                            <br>
                            <code> Student (string name): name{name} {}</code><br>
                            <code>this-&gt;name</code> is initialised to <code>name</code> in step 2.<br>
                            <br>
                            Note: fields are initialised <u>in the order in which they are declared in the class</u>, even if the MIL orders them differently.<br>
                            <br>
                            Embrace the MIL!<br>
                            What if a field is initialised inline AND in the MIL?
                        </p>
<pre class="prettyprint linenums lang-cpp">struct Vec {
    int x = 0, y = 0;
    Vec(int x): x{x} {}
};</pre>
                        <p>
                            MIL takes precedence.<br>
                            <code>int x = 0, y = 0;</code> only happens if the field is not mentioned in the MIL.<br>
                            <br>
                            Now consider:<br>
                            <code>Student billy{60, 70, 80};</code><br>
                            <code>Student bilaal = billy;</code><br>
                            How does this initialisation happen?<br>
                            The <strong>copy constructor</strong>, for constructing one object as a copy of another.<br>
                            <br>
                            Note: Every class comes with...
                        </p>
                        <ul>
                            <li>a default constructor (default - constructs all fields that are objects)</li>
                            <li>a copy constructor (just copies all fields)</li>
                            <li>a copy assignment operator</li>
                            <li>a move constructor</li>
                            <li>a move assignment operator</li>
                            <li>a destructor</li>
                        </ul>
                        <p>
                            <br>Writing your own copy constructor:<br>
                        </p>
<pre class="prettyprint linenums lang-cpp">struct Student {
    ...
    Student (...) {...}
    Student (const Student &amp;other):
        assn{other.assn}, mt{other.mt}, final{other.final} {...}
        // equiv. to built-in
};</pre>
                        <p>
                            <code>Student (const Student &amp;other)</code> must be by reference.<br>
                            <br>
                            When is the built-in copy constructor not correct?<br>
                            Consider:<br>
                        </p>
<pre class="prettyprint linenums lang-cpp">struct Node {
    int data;
    Node *next;
    ...
};</pre>
                    </div>
                    <hr>
               </div>
           </div>
           <div class="row">
               <div class="col-12">
                    <div class="lec9">
                    <h3>Lecture 9 - 05/10/2017</h3>
                    <hr>
                    <p>What the built-in copy constructor is not correct?</p>
<pre class="prettyprint linenums lang-cpp">struct Node {
    int data;
    Node *next;
    Node(const Node &amp;other): data{other.data}, next{other.next} {}
    Node(int data, Node *next): data{data}, next{next} {}
};
Node *n = new Node{1, nex Node{1, new Node{2, new Node{}, nullptr}}};</pre>
                    <img src="./img/cs246/lec9/lec9_1.png" width="35%" height="35%">
                    <p>
                        Simply copy of fields -&gt; only the first node is actually copied (<strong>shallow</strong> copy).<br>
                        If you want a <strong>deep</strong> copy (copies the whole list), must write you own copy constructor.
                    </p>
<pre class="prettyprint linenums lang-cpp">struct Node {
    ...
    Node(const Node &amp;other):
        data{other.data}, next{other.next? new Node{*other.next}:nullptr} {}
};</pre>
                    <p>
                        <code>new Node{*other.next}</code> calls the copy constructor - Recursion!!!<br>
                        <br>
                        The copy constructor is called when...
                    </p>
                    <ol>
                        <li>an object is initialised with another object</li>
                        <li>an object is passed by value</li>
                        <li>an object is returned  by a function</li>
                    </ol>
                    <p>
                        P.S. There are exceptions to these (later!)<br>
                        <br>
                        <strong>Beware</strong> of copy constructor that can take <u>one</u> argument.<br>
                        Example:
                    </p>
<pre class="prettyprint linenums lang-cpp">struct Node {
    ...
    Node(int data): data{data}, next{nullptr} {}
    ...
};</pre>
                    <p>
                        Single-argument copy constructors create implicit conversions.<br>
                        Example: <code>Node n{4}; // [4|nullptr]</code><br>
                        But also <code>Node n = 4; // implicit conversion from integer to Node</code><br>
                        and <code>String s = "hello";</code> // implicit conversion from char* to string
                    </p>
<pre class="prettyprint linenums lang-cpp">int f(Node n) {...}
f(4); // this works, since 4 implicitly converted to Node</pre>
                    <p>
                        <strong>Danger!</strong><br>
                        Accidentally pass an integer to a function expecting a Node...
                    </p>
                    <ol>
                        <li>silent conversion</li>
                        <li>compiler does not signal an error</li>
                        <li>potential error not caught</li>
                    </ol>
                    <p>
                        Good Idea: disable the implicit conversion and make the copy constructor <code>ecplicit</code>.<br>
                        Example:
                    </p>
<pre class="prettyprint linenums lang-cpp">struct Node {
    ...
    explicit Node(int data): data{data}, next{nullptr} {}
    ...
};

// then...
Node n{4}; // okay
Node n = 4; // no
f(4); // no
f(Node{4}); // okay</pre>
                    <br>
                    <b>Destructor</b>
                    <p>	
                        When an object is destroyed...<br>
                        - stack-allocated: goes out of scope<br>
                        - heap-allocated: is deleted<br>
                        <br>
                        ... a method calls the <u>destructor</u> runs:
                    </p>
                    <ol>
                        <li>destructor (dtor) body runs</li>
                        <li>field's destructor are called in reverse declaration order</li>
                        <li>Space deallocated</li>
                    </ol>
                    <p>
                        Classes come with a destructor (just calls destructor for all fields that are objects).<br>
                        <br>
                        When do we need to write one?
                    </p>
<pre class="prettyprint linenums lang-cpp">Node *np = new Node{1, new Node{2, new Node{3, nullptr}}};</pre>
                    <p>
                        If <code>np</code> goes out of scope...<br>
                        - the <u>pointer</u> is reclaimed (on the stack).<br>
                        - the <u>entire list</u> is leaked.<br>
                        If we say <code>delete np</code>...<br>
                        - calls <code>*np</code>'s destructor, which doesn't do anything.
                    </p>
                    <img src="./img/cs246/lec9/lec9_2.png" width="45%" height="45%">
                    <p>Write a destructor to ensure the whole list is freed:</p>
<pre class="prettyprint linenums lang-cpp">struct Node {
    ...
    ~Node() {delete next;}
};</pre>
                    <p>
                        <code>delete next;</code> recursively calls <code>*next</code>'s destructor, so whole list is freed.<br>
                        Now, <code>delete np;</code> frees the whole list.
                    </p>
                    <br>
                    <b>Copy Assignment Operator</b>
<pre class="prettyprint linenums lang-cpp">Student billy{60, 70, 80};
Student bilaal = billy; // copy constructor
Student frost; // default constructor {0, 0, 0}
frost = billy; // copy, but not constructor</pre>
                    <p>
                        In line 4, this is the copy assignment operator.<br>
                        It uses compiler-supplied default (shallow).<br>
                        <br>
                        You may need to write your own one:
                    </p>
<pre class="prettyprint linenums lang-cpp">struct Node {
    ...
    Node &amp;operator=(const Node &amp;other) {
        data = oter.data;
        next = other.next? new Node{*other.next}:nullptr;
        return *this;
    }
};</pre>
                    <p>
                        This is DANGEROUS!!!!<br>
                        Using <code>Node &amp;</code>: so that cascading works.<br>
                        But why the structure is dangerous?
                    </p>
<pre class="prettyprint linenums lang-cpp">Node n{1, new Node{2, new Node{3, nullptr}}};
n = n;</pre>
                    <p>
                        Deletes <code>n</code> and then tries to copy <code>n</code> to <code>n</code>?<br>
                        This is undefined behaviour!<br>
                        <br>
                        Other examples for using copy assignment operator:<br>
                        <code>*p = *q;</code> and <code>a[i] = a[j];</code><br>
                        <br>
                        When writing <code>operator=</code>, ALWAYS make sure it works for self-assignment:
                    </p>
<pre class="prettyprint linenums lang-cpp">struct Node {
    ...
    Node &amp;operator=(const Node &amp;other) {
        if (this == &amp;other) return *this;
        data = other.data;
        delete next;
        next = other.next? new Node {*other.next}:nullptr;
        return *this;
    }
};</pre>
                    <p>
                        If the <code>new</code> in line 7 fail, this function will fail out.<br>
                        - deleted successor nudes, but <code>next</code> still points at them<br>
                        &nbsp;- dangling pointer
                    </p>
                </div>
                <hr> 
               </div>
           </div>
            <div class="row">
                <div class="col-12">
                    <div class="lec10">
                        <h3>Lecture 10 - 12/10/2017</h3>
                        <hr>
<pre class="prettyprint linenums lang-cpp">struct Node {
    ...
    Node &amp;operator=(const Node &amp;other) {
        if (this == &amp;other) return *this;
        data = next.data;
        next = other.next? new Node {*other.next}:nullptr;
        delete next;
        return *this;
    }
};</pre>
                        <p>
                            If the <code>new</code> in line 6 fail, function will abort.<br>
                            The <code>next</code> points at deleted data corrupted list.<br>
                            <br>
                            A better way to do is...
                        </p>
<pre class="prettyprint linenums lang-cpp">struct Node {
    ...
    Node &amp;operator=(const Node &amp;other) {
        if (this == &amp;other) return *this;
        Node *tmp = next;
        data = other.data;
        next = other.next? new Node {*other.next}:nullptr;
        delete tmp;
        return *this;
    }
};</pre>
                        <p>If the <code>new</code> in line 7 fail, the Node will still be in a valid state.</p>
                        <br>
                        <b>Alternative: Copy and Swap Idiom</b>
<pre class="prettyprint linenums lang-cpp">#include &lt;utility&gt;
struct Node {
    ...
    void swap(Node &amp;other) {
        using std::swap;
        swap(data, other.data);
        swap(next, other.next);
    }
    Node &amp;operator=(const Node &amp;other) {
        Node tmp = other;
        swap(tmp);
        return *this;
    }
};</pre>
                        <p>
                            Notice:<br>
                            The <code>operator=</code> is a member function, not a Standalone function.<br>
                            When an operator is declared as a member function, <code>*this</code> plays the role of the first operand.<br>
                            Example:
                        </p>
<pre class="prettyprint linenums lang-cpp">struct Vec {
    int x, y;
    Vec operator+(const Vec &amp;other) {
        return {x + other.x, y + other.y};
    }
    Vec operator*(const int k) { // this is v * k
        return {x * k, y * k};
    }
};</pre>
                        <p>
                            How would we implement <i>k*v</i>?<br>
                            You can't do it as a member function.<br>
                            The first argument no a <code>Vec</code>! It must be standalone:
                        </p>
<pre class="prettyprint linenums lang-cpp">Vec operator*(const int k, const Vec &amp;v) {
    return v * k;
}</pre>
                        <p>What about I/O operators?</p>
<pre class="prettyprint linenums lang-cpp">struct Vec {
    ...
    ostream&amp; operator&lt;&lt;(ostream &amp;out) {
        return out &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y;
    }
};</pre>
                        <p>
                            What is wrong with this?<br>
                            It makes <code>Vec</code> the LHS operand, not the RHS.<br>
                            So we need to do <code>v &lt;&lt; cout;</code>. This is so confusing!!!<br>
                            So we need to write the <code>operator&lt;&lt;</code> and <code>operator&gt;&gt;</code> as standalone functions.<br>
                            <br>
                            Certain operators <u>must</u> be members:
                        </p>
                        <ol>
                            <li><code>operator=</code></li>
                            <li><code>operator[]</code></li>
                            <li><code>operator-&gt;</code></li>
                            <li><code>operator()</code></li>
                            <li><code>operatorT</code> where <code>T</code> is a type</li>
                        </ol>
                        <br>
                        <b>Separate Compilation for Classes</b>
<pre class="prettyprint linenums lang-cpp">// Node.h
#ifnder NODE_H
#define NODE_H
struct Node {
    int data;
    Node *next;
    explicit Node(int data, Node *next = nullptr);
    bool isSingleton();
};
#endif

// Node.cc
#include "Node.h"
Node::Node(int data, Node *next): data{data}, next{next} {}
bool Node::isSingleton() {return next == nullptr;}</pre>
                        <p>
                            <code>::</code> is called <u>scope resolution operator</u>.<br>
                            <code>Node::______</code> means <code>______</code> in the context of <code>struct Node</code>.<br>
                            <code>::</code> is like <code>.</code> where LHS is a class (or namespace, not an object.
                        </p>
                        <br>
                        <b>Constant Objects</b>
                        <p>
                            <code>int f (const Node &amp;n) {...}</code><br>
                            Constatn objects arise often, especially as parameters.<br>
                            <br>
                            So, what is a constant object?<br>
                            The fields cannot be modified.<br>
                            <br>
                            Can we call methods on a constant object?<br>
                            Issue: the method may change fields, violate constant.<br>
                            Answer: Yes, we can call methods that <u>promise</u> not to modify fields.<br>
                            Example:
                        </p>
<pre class="prettyprint linenums lang-cpp">struct Student {
    int assn, mt, final;
    float grade() const; // doesn't modify fields, so declare the method const
};
...
float Student::grade() const {...}</pre>
                        <p>
                            Compiler will check that constant methods don't modify fields.<br>
                            Only constant methods can be called on constant objects.
                        </p>
                        <br>
                        <b>Rvalues and Rvalue References</b>
                        <p>
                            Reacll:<br>
                            An lvalue is anything with an address.<br>
                            An lvalue reference (<code>&amp;</code>) is like a constant pointer with auto-dereference.<br>
                            We need to always initialised an lvalue reference to an lvalue.<br>
                            <br>
                            Now consider:
                        </p>
<pre class="prettyprint linenums lang-cpp">Node n{1, new Node {2, nullptr}};
Node m = n;  // copy constructor
Node m2;
m2 = n; // copy assignment

Node pulsOne(Node n) {
    for (Node *p = &amp;n; p; p = p-&gt;next) {
        ++p-&gt;data;
    }
    return n;
}

Node m3 = plusOne(n); // copy constructor</pre>
                        <p>
                            In line 13, what is "other" for <code>plusOne(n)</code>?<br>
                            A reference.<br>
                            Reference to what?<br>
                            Compiler creates a <u>temporary object</u> to hold the result of <code>pulsOne</code>.<br>
                            So "other" is a reference to this temporary.<br>
                            Copy constructor deep-copies the data from the temporary.<br>
                            <br>
                            But...<br>
                            The temporary is just going to be discarded anyway, as soon as the statement <code>Node m3 = plusOne(n);</code> is done.<br>
                            It is wasteful to have to copy the data from the temporary. Why not just steal it instead? Then it will save the cost of a copy.<br>
                            We need to be able to tell whether other is a reference to a temporary object or a standalone object.<br>
                            <br>
                            C++:
                            rvalue reference <code>Node&amp;&amp;</code> is a reference to a <u>temporary</u> object (rvale) of bype Node.<br>
                            <br>
                            Version of the copy constructor that takes a <code>Node&amp;&amp;</code>:
                        </p>
<pre class="prettyprint linenums lang-cpp">struct Node {
    ...
    Node(Node &amp;&amp;other): data{other.data}, next{other.next} {
        other.next = nullptr;
    }
};</pre>
                        <p>
                            The <code>Node &amp;&amp;other</code> in line 3 is called a <u>move constructor</u>.<br>
                            Move Constructor: steal other's data
                        </p>
                    </div>
                    <hr>     
                </div>
            </div>
            <div class="row">
                <div class="col-12">
                    <div class="lec11">
                        <h3>Lecture 11 - 17/10/2017</h3>
                        <hr>
                        <p>Recall:</p>
<pre class="prettyprint linenums lang-cpp">struct Node {
    ...
    Node(Node &amp;&amp;other): data{other.data}, next{other.next} {
        other.next = nullptr;
    }
};</pre>
                        <p>Similarly:</p>
<pre class="prettyprint linenums lang-cpp">// the example for move constructor
Node m;
m = plusOne(n); // assignment from temporary

// Move assignment operator
struct Node {
    ...
    Node&amp; operator=(Node &amp;&amp;other) {
        //idea: steal other's data and destroy my old data
        //easy way: swap without copy
        using std::swap;
        swap(data, other.data);
        swap(next, other.next);
        return *this;
        // the temporary will be destroyed and take out old data with it
    }
};</pre>
                        <p>
                            If you don't define move  constructor/assignment operations, the copy versions will be used.<br>
                            If the move ctor/assignment is defined, it will replace all calls to the copy  constructor/assignment when the argument "other" is a temporary (rvalue).<br>
                            <br>
                            Copy/Move Elision:
                        </p>
<pre class="prettyprint linenums lang-cpp">Vec makeAVec() {
    return {0,0}; // invokes Vec's basic  constructor
}
Vec v = makeAVec(); // What runs?</pre>
                        <p>
                            What will run in line 4?<br>
                            Copy constructor? If no move constructor.<br>
                            Move constructor? If there exist move constructor.<br>
                            Let's check in <code>g++</code>.<br>
                            Just the basic ctor runs - not copy constructor, not move constructor.<br>
                            <br>
                            In some circumstances, the compiler is allowed to skip calling copy/move constructors (but doesn't have to).<br>
                            <br>
                            In the example above:<br>
                            <code>makeAVec()</code> writes its result(<code>{0,0}</code>) directly into the space occupied by <code>v</code> in the caller, rather than copy it later.<br>
                            <br>
                            Example:
                        </p>
<pre class="prettyprint linenums lang-cpp">void doSth(Vec v) {...} // pass-by-value: copy or move ctor
doSth(makeAVec());
// result of makeAVec() has written directly into the parameter - no copy/move</pre>
                        <p>
                            This code above is allowed, even if dropping ctor calls would change the behaviour of the program.<br>
                            Example: if the constructors print something<br>
                            <br>
                            You are not expected to know exactly when copy/move elision is allowed - just that it is possible.<br>
                            <br>
                            It you need all of the cconstructors to run: <code>g++ -fno-elid-constructors file.cc</code><br>
                            But this can slow down your program considerably.<br>
                            <br>
                            In summary: the Rule of 5 (or "Big 5")<br>
                            If you need to customise any one of
                        </p>
                        <ol>
                            <li>copy constructor (copy ctor)</li>
                            <li>copy assignment</li>
                            <li>destructor (dtor)</li>
                            <li>move constructor (move ctor)</li>
                            <li>move assignment</li>
                        </ol>
                        <p>
                            then you usually need to customise all 5.<br>
                            <br>
                            Arrays of Objects:<br>
                        </p>
<pre class="prettyprint linenums lang-cpp">struct Vec {
    int x, y;
    Vec(int x, int y): x{x}, y{y} {}
};
Vec *vp = new Vec[15];
Vec moveVectors[10];</pre>
                        <p>
                            Both of line 5 and 6 will not compile.<br>
                            These want to call the default constructor on each item.<br>
                            If there is no default ctor, then error!<br>
                            <br>
                            Options:
                        </p>
                        <ol>
                            <li>Provide a default constructor.</li>
                            <li>
                                For stack arrays: <code>Vec moreVectors[] = {Vec{0,0}, Vec{1,3}, Vec{2,4}};</code><br>
                                This is allowed.<br>
                            </li>
                            <li>For heap arrays, create an array of pointer.</li>
                        </ol>
<pre class="prettyprint linenums lang-cpp">Vec **vp = new Vec*[5];
vp[0] = new Vec{0,0};
vp[1] = new Vec{1,3};
// etc.
for (int i = 0; i &gt; 5; i++) {
    delete vp[i];
}
delete [] vp;</pre>
                        <br>
                        <b>Invariants and Encapsulation</b>
                        <p>Consider:</p>
<pre class="prettyprint linenums lang-cpp">struct Node {
    int data;
    Node *next;
    Node(int data, Node *next): data{data}, next{next} {}
    …
    ~Node () {delete next;}
};
Node n1{1, new Node{2, nullptr}}; // on stack, next on heap
Node n2{3,nullptr};  // on stack
Node n3{4, &amp;n2};  // on stack</pre>
                        <p>
                            What happens when these go out of scope?<br>
                            <code>n1</code> - destructor runs, entire lies is deleted. OK.<br>
                            <code>n2</code>, <code>n3</code> go out of scope - <code>n3</code>'s destructor tries to delete <code>n2</code>, but <code>n2</code> is not on the heap; <code>n2</code> is on the stack!<br>
                            This is undefined behaviour!<br>
                            You can't call <code>delete</code> for stack (only heap)!<br>
                            The class <code>Node</code> relies on an assumption for its proper operation - that <code>next</code> is either <code>nullptr</code>, or is a valid pointer to the heap, allocated by <code>new</code>.<br>
                            <br>
                            This is an <u>invariant</u>.<br>
                            Statement that holds true that <code>next</code> is either null pointer or pointer to memory allocated by <code>new</code>, upon which <code>Node</code> relies.<br>
                            But we can't guarantee the invariant.<br>
                            We can't trust the user to use <code>Node</code> property.<br>
                            Right now, we can't enforce <i>any</i> incariants since the user can interfere with our data.<br>
                            <br>
                            Example - Stack<br>
                            Invariant: last item pushed is the first item popped.<br>
                            But not if the client can rearrange the underlying data.<br>
                            To enforce invariants, we introduce <i>encapsulation</i>.<br>
                            We want clinets to treat objects as black boxes - <u>capsules</u>.
                        </p>
                        <ul>
                            <li>implementation details sealed away</li>
                            <li>can only interact via provided methods</li>
                            <li>
                                creates an abstraction<br>
                                <ul>
                                    <li>regains control over the object</li>
                                </ul>
                            </li>
                        </ul>
                        <p>Example:</p>
<pre class="prettyprint linenums lang-cpp">struct Vec {
    Vec(int x, int y);
    private:
        int x, y;
    public:
        Vec &amp;operator+(const Vec &amp;other);
        ...
};</pre>
                        <p>
                            Anything in <code>private</code> is private, can't be accessed outside the struct.<br>
                            Anything in <code>public</code> - anyone can assess.<br>
                            By default, <code>Vec (int x, int y);</code> is public.<br>
                            <br>
                            Default visibility in structs - public.<br>
                            In general, we want fields to be private; only methods should be public.<br>
                            Better to have default visibility - private.<br>
                            <br>
                            Now, it is time to switch from <code>struct</code> to <code>class</code>.<br>
                        </p>
<pre class="prettyprint linenums lang-cpp">class Vec {
    int x, y;
    public:
        Vec(int x, int y);
        Vec&amp; operator+(const Vec &amp;other);
        ...
};</pre>
                        <p>The difference between <code>class</code> and <code>struct</code> is default visibility: public in <code>struct</code> and private in <code>class</code>.</p>
                    </div>
                    <hr> 
                </div>
            </div>
            <div class="row">
                <div class="col-12">
                    <div class="lec12">
                        <h3>Lecture 12 - 19/10/2017</h3>
                        <hr>
                        <p>Fix the linked list class:</p>
<pre class="prettyprint linenums lang-cpp">// list.h
class List {
    struct Node; // private nested class
    Node *theList = nullptr; // only accessible inside class lis
    public:
        void addToFront(int n);
        int ith(int i);
        ~List();
        ...
};

// list.cc
struct List::Node {
    int data;
    Node *next;
    Node(int data, Node *next): ... {}
    ~Node {delete next;}
    ...
};

void List::addToFront(int n) {
    theList = new Node{n, theList};
}

int List::ith(int i) {
    node *curr;
    for (int j = 0; j &lt; i, j++) {
        curr = curr-&gt;next;
    }
    return curr-&gt;data;
}

List::~List() {delete theList;}</pre>
                        <p>
                            Note that only <code>List</code> can create/manipulate <code>Node</code> object.<br>
                            It's because we need to gurentee the invariant that <code>next</code> is always <code>nullptr</code> or heap pointer.<br>
                            But now, we can't traverse the list from node to node as we would want in a linked list.<br>
                            Repeatedly calling <code>ith()</code> to access the whole list needs O(n<sup>2</sup>) time.<br>
                            However, we can't expose the nodes or we lose encapsulation.
                        </p>
                        <br>
                        <div class="specialTalk">
                            <h4 class="title">Software Engineering Topic: Design Pattern</h4>
                            <ul>
                                <li>certain problems/scenarios arise frequently</li>
                                <li>keep track of good solutions to these problems</li>
                                <li>Design Pattern: If you have a situation like this, the technique may solve the problem.</li>
                            </ul>
                        </div>
                        <br>
                        <p>Solution: Iterator Pattern</p>
                        <ul>
                            <li>
                                create a class theat manages access to node
                                <ul>
                                    <li>abstraction of a pointer</li>
                                    <li>walk the list without exposing the actual pointers</li>
                                </ul>
                            </li>
                        </ul>
<pre class="prettyprint linenums lang-cpp">// Inspiration: C
for (int *p = a; p != (a+n); p++) {
    cout &lt;&lt; *p &lt;&lt; endl;
}

class List {
    struct Node;
    Node *theList;
    public:
        class Iterator {
            Node *p;
            public:
                explicit Iterator(Node *p): p{p} {}
                int &amp;operator* (){return p-&gt;data;}
                Iterator &amp;operator++() {
                    p = p-&gt;next;
                    return *this;
                }
                bool &amp;operator!=(const Iterator &amp;other) const {
                    return p != other.p;
                }
        }; // end Iterator
        Iterator begin() {return Iterator{theList};}
        Iterator end() {return Iterator{nullptr};}
}; // end List</pre>
                        <p>
                            In line 14, the method <code>&amp;operator* ()</code> returns by reference.<br>
                            The result is not a copy; it can mutate list items.
                        </p>
<pre class="prettyprint linenums lang-cpp">// client
int main() {
    List l;
    l.addToFront(1);
    l.addToFront(2);
    l.addToFront(3);
    for (List::Iterator it = l.begin(); it != l.end(); ++it) {
        cout &lt;&lt; *it &lt;&lt; endl;
    }
}</pre>
                        <p>
                            There is a shortcut: automatic type deduction - <code>auto x = y;</code>
                            The keyword <code>auto</code> automatically give <code>x</code> the same type as its initializer <code>y</code>.
                        </p>
<pre class="prettyprint linenums lang-cpp">for (auto it = l.begin(); it != l.end(); ++it) {
    cout &lt;&lt; *it &lt;&lt; endl;
}</pre>
                        <p>Now, the shorter-cut way: range-based for loop.</p>
<pre class="prettyprint linenums lang-cpp">for (auto n:l) { // n is the thing in the list
    cout &lt;&lt; n &lt;&lt; endl;
}</pre>
                        <p>
                            In line 1, <code>n</code> will copy of list item.<br>
                            The <code>for</code> statement can mutate <code>n</code>, but <code>l</code> will not be mutated.<br>
                            <br>
                            The keyword <code>auto</code> is available for any class with method <code>begin()</code> and <code>end()</code> that produce iterators, and the iterator type must support unary <code>*</code>, <code>!=</code> and prefix <code>++</code>.<br>
                            <br>
                            If you want to modify list items (or save copying), do the following:
                        </p>
<pre class="prettyprint linenums lang-cpp">for (auto &amp;n:l) {
    cout &lt;&lt; n &lt;&lt; endl;
    ++n; // it will mutate list items
}</pre>
                        <br>
                        <b>Encapsulation (continue)</b>
                        <p>
                            <code>List</code> clinet can create iterators directly!<br>
                            <code>auto it = List::Iterator(nullptr);</code><br>
                            This violates encapsulation, the clinet should be using <code>begin()</code> or <code>end()</code>.<br>
                            We could make Iterator's constructor private.<br>
                            Then client can't call <code>List::Iterator()</code>, but then neither can List.<br>
                            <br>
                            Solution: Give list privileged access to Iterator, using the keyword <code>friend</code>.	
                        </p>
<pre class="prettyprint linenums lang-cpp">class Listb{
    ...
    public:
        class Iterator {
            Node *p;
            explicit Iterator (Node *p);
            public:
                ...
                friend class List;
                ...
        };
        ...
};</pre>
                        <p>
                            The keyword <code>friend</code> in line 9, has access to all members of Iterator.<br>
                            <br>
                            Now list can still create iterators, but client can only create iterators by calling <code>begin()</code> or <code>end()</code>.<br>
                            <br>
                            Notice that give your classes as few <code>friend</code>s as possible - weakness encapsulation.<br>
                            Oce again, keep fields private.<br>
                            What if you want to provide access to fields?<br>
                            Create accessor/mutator methods.
                        </p>

<pre class="prettyprint linenums lang-cpp">class Vec{
    int x, y;
    public:
        ...
        int getX() const {return x;} // accessor
        void setY(int z) {y = z;} // mutator
};</pre>
                        <br>
                        <h4 class="title">Module 3 - C++ (Part 2) and Introduction to OOP</h4>
                        <h5 class="title">The End</h5>
                    </div>
                    <hr>
                </div>
            </div>
            <div class="row">
                <div class="col-12">
                    <table class="buttomTable">
                        <tr>
                            <td class="buttomLeftTable"><a href="./cs246_2.html">&larr; Go to Module 2 - C++ (Part 1)</a></td>
                            <td class="buttomCentreTable"><a href="./cs246.html">&uarr; Go to Index</a></td>
                            <td class="buttomRightTable"><a href="./cs246_4.html">&rarr; Go to Module 4 - C++ (Part 3), UML and Design Pattern&nbsp;</a></td>
                        </tr>
                    </table>
                    <hr>
                    <p>Find a typo or mistake? Feel free to contact me and I will correct it as soon as possible.</p>
                </div>
            </div>
            <footer id="footer">
                <p>Thanks For Coming. - Vert Li</p>
                 <!-- icons -->
                <a href="mailto: vert.c.k.li@gmail.com" target="_blank;">
                    <i class="fas fa-envelope-square fa-2x"></i>
                </a>
                <a href="https://www.linkedin.com/in/vertckli/" target="_blank;">
                    <i class="fab fa-linkedin fa-2x"></i>
                </a>
                <a href="https://www.instagram.com/vert_arts/" target="_blank;">
                    <i class="fab fa-instagram fa-2x"></i>
                </a>
                <a href="https://github.com/vertli" target="_blank;">
                    <i class="fab fa-github-square fa-2x"></i>
                </a>
                <!-- icons -->
                <p>Chun Kit (Calvin Vert) Li &copy; 2017 - 2020</p>
            </footer>
            <hr>
        </div>
        
        <script src="./js/style.js"></script>
        <script src="./js/height.js"></script>
    </body>
    
</html>