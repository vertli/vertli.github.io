<!DOCTYPE html>

<html>

    <head>
        <meta charset="utf-8">
        <title>Calvin Li</title>
        <link rel="stylesheet" href="./bootstrap-3.3.7-dist/css/bootstrap.css">
        <link rel="stylesheet" href="./note.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:400,800" rel="stylesheet">
        <link rel='stylesheet' href='//cdn.jsdelivr.net/npm/hack-font/build/web/hack.css'> <!-- HACK!!! -->
        <!-- stylesheet found from w3school. (icon use)-->
        <link rel = "stylesheet" href = "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    </head>
    
    <body>
        <nav class="navbar navbar-inverse navbar-fixed-top">
            <div class="container-fluid">
                <!-- Brand and toggle get grouped for better mobile display -->
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#topNavbar" aria-expanded="false">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="./index.html">Calvin Li</a>
                </div>

                <!-- Collect the nav links, forms, and other content for toggling -->
                <div class="collapse navbar-collapse" id="topNavbar">
                    <ul class="nav navbar-nav">
                        <li><a href="./doc/NewResume_CKLI.pdf" target="_blank;">Résumé</a></li>
                    </ul>
                    <ul class="nav navbar-nav navbar-right">
                        <li><a href="./about.html">About</a></li>
                        <li><a href="./projects.html">Projects</a></li>
                        <li class="courseNote">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Course Notes<span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <li><a href="./cs246.html">CS 246</a></li>
                            </ul>
                        </li>
                    </ul>
                </div><!-- /.navbar-collapse -->
            </div><!-- /.container-fluid -->
        </nav>
        <br><br>
        <div class="container">
            <br>
            <table class="header">
                <tr>
                    <td colspan="100%">
                        <h1 class="title">CS 246 - Object-Oriented Development</h1>
                    </td>
                </tr>
                <tr>
                    <td colspan="5%">
                        <span class="headerLeft">Instructor:</span>
                    </td>
                    <td colspan="95%">Brad Lushman</td>
                </tr>
                <tr>
                    <td colspan="5%">
                        <span class="headerLeft">Office:</span>
                    </td>
                    <td colspan="95%">DC3110</td>
                </tr>
                <tr>
                    <td colspan="5%">
                        <span class="headerLeft">Email:</span>
                    </td>
                    <td colspan="95%">brad.lushman@uwaterloo.ca</td>
                </tr>
                <tr>
                    <td colspan="5%">
                        <span class="headerLeft">Website:</span>
                    </td>
                    <td colspan="95%">
                        <a href="https://www.student.cs.uwaterloo.ca/~cs246/" target="_blank;">https://www.student.cs.uwaterloo.ca/~cs246/</a>
                    </td>
                </tr>
                <br>
                <tr>
                    <td colspan="95%"><span class="headerLeft">Note:</span></td>
                    <td>All program codes below are provided by Prof. Lushman in class.</td>
                </tr>
            </table>
            <hr>
           
            <div class="lec7">
                <h3>Lecture 7 - 28/09/2017</h3>
                <hr>
                <h4 class="title">Module 3 - C++ (Part 2) and Introduction to OOP</h4>
                <p>
	               Recall: Overloading <code>&lt;&lt;</code> and <code>&gt;&gt;</code>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Grade {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;int theGrade;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>};<br>
                        <span class="cline">04&nbsp;&nbsp;</span><br>
                        <span class="cline">05&nbsp;&nbsp;</span>ostream &amp;operator&lt;&lt; (ostream &amp;out, const Grade &amp;g) {<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;return out &lt;&lt; g.theGrade &lt;&lt; '%';<br>
                        <span class="cline">07&nbsp;&nbsp;</span>}<br>
                        <span class="cline">08&nbsp;&nbsp;</span><br>
                        <span class="cline">09&nbsp;&nbsp;</span>istream &amp;operator&gt;&gt; (istream &amp;in, Grade &amp;g) {<br>
                        <span class="cline">10&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;in &gt;&gt; g.theGrade;<br>
                        <span class="cline">11&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;if (g.theGrade &lt; 0) g.theGrade = 0;<br>
                        <span class="cline">12&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;if (g.theGrade &gt; 100) g.theGrade = 100;<br>
                        <span class="cline">13&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;return in;<br>
                        <span class="cline">14&nbsp;&nbsp;</span>}<br>
                    </code></pre>
                </span>
                <br>
                <b>The Preprocessor</b>
                <p>
                    The preprocessor transforms the program before the compiler sees it.<br>
                    <code>#______</code> is the preprocessor directive.<br>
                    For example, <code>#inlcude</code>.<br>
                    It includes old C headers into C++: new naming convention.<br>
                    For example, instead of using <code>#include &lt;stdio.h&gt;</code>, we use <code>#include &lt;cstdio&gt;</code> in C++.<br>
                    <br>
                    <code>#define var val</code><br>
                    This code sets a preprocessor variable, then all occurrences of <code>var</code> in the source file are replaced with <code>val</code>.<br>
                    Example:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>#define MAX 10<br>
                        <span class="cline">02&nbsp;&nbsp;</span>int a[MAX];<br>
                        <span class="cline">03&nbsp;&nbsp;</span>// transformed to int a[10]<br>
                    </code></pre>
                </span>
                <p>
                    Instead of doing this, you can just use constant.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>#define ever ;;<br>
                        <span class="cline">02&nbsp;&nbsp;</span>...<br>
                        <span class="cline">03&nbsp;&nbsp;</span>for (ever) {...}<br>
                    </code></pre>
                </span>
                <p>
                    Yes... You can actually do that...<br>
                    <br>
                    <code>#define FLAG</code><br>
                    This code sets the variable FLAG and the value is the empty string.<br>
                    <br>
                    Define constants good for conditional compilation.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>#if SECURITYLEVEL == 1 // remove if SECURITYLEVEL != 1<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;short int<br>
                        <span class="cline">03&nbsp;&nbsp;</span>#elif SECURITYLEVEL == 2 // removed if SECURITYLEVEL != 2<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;long long int<br>
                        <span class="cline">05&nbsp;&nbsp;</span>#endif<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;publickey;<br>
                    </code></pre>
                </span>
                <p>
                    Special Case:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>#if 0<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;... <br>
                        <span class="cline">03&nbsp;&nbsp;</span>#endif<br>
                    </code></pre>
                </span>
                <p>
                    0 is false, so never true, all inner text is removed before it gets to the compiler.<br>
                    You can use if for <strong>industrial strength "comment out"</strong>.<br>
                </p>
                <br>
                <b>Comment</b>
                <p>
                    Way 1: <code> // I am a comment</code><br>
                    Way 2: <code>/* I am a comment */</code><br>
                    Notice that way 2 doesn't nest. In other word,<code>/* /* I am a comment */ I am out of the comment */</code> doesn't work.<br>
                    But our special case is nests properly!<br>
                    <br>
                    We can define symbols via compiler arguments.<br>
                    Example:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>// define.cc<br>
                        <span class="cline">02&nbsp;&nbsp;</span>int main () {<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; X &lt;&lt; endl;<br>
                        <span class="cline">04&nbsp;&nbsp;</span>}<br>
                        <span class="cline">05&nbsp;&nbsp;</span><br>
                        <span class="cline">06&nbsp;&nbsp;</span>g++14 -DX=15 define.cc -o define<br>
                        <span class="cline">07&nbsp;&nbsp;</span>./define<br>
                        <span class="cline">08&nbsp;&nbsp;</span>// then we will get 15<br>
                    </code></pre>
                </span>
                <p>
                    <code>#ifdef NAME</code> true if <code>NAME</code> has been defined.<br>
                    <code>#ifndef NAME</code> true if <code>NAME</code> has not been defined.<br>
                    <br>
                    Example:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>int main () {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;#ifdef DEBUG<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; "setting x = 1" &lt;&lt; endl;<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;#endif<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;int x = 1;<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;while (x &lt; 10) {<br>
                        <span class="cline">07&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++x;<br>
                        <span class="cline">08&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef DEBUG<br>
                        <span class="cline">09&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; "x is now" &lt;&lt; endl;<br>
                        <span class="cline">10&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif<br>
                        <span class="cline">11&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <span class="cline">12&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; x &lt;&lt; end;<br>
                        <span class="cline">13&nbsp;&nbsp;</span>}<br>
                        <span class="cline">14&nbsp;&nbsp;</span><br>
                        <span class="cline">15&nbsp;&nbsp;</span>g++14 debug.cc -o debug // no debugging output<br>
                        <span class="cline">16&nbsp;&nbsp;</span>g++14 -DDEBUG debug.cc -o debug // enables debugging output<br>
                    </code></pre>
                </span>
                <br>
                <b>Separate Compilation</b>
                <p>
                    Split programs into composable <u>modules</u>, which each provide<br>
                </p>
                <ul>
                    <li>
                        interface<br>
                        <ul><li>type definitions, prototypes for functions (in .h file)</li></ul>
                    </li>
                    <li>
                        implementation<br>
                        <ul><li>full definition for every provided function (in .cc file)</li></ul>
                    </li>
                </ul>
                <p>
                    Recall:<br>
                    Declaration - asserts existence<br>
                    Definition - full details: allocates space (variables/functions)<br>
                    Example:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>// interface vec.h<br>
                        <span class="cline">02&nbsp;&nbsp;</span>struct Vec {<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;int x, y;<br>
                        <span class="cline">04&nbsp;&nbsp;</span>}<br>
                        <span class="cline">05&nbsp;&nbsp;</span>Vec operator+ (const Vec &amp;v1, const Vec &amp;v2);<br>
                        <span class="cline">06&nbsp;&nbsp;</span><br>
                        <span class="cline">07&nbsp;&nbsp;</span>// implementation vec.cc<br>
                        <span class="cline">08&nbsp;&nbsp;</span>#include "vec.h" // so that we get the struct definition<br>
                        <span class="cline">09&nbsp;&nbsp;</span>Vec operator+ (cons Vec &amp;v1, const Vec &amp;v2) {<br>
                        <span class="cline">10&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;return {v1.x + v2.x, v1.y + v2.y};<br>
                        <span class="cline">11&nbsp;&nbsp;</span>}<br>
                        <span class="cline">12&nbsp;&nbsp;</span><br>
                        <span class="cline">13&nbsp;&nbsp;</span>// main.cc<br>
                        <span class="cline">14&nbsp;&nbsp;</span>#include "vec.h"<br>
                        <span class="cline">15&nbsp;&nbsp;</span>int main () {<br>
                        <span class="cline">16&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;Vec v {1, 2};<br>
                        <span class="cline">17&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;v = v + v;<br>
                        <span class="cline">18&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;...<br>
                        <span class="cline">19&nbsp;&nbsp;</span>}<br>
                    </code></pre>
                </span>
                <P>
                    Recall: an entity can be declared many times, but defined at most once.<br>
                </P>
                <br>
                <b>Compiling Separately</b>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>g++14 -c vec.cc<br>
                        <span class="cline">02&nbsp;&nbsp;</span>// compile only, do not link<br>
                        <span class="cline">03&nbsp;&nbsp;</span>// creates vec.o ("object file")<br>
                        <span class="cline">04&nbsp;&nbsp;</span><br>
                        <span class="cline">05&nbsp;&nbsp;</span>g++14 -c main.cc<br>
                        <span class="cline">06&nbsp;&nbsp;</span><br>
                        <span class="cline">07&nbsp;&nbsp;</span>g++14 vec.o main.o -o main<br>
                        <span class="cline">08&nbsp;&nbsp;</span>// links object files into executable<br>
                    </code></pre>
                </span>
                <p>
                    What if we want a module to provide a global variable?<br>
                    Example:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>// abc.h<br>
                        <span class="cline">02&nbsp;&nbsp;</span>int globalNum; // definition and declaration<br>
                    </code></pre>
                </span>
                <p>
                    Every file athat includes <code>abc.h</code> defines a separate <code>globalNum</code>.<br>
                    You cannot have more than one global variable with the same name; the program will not link.<br>
                    Solution:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>// abc.h<br>
                        <span class="cline">02&nbsp;&nbsp;</span>extern int globalNum; // declaration, but not definition<br>
                        <span class="cline">03&nbsp;&nbsp;</span><br>
                        <span class="cline">04&nbsp;&nbsp;</span>// abc.cc<br>
                        <span class="cline">05&nbsp;&nbsp;</span>int globalNum; // definition<br>
                    </code></pre>
                </span>
                <p>
                    Suppose we write a linear algebra module:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>// linalg.h<br>
                        <span class="cline">02&nbsp;&nbsp;</span>#include "vector.h"<br>
                        <span class="cline">03&nbsp;&nbsp;</span>...<br>
                        <span class="cline">04&nbsp;&nbsp;</span><br>
                        <span class="cline">05&nbsp;&nbsp;</span>// linalg.cc<br>
                        <span class="cline">06&nbsp;&nbsp;</span>#include "linalg.h"<br>
                        <span class="cline">07&nbsp;&nbsp;</span>#include "vector.h"<br>
                        <span class="cline">08&nbsp;&nbsp;</span>...
                    </code></pre>
                </span>
                <p>
                    The program won't compile.<br>
                    <code>linalg.cc</code> includes <code>linalg.h</code> and <code>vector.h</code>.<br>
                    But <code>linalg.h</code> includes <code>vector.h</code> too.<br>
                    So we have 2 copies of <code>vector.h</code>.<br>
                    The struct <code>Vec</code> defined twice!!!<br>
                    <br>
                    We need to prevent files from being included more than once.<br>
                    Solution: <code>#inlucde</code> guard.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>// vec.h<br>
                        <span class="cline">02&nbsp;&nbsp;</span>#ifndef VEC_H // pick any unique symbol (suggest: based on file name)<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;#define VEC_H<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;... // file contents<br>
                        <span class="cline">05&nbsp;&nbsp;</span>#endif<br>
                    </code></pre>
                </span>
                <p>
                    First time <code>vec.h</code> is included.<br>
                    The symbol <code>VEC_H</code> is not defined, so the file is included it.<br>
                    After that, <code>VEC_H</code> is defined, so the contents of <code>vec.h</code> are suppressed.<br>
                    <strong>Always</strong> put <code>#include</code> guards in .h files!<br>
                    <strong>Never ever ever *100</strong> compile .h files and include .cc files.<br>
                    <strong>Never</strong> put <code>using namespace std;</code> in headers; this forces the client to open up the namespace, so always use the <code>std::</code> prefix in headers.<br>
                </p>
            </div>
            <hr> 
            
            <div class="lec8">
                <h3>Lecture 8 - 03/10/2017</h3>
                <hr>
                <P>This lecture will be updated someday in the future...</P>
            </div>
            <hr>         
            
            <div class="lec9">
                <h3>Lecture 9 - 05/10/2017</h3>
                <hr>
                <P>This lecture will be updated someday in the future...</P>
            </div>
            <hr>  
            
            <div class="lec10">
                <h3>Lecture 10 - 12/10/2017</h3>
                <hr>
                <P>This lecture will be updated someday in the future...</P>
            </div>
            <hr>         
            
            <div class="lec11">
                <h3>Lecture 11 - 17/10/2017</h3>
                <hr>
                <p>Recall:</p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Node {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;...<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;Node (Node &amp;&amp;other): data{other.data}, next{other.next} {<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;other.next = nullptr;<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <span class="cline">06&nbsp;&nbsp;</span>};<br>
                    </code></pre>
                </span>
                <p>Similarly:</p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>// the example for move constructor<br>
                        <span class="cline">02&nbsp;&nbsp;</span>Node m;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>m = plusOne (n); // assignment from temporary<br>
                        <span class="cline">04&nbsp;&nbsp;</span><br>
                        <span class="cline">05&nbsp;&nbsp;</span>// Move assignment operator<br>
                        <span class="cline">06&nbsp;&nbsp;</span>struct Node {<br>
                        <span class="cline">07&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;...<br>
                        <span class="cline">08&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;Node &amp;operator= (Node &amp;&amp;other) {<br>
                        <span class="cline">09&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//idea: steal other's data and destroy my old data<br>
                        <span class="cline">10&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//easy way: swap without copy<br>
                        <span class="cline">11&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;using std::swap;<br>
                        <span class="cline">12&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap (data, other.data);<br>
                        <span class="cline">13&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap (next, other.next);<br>
                        <span class="cline">14&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return *this;<br>
                        <span class="cline">15&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the temporary will be destroyed and take out old data with it<br>
                        <span class="cline">16&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <span class="cline">17&nbsp;&nbsp;</span>};<br>
                    </code></pre>
                </span>
                <p>
                    If you don't define move  constructor/assignment operations, the copy versions will be used.<br>
                    If the move ctor/assignment is defined, it will replace all calls to the copy  constructor/assignment when the argument "other" is a temporary (rvalue).<br>
                    <br>
                    Copy/Move Elision:
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>Vec makeAVec () {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;return {0,0}; // invokes Vec's basic  constructor<br>
                        <span class="cline">03&nbsp;&nbsp;</span>}<br>
                        <span class="cline">04&nbsp;&nbsp;</span>Vec v = makeAVec(); // What runs?<br>
                    </code></pre>
                </span>
                <p>
                    What will run in line 4?<br>
                    Copy constructor? If no move constructor.<br>
                    Move constructor? If there exist move constructor.<br>
                    Let's check in <code>g++</code>.<br>
                    Just the basic ctor runs - not copy constructor, not move constructor.<br>
                    <br>
                    In some circumstances, the compiler is allowed to skip calling copy/move constructors (but doesn't have to).<br>
                    <br>
                    In the example above:<br>
                    <code>makeAVec()</code> writes its result(<code>{0,0}</code>) directly into the space occupied by <code>v</code> in the caller, rather than copy it later.<br>
                    <br>
                    Example:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>void doSth (Vec v) {...} // pass-by-value: copy or move ctor<br>
                        <span class="cline">02&nbsp;&nbsp;</span>doSth (makeAVec());<br>
                        <span class="cline">03&nbsp;&nbsp;</span>// result of makeAVec() has written directly into the parameter - no copy/move<br>
                    </code></pre>
                </span>
                <p>
                    This code above is allowed, even if dropping ctor calls would change the behaviour of the program.<br>
                    Example: if the constructors print something<br>
                    <br>
                    You are not expected to know exactly when copy/move elision is allowed - just that it is possible.<br>
                    <br>
                    It you need all of the cconstructors to run: <code>g++ -fno-elid-constructors file.cc</code><br>
                    But this can slow down your program considerably.<br>
                    <br>
                    In summary: the Rule of 5 (or "Big 5")<br>
                    If you need to customise any one of<br>
                </p>
                <ol>
                    <li>copy constructor (copy ctor)</li>
                    <li>copy assignment</li>
                    <li>destructor (dtor)</li>
                    <li>move constructor (move ctor)</li>
                    <li>move assignment</li>
                </ol>
                <p>
                    then you usually need to customise all 5.<br>
                    <br>
                    Arrays of Objects:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Vec {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;int x, y;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;Vec (int x, int y): x{x}, y{y} {}<br>
                        <span class="cline">04&nbsp;&nbsp;</span>};<br>
                        <span class="cline">05&nbsp;&nbsp;</span>Vec *vp = new Vec[15];<br>
                        <span class="cline">06&nbsp;&nbsp;</span>Vec moveVectors[10];<br>
                    </code></pre>
                </span>
                <p>
                    Both of line 5 and 6 will not compile.<br>
                    These want to call the default constructor on each item.<br>
                    If there is no default ctor, then error!<br>
                    <br>
                    Options:<br>
                </p>
                <ol>
                    <li>Provide a default constructor.</li>
                    <li>
                        For stack arrays: <code>Vec moreVectors[] = {Vec{0,0}, Vec{1,3}, Vec{2,4}};</code><br>
                        This is allowed.<br>
                    </li>
                    <li>For heap arrays, create an array of pointer.</li>
                </ol>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>Vec **vp = new Vec*[5];<br>
                        <span class="cline">02&nbsp;&nbsp;</span>vp[0] = new Vec {0,0};<br>
                        <span class="cline">03&nbsp;&nbsp;</span>vp[1] = new Vec {1,3}; <br>
                        <span class="cline">04&nbsp;&nbsp;</span>// etc.<br>
                        <span class="cline">05&nbsp;&nbsp;</span>for (int I = 0; I &gt; 5; i++) {<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;delete vp[i];<br>
                        <span class="cline">07&nbsp;&nbsp;</span>}<br>
                        <span class="cline">08&nbsp;&nbsp;</span>delete [] vp;<br>
                    </code></pre>
                </span>
                <br>
                <b>Invariants and Encapsulation</b>
                <p>
                    Consider:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Node {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;int data;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;Node *next;<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;Node (int data, Node *next): data{data}, next{next} {}<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;…<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;~Node () {delete next;}<br>
                        <span class="cline">07&nbsp;&nbsp;</span>};<br>
                        <span class="cline">08&nbsp;&nbsp;</span>Node n1 {1, new Node{2, nullptr}}; // on stack, next on heap<br>
                        <span class="cline">09&nbsp;&nbsp;</span>Node n2 {3,nullptr};  // on stack<br>
                        <span class="cline">10&nbsp;&nbsp;</span>Node n3{4, &amp;n2};  // on stack<br>
                    </code></pre>
                </span>
                <p>
                    What happens when these go out of scope?<br>
                    <code>n1</code> - dtor runs, entire lies is deleted. OK.<br>
                    <code>n2</code>, <code>n3</code> go out of scope - <code>n3</code>'s dtor tries to delete <code>n2</code>, but <code>n2</code> is not on the heap; <code>n2</code> is on the stack!<br>
                    This is undefined behaviour!<br>
                    You can't call <code>delete</code> for stack (only heap)!<br>
                    The class <code>Node</code> relies on an assumption for its proper operation - that <code>next</code> is either <code>nullptr</code>, or is a valid pointer to the heap, allocated by <code>new</code>.<br>
                    <br>
                    This is an <u>invariant</u>.<br>
                    Statement that holds true that <code>next</code> is either null pointer or pointer to memory allocated by <code>new</code>, upon which <code>Node</code> relies.<br>
                    But we can't guarantee the invariant.<br>
                    We can't trust the user to use <code>Node</code> property.<br>
                    Right now, we can't enforce <i>any</i> incariants since the user can interfere with our data.<br>
                    <br>
                    Example - Stack<br>
                    Invariant: last item pushed is the first item popped.<br>
                    But not if the client can rearrange the underlying data.<br>
                    To enforce invariants, we introduce <i>encapsulation</i>.<br>
                    We want clinets to treat objects as black boxes - <u>capsules</u>.<br>
                </p>
                <ul>
                    <li>implementation details sealed away</li>
                    <li>can only interact via provided methods</li>
                    <li>
                        creates an abstraction<br>
                        <ul>
                            <li>regains control over the object</li>
                        </ul>
                    </li>
                </ul>
                <p>
                    Example:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Vec {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;Vec (int x, int y);<br>
                        <span class="cline">03&nbsp;&nbsp;</span>private:<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;int x, y;<br>
                        <span class="cline">05&nbsp;&nbsp;</span>public:<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;Vec &amp;operator+ (const Vec &amp;other);<br>
                        <span class="cline">07&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;...<br>
                        <span class="cline">08&nbsp;&nbsp;</span>};<br>
                    </code></pre>
                </span>
                <p>
                    Anything in <code>private</code> is private, can't be accessed outside the struct.<br>
                    Anything in <code>public</code> - anyone can assess.<br>
                    By default, <code>Vec (int x, int y);</code> is public.<br>
                    <br>
                    Default visibility in structs - public.<br>
                    In general, we want fields to be private; only methods should be public.<br>
                    Better to have default visibility - private.<br>
                    <br>
                    Now, it is time to switch from <code>struct</code> to <code>class</code>.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>class Vec {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;int x, y;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>public:<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;Vec (int x, int y);<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;Vec &amp;operator+ (const Vec &amp;other);<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;...<br>
                        <span class="cline">07&nbsp;&nbsp;</span>};<br>
                    </code></pre>
                </span>
                <p>
                    The difference between <code>class</code> and <code>struct</code> is default visibility: public in <code>struct</code> and private in <code>class</code>.<br>
                </p>
            </div>
            <hr>  
            
            <div class="lec12">
                <h3>Lecture 12 - 19/10/2017</h3>
                <hr>
                <p>Fix the linked list class:</p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>// list.h<br>
                        <span class="cline">02&nbsp;&nbsp;</span>class List {<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;struct Node; // private nested class<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;Node *theList = nullptr; // only accessible inside class list<br>
                        <span class="cline">05&nbsp;&nbsp;</span>public:<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;void addToFront (int n);<br>
                        <span class="cline">07&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;int ith (int i);<br>
                        <span class="cline">08&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;~List();<br>
                        <span class="cline">09&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;...<br>
                        <span class="cline">10&nbsp;&nbsp;</span>};<br>
                        <span class="cline">11&nbsp;&nbsp;</span><br>
                        <span class="cline">12&nbsp;&nbsp;</span>// list.cc<br>
                        <span class="cline">13&nbsp;&nbsp;</span>struct List::Node {<br>
                        <span class="cline">14&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;int data;<br>
                        <span class="cline">15&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;Node *next;<br>
                        <span class="cline">16&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;Node (int data, Node *next): ... {}<br>
                        <span class="cline">17&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;~Node {delete next;}<br>
                        <span class="cline">18&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;...<br>
                        <span class="cline">19&nbsp;&nbsp;</span>};<br>
                        <span class="cline">20&nbsp;&nbsp;</span><br>
                        <span class="cline">21&nbsp;&nbsp;</span>void List::addToFront (int n) {<br>
                        <span class="cline">22&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;theList = new Node {n, theList};<br>
                        <span class="cline">23&nbsp;&nbsp;</span>}<br>
                        <span class="cline">24&nbsp;&nbsp;</span><br>
                        <span class="cline">25&nbsp;&nbsp;</span>int List::ith (int i) {<br>
                        <span class="cline">26&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;node *curr;<br>
                        <span class="cline">27&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;for (int j = 0; j &lt; i, j++) {<br>
                        <span class="cline">28&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curr = curr-&gt;next;<br>
                        <span class="cline">29&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <span class="cline">30&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;return curr-&gt;data;<br>
                        <span class="cline">31&nbsp;&nbsp;</span>}<br>
                        <span class="cline">32&nbsp;&nbsp;</span><br>
                        <span class="cline">22&nbsp;&nbsp;</span>List::~List() {delete theList;}<br>
                    </code></pre>
                </span>
                <p>
                    Note that only <code>List</code> can create/manipulate <code>Node</code> object.<br>
                    It's because we need to gurentee the invariant that <code>next</code> is always <code>nullptr</code> or heap pointer.<br>
                    But now, we can't traverse the list from node to node as we would want in a linked list.<br>
                    Repeatedly calling <code>ith()</code> to access the whole list needs O(n<sup>2</sup>) time.<br>
                    However, we can't expose the nodes or we lose encapsulation.<br>
                </p>
                <br>
                <div class="specialTalk">
                    <h4 class="title">Software Engineering Topic: Design Pattern</h4>
                    <ul>
                        <li>certain problems/scenarios arise frequently</li>
                        <li>keep track of good solutions to these problems</li>
                        <li>Design Pattern: If you have a situation like this, the technique may solve the problem.</li>
                    </ul>
                </div>
                <br>
                <p>
                    Solution: Iterator Pattern
                </p>
                <ul>
                    <li>
                        create a class theat manages access to node
                        <ul>
                            <li>abstraction of a pointer</li>
                            <li>walk the list without exposing the actual pointers</li>
                        </ul>
                    </li>
                </ul>

                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>// Inspiration: C<br>
                        <span class="cline">02&nbsp;&nbsp;</span>for (int *p = a; p != (a+n); p++) {<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; *p &lt;&lt; endl;<br>
                        <span class="cline">04&nbsp;&nbsp;</span>}<br>
                        <span class="cline">05&nbsp;&nbsp;</span><br>
                        <span class="cline">06&nbsp;&nbsp;</span>class List {<br>
                        <span class="cline">07&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;struct Node;<br>
                        <span class="cline">08&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;Node *theList;<br>
                        <span class="cline">09&nbsp;&nbsp;</span>public:<br>
                        <span class="cline">10&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;class Iterator {<br>
                        <span class="cline">11&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node *p;<br>
                        <span class="cline">12&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;public:<br>
                        <span class="cline">13&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;explicit Iterator (Node *p): p{p} {}<br>
                        <span class="cline">14&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int &amp;operator* () {return p-&gt;data;}<br>
                        <span class="cline">15&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterator &amp;operator++ () {<br>
                        <span class="cline">16&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p = p-&gt;next;<br>
                        <span class="cline">17&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return *this;<br>
                        <span class="cline">18&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <span class="cline">19&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool &amp;operator!= (const Iterator &amp;other) const {<br>
                        <span class="cline">20&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return p != other.p;<br>
                        <span class="cline">21&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <span class="cline">22&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;}; // end Iterator<br>
                        <span class="cline">23&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;Iterator begin() {return Iterator{theList};}<br>
                        <span class="cline">24&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;Iterator end() {return Iterator{nullptr};}<br>
                        <span class="cline">25&nbsp;&nbsp;</span>}; // end List<br>
                    </code></pre>
                </span>
                <p>
                    In line 14, the method <code>&amp;operator* ()</code> returns by reference.<br>
                    The result is not a copy; it can mutate list items.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>// client<br>
                        <span class="cline">02&nbsp;&nbsp;</span>int main() {<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;List l;<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;l.addToFront(1);<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;l.addToFront(2);<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;l.addToFront(3);<br>
                        <span class="cline">07&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;for (List::Iterator it = l.begin(); it != l.end(); ++it) {<br>
                        <span class="cline">08&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; *it &lt;&lt; endl;<br>
                        <span class="cline">09&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <span class="cline">10&nbsp;&nbsp;</span>}<br>
                    </code></pre>
                </span>
                <p>
                    There is a shortcut: automatic type deduction - <code>auto x = y;</code>
                    The keyword <code>auto</code> automatically give <code>x</code> the same type as its initializer <code>y</code>.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>for (auto it = l.begin(); it != l.end(); ++it) {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; *it &lt;&lt; endl;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>}<br>
                    </code></pre>
                </span>
                <p>
                    Now, the shorter-cut way: range-based for loop. 
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>for (auto n:l) { // n is the thing in the list<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; n &lt;&lt; endl;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>}<br>
                    </code></pre>
                </span>
                <p>
                    In line 1, <code>n</code> will copy of list item.<br>
                    The <code>for</code> statement can mutate <code>n</code>, but <code>l</code> will not be mutated.<br>
                    <br>
                    The keyword <code>auto</code> is available for any class with method <code>begin()</code> and <code>end()</code> that produce iterators, and the iterator type must support unary <code>*</code>, <code>!=</code> and prefix <code>++</code>.<br>
                    <br>
                    If you want to modify list items (or save copying), do the following:
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>for (auto &amp;n:l) {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; n &lt;&lt; endl;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;++n; // it will mutate list items<br>
                        <span class="cline">04&nbsp;&nbsp;</span>}<br>
                    </code></pre>
                </span>
                <br>
                <b>Encapsulation (continue)</b>
                <p>
                    <code>List</code> clinet can create iterators directly!<br>
                    <code>auto it = List::Iterator(nullptr);</code><br>
                    This violates encapsulation, the clinet should be using <code>begin()</code> or <code>end()</code>.<br>
                    We could make Iterator's constructor private.<br>
                    Then client can't call <code>List::Iterator()</code>, but then neither can List.<br>
                    <br>
                    Solution: Give list privileged access to Iterator, using the keyword <code>friend</code>.<br>	
                </p>

                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>class List{<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;...<br>
                        <span class="cline">03&nbsp;&nbsp;</span>public:<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;class Iterator {<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node *p;<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;explicit Iterator (Node *p);<br>
                        <span class="cline">07&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;public:<br>
                        <span class="cline">08&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
                        <span class="cline">09&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;friend class List;<br>
                        <span class="cline">10&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
                        <span class="cline">11&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;};<br>
                        <span class="cline">12&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;...<br>
                        <span class="cline">13&nbsp;&nbsp;</span>};<br>
                    </code></pre>
                </span>
                <p>
                    The keyword <code>friend</code> in line 9, has access to all members of Iterator.<br>
                    <br>
                    Now list can still create iterators, but client can only create iterators by calling <code>begin()</code> or <code>end()</code>.<br>
                    <br>
                    Notice that give your classes as few <code>friend</code>s as possible - weakness encapsulation.<br>
                    Oce again, keep fields private.<br>
                    What if you want to provide access to fields?<br>
                    Create accessor/mutator methods.<br>
                </p>

                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>class Vec{<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;int x, y;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>public:<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;...<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;int getX() const {return x;} // accessor<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;void setY (int z) {y = z;} // mutator<br>
                        <span class="cline">07&nbsp;&nbsp;</span>};<br>
                    </code></pre>
                </span>
                <br>
                <h4 class="title">Module 3 - C++ (Part 2) and Introduction to OOP</h4>
                <h5 class="title">The End</h5>
            </div>
            <hr>         
            
            
            <table width="100%">
                <tr>
                    <td width="45%"><a href="./cs246_2.html">&larr; Go to Module 2 - C++ (Part 1)</a></td>
                    <td width="10%" align="centre"><a href="./cs246.html">&uarr; Go to Index</a></td>
                    <td width="45%" align="right"><a href="./cs246_4.html">&rarr; Go to Module 4 - C++ (Part 3), UML and Design Pattern&nbsp;</a></td>
                </tr>
            </table>
            
            
            <div class="footer">
                <p>Thanks For Coming Here. - Calvin Li</p>
                <a href = "mailto: ck6li@edu.uwaterloo.ca" target = "_blank;">
                    <i class = "fa fa-envelope-square"></i>
                </a>
                <a href = "https://www.linkedin.com/in/vertckli/" target = "_blank;">
                    <i class = "fa fa-linkedin-square"></i>
                </a>       
                <a href = "https://www.instagram.com/vert_arts/" target = "_blank;">
                    <i class="fa fa-instagram"></i>
                </a>
                <a href = "https://github.com/vertli" target = "_blank;">
                    <i class="fa fa-github-square"></i>
                </a>
                <br>
                <p>Chun Kit (Calvin) Li &copy; 2017</p>
                <br>
            </div>
        </div>
        <script src="https://code.jquery.com/jquery-2.1.4.js"></script>
        <script src="./bootstrap-3.3.7-dist/js/bootstrap.js"></script>
    </body>
    
</html>