<!DOCTYPE html>

<html>

    <head>
        <meta charset="utf-8">
        <title>Calvin Li</title>
        <link rel="stylesheet" href="./bootstrap-3.3.7-dist/css/bootstrap.css">
        <link rel="stylesheet" href="./note.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:400,800" rel="stylesheet">
        <link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/hack-font/build/web/hack.css'> <!-- HACK!!! -->
        <!-- stylesheet found from w3school. (icon use)-->
        <link rel = "stylesheet" href = "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    </head>
    
    <body>
        <nav class="navbar navbar-inverse navbar-fixed-top">
            <div class="container-fluid">
                <!-- Brand and toggle get grouped for better mobile display -->
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#topNavbar" aria-expanded="false">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="./index.html">Calvin Li</a>
                </div>

                <!-- Collect the nav links, forms, and other content for toggling -->
                <div class="collapse navbar-collapse" id="topNavbar">
                    <ul class="nav navbar-nav">
                        <li><a href="./doc/NewResume_CKLI.pdf" target="_blank;">Résumé</a></li>
                    </ul>
                    <ul class="nav navbar-nav navbar-right">
                        <li><a href="./about.html">About</a></li>
                        <li><a href="./projects.html">Projects</a></li>
                        <li class="courseNote">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Course Notes<span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <li><a href="./cs246.html">CS 246</a></li>
                            </ul>
                        </li>
                    </ul>
                </div><!-- /.navbar-collapse -->
            </div><!-- /.container-fluid -->
        </nav>
        <br><br>
        <div class="container">
            <br>
            <table class="header">
                <tr>
                    <td colspan="100%">
                        <h1 class="title">CS 246 - Object-Oriented Development</h1>
                    </td>
                </tr>
                <tr>
                    <td colspan="5%">
                        <span class="headerLeft">Instructor:</span>
                    </td>
                    <td colspan="95%">Brad Lushman</td>
                </tr>
                <tr>
                    <td colspan="5%">
                        <span class="headerLeft">Office:</span>
                    </td>
                    <td colspan="95%">DC3110</td>
                </tr>
                <tr>
                    <td colspan="5%">
                        <span class="headerLeft">Email:</span>
                    </td>
                    <td colspan="95%">brad.lushman@uwaterloo.ca</td>
                </tr>
                <tr>
                    <td colspan="5%">
                        <span class="headerLeft">Website:</span>
                    </td>
                    <td colspan="95%">
                        <a href="https://www.student.cs.uwaterloo.ca/~cs246/" target="_blank;">https://www.student.cs.uwaterloo.ca/~cs246/</a>
                    </td>
                </tr>
                <br>
                <tr>
                    <td colspan="95%"><span class="headerLeft">Note:</span></td>
                    <td>All program codes below are provided by Prof. Lushman in class.</td>
                </tr>
            </table>
            <hr>
           
            <div class="lec7">
                <h3>Lecture 7 - 28/09/2017</h3>
                <hr>
                <h4 class="title">Module 3 - C++ (Part 2) and Introduction to OOP</h4>
                <p>
	               Recall: Overloading <code>&lt;&lt;</code> and <code>&gt;&gt;</code>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Grade {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;int theGrade;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>};<br>
                        <span class="cline">04&nbsp;&nbsp;</span><br>
                        <span class="cline">05&nbsp;&nbsp;</span>ostream &amp;operator&lt;&lt;(ostream &amp;out, const Grade &amp;g) {<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;return out &lt;&lt; g.theGrade &lt;&lt; '%';<br>
                        <span class="cline">07&nbsp;&nbsp;</span>}<br>
                        <span class="cline">08&nbsp;&nbsp;</span><br>
                        <span class="cline">09&nbsp;&nbsp;</span>istream &amp;operator&gt;&gt;(istream &amp;in, Grade &amp;g) {<br>
                        <span class="cline">10&nbsp;&nbsp;</span>&nbsp;&nbsp;in &gt;&gt; g.theGrade;<br>
                        <span class="cline">11&nbsp;&nbsp;</span>&nbsp;&nbsp;if (g.theGrade &lt; 0) g.theGrade = 0;<br>
                        <span class="cline">12&nbsp;&nbsp;</span>&nbsp;&nbsp;if (g.theGrade &gt; 100) g.theGrade = 100;<br>
                        <span class="cline">13&nbsp;&nbsp;</span>&nbsp;&nbsp;return in;<br>
                        <span class="cline">14&nbsp;&nbsp;</span>}<br>
                    </code></pre>
                </span>
                <br>
                <b>The Preprocessor</b>
                <p>
                    The preprocessor transforms the program before the compiler sees it.<br>
                    <code>#______</code> is the preprocessor directive.<br>
                    For example, <code>#inlcude</code>.<br>
                    It includes old C headers into C++: new naming convention.<br>
                    For example, instead of using <code>#include &lt;stdio.h&gt;</code>, we use <code>#include &lt;cstdio&gt;</code> in C++.<br>
                    <br>
                    <code>#define var val</code><br>
                    This code sets a preprocessor variable, then all occurrences of <code>var</code> in the source file are replaced with <code>val</code>.<br>
                    Example:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>#define MAX 10<br>
                        <span class="cline">02&nbsp;&nbsp;</span>int a[MAX];<br>
                        <span class="cline">03&nbsp;&nbsp;</span>// transformed to int a[10]<br>
                    </code></pre>
                </span>
                <p>
                    Instead of doing this, you can just use constant.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>#define ever ;;<br>
                        <span class="cline">02&nbsp;&nbsp;</span>...<br>
                        <span class="cline">03&nbsp;&nbsp;</span>for (ever) {...}<br>
                    </code></pre>
                </span>
                <p>
                    Yes... You can actually do that...<br>
                    <br>
                    <code>#define FLAG</code><br>
                    This code sets the variable FLAG and the value is the empty string.<br>
                    <br>
                    Define constants good for conditional compilation.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>#if SECURITYLEVEL == 1 // remove if SECURITYLEVEL != 1<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;short int<br>
                        <span class="cline">03&nbsp;&nbsp;</span>#elif SECURITYLEVEL == 2 // removed if SECURITYLEVEL != 2<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;long long int<br>
                        <span class="cline">05&nbsp;&nbsp;</span>#endif<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;publickey;<br>
                    </code></pre>
                </span>
                <p>
                    Special Case:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>#if 0<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;... <br>
                        <span class="cline">03&nbsp;&nbsp;</span>#endif<br>
                    </code></pre>
                </span>
                <p>
                    0 is false, so never true, all inner text is removed before it gets to the compiler.<br>
                    You can use if for <strong>industrial strength "comment out"</strong>.<br>
                </p>
                <br>
                <b>Comment</b>
                <p>
                    Way 1: <code> // I am a comment</code><br>
                    Way 2: <code>/* I am a comment */</code><br>
                    Notice that way 2 doesn't nest. In other word,<code>/* /* I am a comment */ I am out of the comment */</code> doesn't work.<br>
                    But our special case is nests properly!<br>
                    <br>
                    We can define symbols via compiler arguments.<br>
                    Example:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>// define.cc<br>
                        <span class="cline">02&nbsp;&nbsp;</span>int main () {<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;cout &lt;&lt; X &lt;&lt; endl;<br>
                        <span class="cline">04&nbsp;&nbsp;</span>}<br>
                        <span class="cline">05&nbsp;&nbsp;</span><br>
                        <span class="cline">06&nbsp;&nbsp;</span>g++14 -DX=15 define.cc -o define<br>
                        <span class="cline">07&nbsp;&nbsp;</span>./define<br>
                        <span class="cline">08&nbsp;&nbsp;</span>// then we will get 15<br>
                    </code></pre>
                </span>
                <p>
                    <code>#ifdef NAME</code> true if <code>NAME</code> has been defined.<br>
                    <code>#ifndef NAME</code> true if <code>NAME</code> has not been defined.<br>
                    <br>
                    Example:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>int main () {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;#ifdef DEBUG<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; "setting x = 1" &lt;&lt; endl;<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;#endif<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;int x = 1;<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;while (x &lt; 10) {<br>
                        <span class="cline">07&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;++x;<br>
                        <span class="cline">08&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;#ifdef DEBUG<br>
                        <span class="cline">09&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; "x is now" &lt;&lt; endl;<br>
                        <span class="cline">10&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;#endif<br>
                        <span class="cline">11&nbsp;&nbsp;</span>&nbsp;&nbsp;}<br>
                        <span class="cline">12&nbsp;&nbsp;</span>&nbsp;&nbsp;cout &lt;&lt; x &lt;&lt; end;<br>
                        <span class="cline">13&nbsp;&nbsp;</span>}<br>
                        <span class="cline">14&nbsp;&nbsp;</span><br>
                        <span class="cline">15&nbsp;&nbsp;</span>g++14 debug.cc -o debug // no debugging output<br>
                        <span class="cline">16&nbsp;&nbsp;</span>g++14 -DDEBUG debug.cc -o debug // enables debugging output<br>
                    </code></pre>
                </span>
                <br>
                <b>Separate Compilation</b>
                <p>
                    Split programs into composable <u>modules</u>, which each provide<br>
                </p>
                <ul>
                    <li>
                        interface<br>
                        <ul><li>type definitions, prototypes for functions (in .h file)</li></ul>
                    </li>
                    <li>
                        implementation<br>
                        <ul><li>full definition for every provided function (in .cc file)</li></ul>
                    </li>
                </ul>
                <p>
                    Recall:<br>
                    Declaration - asserts existence<br>
                    Definition - full details: allocates space (variables/functions)<br>
                    Example:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>// interface vec.h<br>
                        <span class="cline">02&nbsp;&nbsp;</span>struct Vec {<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;int x, y;<br>
                        <span class="cline">04&nbsp;&nbsp;</span>}<br>
                        <span class="cline">05&nbsp;&nbsp;</span>Vec operator+(const Vec &amp;v1, const Vec &amp;v2);<br>
                        <span class="cline">06&nbsp;&nbsp;</span><br>
                        <span class="cline">07&nbsp;&nbsp;</span>// implementation vec.cc<br>
                        <span class="cline">08&nbsp;&nbsp;</span>#include "vec.h" // so that we get the struct definition<br>
                        <span class="cline">09&nbsp;&nbsp;</span>Vec operator+(cons Vec &amp;v1, const Vec &amp;v2) {<br>
                        <span class="cline">10&nbsp;&nbsp;</span>&nbsp;&nbsp;return {v1.x + v2.x, v1.y + v2.y};<br>
                        <span class="cline">11&nbsp;&nbsp;</span>}<br>
                        <span class="cline">12&nbsp;&nbsp;</span><br>
                        <span class="cline">13&nbsp;&nbsp;</span>// main.cc<br>
                        <span class="cline">14&nbsp;&nbsp;</span>#include "vec.h"<br>
                        <span class="cline">15&nbsp;&nbsp;</span>int main () {<br>
                        <span class="cline">16&nbsp;&nbsp;</span>&nbsp;&nbsp;Vec v {1, 2};<br>
                        <span class="cline">17&nbsp;&nbsp;</span>&nbsp;&nbsp;v = v + v;<br>
                        <span class="cline">18&nbsp;&nbsp;</span>&nbsp;&nbsp;...<br>
                        <span class="cline">19&nbsp;&nbsp;</span>}<br>
                    </code></pre>
                </span>
                <P>
                    Recall: an entity can be declared many times, but defined at most once.<br>
                </P>
                <br>
                <b>Compiling Separately</b>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>g++14 -c vec.cc<br>
                        <span class="cline">02&nbsp;&nbsp;</span>// compile only, do not link<br>
                        <span class="cline">03&nbsp;&nbsp;</span>// creates vec.o ("object file")<br>
                        <span class="cline">04&nbsp;&nbsp;</span><br>
                        <span class="cline">05&nbsp;&nbsp;</span>g++14 -c main.cc<br>
                        <span class="cline">06&nbsp;&nbsp;</span><br>
                        <span class="cline">07&nbsp;&nbsp;</span>g++14 vec.o main.o -o main<br>
                        <span class="cline">08&nbsp;&nbsp;</span>// links object files into executable<br>
                    </code></pre>
                </span>
                <p>
                    What if we want a module to provide a global variable?<br>
                    Example:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>// abc.h<br>
                        <span class="cline">02&nbsp;&nbsp;</span>int globalNum; // definition and declaration<br>
                    </code></pre>
                </span>
                <p>
                    Every file athat includes <code>abc.h</code> defines a separate <code>globalNum</code>.<br>
                    You cannot have more than one global variable with the same name; the program will not link.<br>
                    Solution:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>// abc.h<br>
                        <span class="cline">02&nbsp;&nbsp;</span>extern int globalNum; // declaration, but not definition<br>
                        <span class="cline">03&nbsp;&nbsp;</span><br>
                        <span class="cline">04&nbsp;&nbsp;</span>// abc.cc<br>
                        <span class="cline">05&nbsp;&nbsp;</span>int globalNum; // definition<br>
                    </code></pre>
                </span>
                <p>
                    Suppose we write a linear algebra module:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>// linalg.h<br>
                        <span class="cline">02&nbsp;&nbsp;</span>#include "vector.h"<br>
                        <span class="cline">03&nbsp;&nbsp;</span>...<br>
                        <span class="cline">04&nbsp;&nbsp;</span><br>
                        <span class="cline">05&nbsp;&nbsp;</span>// linalg.cc<br>
                        <span class="cline">06&nbsp;&nbsp;</span>#include "linalg.h"<br>
                        <span class="cline">07&nbsp;&nbsp;</span>#include "vector.h"<br>
                        <span class="cline">08&nbsp;&nbsp;</span>...
                    </code></pre>
                </span>
                <p>
                    The program won't compile.<br>
                    <code>linalg.cc</code> includes <code>linalg.h</code> and <code>vector.h</code>.<br>
                    But <code>linalg.h</code> includes <code>vector.h</code> too.<br>
                    So we have 2 copies of <code>vector.h</code>.<br>
                    The struct <code>Vec</code> defined twice!!!<br>
                    <br>
                    We need to prevent files from being included more than once.<br>
                    Solution: <code>#inlucde</code> guard.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>// vec.h<br>
                        <span class="cline">02&nbsp;&nbsp;</span>#ifndef VEC_H // pick any unique symbol (suggest: based on file name)<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;#define VEC_H<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;... // file contents<br>
                        <span class="cline">05&nbsp;&nbsp;</span>#endif<br>
                    </code></pre>
                </span>
                <p>
                    First time <code>vec.h</code> is included.<br>
                    The symbol <code>VEC_H</code> is not defined, so the file is included it.<br>
                    After that, <code>VEC_H</code> is defined, so the contents of <code>vec.h</code> are suppressed.<br>
                    <strong>Always</strong> put <code>#include</code> guards in .h files!<br>
                    <strong>Never ever ever *100</strong> compile .h files and include .cc files.<br>
                    <strong>Never</strong> put <code>using namespace std;</code> in headers; this forces the client to open up the namespace, so always use the <code>std::</code> prefix in headers.<br>
                </p>
            </div>
            <hr> 
            
            <div class="lec8">
                <h3>Lecture 8 - 03/10/2017</h3>
                <hr>
                <p>Recall:<br></p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>Node *np = new Node();<br>
                        <span class="cline">02&nbsp;&nbsp;</span>...<br>
                        <span class="cline">03&nbsp;&nbsp;</span>delete np;<br>
                    </code></pre>
                </span>
                <p>
                    <br>
                    Or in array:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>int *p = new int [40]; // arry of 40 integers<br>
                        <span class="cline">02&nbsp;&nbsp;</span>delete [] p;<br>
                    </code></pre>
                </span>
                <p>The form of <code>new</code> must match the form of <code>delete</code>.<br></p>
                <b>Classes</b>
                <p>
                    We can put functions inside of structres.<br>
                    Example:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Student {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;int assn, mt, final;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;float grade {<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;return assn * 0.4 + mt * 0.2 + final * 0.4;<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;}<br>
                        <span class="cline">06&nbsp;&nbsp;</span>};<br>
                        <span class="cline">07&nbsp;&nbsp;</span>Student s{70, 80, 90};<br>
                        <span class="cline">08&nbsp;&nbsp;</span>cout &lt;&lt; s.grade() &lt;&lt; endl;<br>
                    </code></pre>
                </span>
                <p>
                    Class is the structure type that can contain functions.<br>
                    C++ has a <u>class</u> keyword (will use later).<br>
                    <br>
                    Object: an instance of a class<br>
                    <br>
                    The function <code>grade()</code> is called a <i>member function</i> (or <i>method</i>).<br>
                    <br>
                    What do <code>assn</code>, <code>mt</code> and <code>final</code> mean insider of <code>grade(){...}</code>?<br>
                    They are fields of the <u>current</u> object - the object upon which grade was invoked.<br>
                    <br>
                    Example:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>Student billy{...};<br>
                        <span class="cline">02&nbsp;&nbsp;</span>billy.grade(); // uses Billy's assn, mt and final<br>
                    </code></pre>
                </span>
                <p>
                    Formally, methods take a hidden extra parameter called <code>this</code>.<br>
                    <code>this</code>: pointer to the object on which the method was called<br>
                    Example: <code>billy.grade(); // this == &amp;billy</code><br>
                    So we can write as<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Student {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;...<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;float grade() {<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;return this-&gt;assn * 0.4 + this-&gt;mt * 0.2 + this-&gt; * 0.4;<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;}<br>
                        <span class="cline">06&nbsp;&nbsp;</span>};<br>
                    </code></pre>
                </span>
                <br>
                <b>Initialising Objects</b>
                <p>
                    <code>Student billy{60, 70, 80}; // this is okay, but limited</code><br>
                    The better way to do is have a method that does initialisation - a <u>constructor</u>.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Student {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;int assn, mt, final;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;float grade() {…}<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;Student(int assn, int mt, int final) {<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;assns = assns;<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;mt = mt;<br>
                        <span class="cline">07&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;final = final;<br>
                        <span class="cline">08&nbsp;&nbsp;</span>&nbsp;&nbsp;}<br>
                        <span class="cline">09&nbsp;&nbsp;</span>};<br>
                        <span class="cline">10&nbsp;&nbsp;</span>Student billy{60, 70, 80}; // better<br>
                    </code></pre>
                </span>
                <p>
                    If a constructor has been defined, these are passed as arguments to the constructor.<br>
                    It no constructor has been defined, tehse initialise the individual fields of <code>Student</code>.<br>
                    <br>
                    <code>Studnet billy = Student {60, 70, 80};</code><br>
                    Heap allocation: <code>Student *pbilly = new Student {60, 70, 80};</code><br>
                    <br>
                    Advantages of Constructor: (1) default parameters, (2) overloading and (3) sanity checks.<br>
                    <br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Student {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;...<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;Studnet(int assn = 0; int mt = 0; int final = 0) {<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;assn = assn;<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;// etc.<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;}<br>
                        <span class="cline">07&nbsp;&nbsp;</span>};<br>
                        <span class="cline">08&nbsp;&nbsp;</span>Student jane{60, 70}; // 60, 70, 0<br>
                        <span class="cline">09&nbsp;&nbsp;</span>Student newKid; // 0, 0, 0<br> 
                    </code></pre>
                </span>
                <p>
                    Note:<br>
                    Every class comes with a built-in default (i.e. no arguments) constructor.<br>
                    (It is ject a default, constructs all fields that are objects.)<br>
                    Example:<br>
                    <code>Vec v; // default constructor (does nothing in this case)</code><br>
                    <br>
                    But the built-in default constructor goes away if you provide a constructor.<br>
                    Example:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Vec {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;int x, y;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;Vec(int x, int y) {<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;x = x;<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;y = y;<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <span class="cline">07&nbsp;&nbsp;</span>};<br>
                        <span class="cline">08&nbsp;&nbsp;</span>Vec v; // Error, no default constructor<br>
                        <span class="cline">09&nbsp;&nbsp;</span>Vec v{1,2}; // this is okay<br>
                        <span class="cline">10&nbsp;&nbsp;</span><br>
                        <span class="cline">11&nbsp;&nbsp;</span>int x = 5; // work<br>
                        <span class="cline">12&nbsp;&nbsp;</span>int x{5}; // work<br>
                        <span class="cline">13&nbsp;&nbsp;</span>int x(5); // work<br>
                        <span class="cline">14&nbsp;&nbsp;</span>struct Vec v{1,2}; // work<br>
                        <span class="cline">15&nbsp;&nbsp;</span>string s = "Hello"; // work<br>
                        <span class="cline">16&nbsp;&nbsp;</span>string s{"Hello"}; // work<br>
                        <span class="cline">17&nbsp;&nbsp;</span>ifstream f("file.txt"); // work<br>
                        <span class="cline">18&nbsp;&nbsp;</span>ifstream f = "file.txt"; // you cannot do this<br>
                    </code></pre>
                </span>
                <p>
                    This <code>{}</code> is called "uniform initialisation". (99% work in C++!!!!)<br>
                    <br>
                    What if a structure contians constants or references?<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct myStruct{<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;const int myConst;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;int &amp;myRef;<br>
                        <span class="cline">04&nbsp;&nbsp;</span>};<br>
                    </code></pre>
                </span>
                <p>
                    The whole thing must be initialised. So initialise:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>int z;<br>
                        <span class="cline">02&nbsp;&nbsp;</span>struct myStruct {<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;const int myConst = 5;<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;int &amp;myRef = z;<br>
                        <span class="cline">05&nbsp;&nbsp;</span>};<br>
                    </code></pre>
                </span>
                <p>
                    This is not a full solution...<br>
                    But does <u>every</u> instance of <code>myStruct</code> need to have the <u>same</u> value of <code>myConst</code>, etc.?<br>
                    Example:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Student {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;const int id;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;// constant (doesn't change), but not the same for all students!<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;...<br>
                        <span class="cline">05&nbsp;&nbsp;</span>};<br>
                    </code></pre>
                </span>
                <p>
                    Where do we initialise?<br>
                    Constructor body? Too late, fields must be fully constructed by then.<br>
                    <br>
                    What happens when an object is created?<br>
                    1) Space is allocated<br>
                    2) Fields are constructed in declaration order<br>
                    3) Constructor body runs<br>
                    <br>
                    We need to put our initialisation in declaration. But How?<br>
                    <strong>Member Initialisation List (MIL)</strong>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Student {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;const int id;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;int assn, mt, final;<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;Student(int id, int assn, int mt, int final):<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id{id}, assn{assn}, mt{mt}, final{final} {<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;...<br>
                        <span class="cline">07&nbsp;&nbsp;</span>&nbsp;&nbsp;}<br>
                        <span class="cline">08&nbsp;&nbsp;</span>};<br>
                    </code></pre>
                </span>
                <p>
                    <code>id{id}, assn{assn}, mt{mt}, final{final}</code><br>
                    Each of them are <code>field{parameter}</code><br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Student {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;string name;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;Student(string name) {<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;name = name;<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;}<br>
                        <span class="cline">06&nbsp;&nbsp;</span>};<br>
                    </code></pre>
                </span>
                <p>
                    <code>name</code> is default.<br>
                    It constructed to step 2, then reassigned in step 3.<br>
                    <br>
                    <code> Student (string name): name{name} {}</code><br>
                    <code>this-&gt;name</code> is initialised to <code>name</code> in step 2.<br>
                    <br>
                    Note: fields are initialised <u>in the order in which they are declared in the class</u>, even if the MIL orders them differently.<br>
                    <br>
                    Embrace the MIL!<br>
                    What if a field is initialised inline AND in the MIL?<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Vec {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;int x = 0, y = 0;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;Vec(int x): x{x} {}<br>
                        <span class="cline">04&nbsp;&nbsp;</span>};<br>
                    </code></pre>
                </span>
                <p>
                    MIL takes precedence.<br>
                    <code>int x = 0, y = 0;</code> only happens if the field is not mentioned in the MIL.<br>
                    <br>
                    Now consider:<br>
                    <code>Student billy{60, 70, 80};</code><br>
                    <code>Student bilaal = billy;</code><br>
                    How does this initialisation happen?<br>
                    The <strong>copy constructor</strong>, for constructing one object as a copy of another.<br>
                    <br>
                    Note: Every class comes with...<br>
                </p>
                <ul>
                    <li>a default constructor (default - constructs all fields that are objects)</li>
                    <li>a copy constructor (just copies all fields)</li>
                    <li>a copy assignment operator</li>
                    <li>a move constructor</li>
                    <li>a move assignment operator</li>
                    <li>a destructor</li>
                </ul>
                <p>
                    <br>Writing your own copy constructor:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Student {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;...<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;Student (...) {...}<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;Student (const Student &amp;other):<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;assn{other.assn}, mt{other.mt}, final{other.final} {...}<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;// equiv. to built-in<br>
                        <span class="cline">06&nbsp;&nbsp;</span>};<br>
                    </code></pre>
                </span>
                <p>
                    <code>Student (const Student &amp;other)</code> must be by reference.<br>
                    <br>
                    When is the built-in copy constructor not correct?<br>
                    Consider:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Node {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;int data;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;Node *next;<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;...<br>
                        <span class="cline">05&nbsp;&nbsp;</span>};<br>
                    </code></pre>
                </span>
            </div>
            <hr>         
            
            <div class="lec9">
                <h3>Lecture 9 - 05/10/2017</h3>
                <hr>
                <p>What the built-in copy constructor is not correct?<br></p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Node {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;int data;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;Node *next;<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;Node(const Node &amp;other): data{other.data}, next{other.next} {}<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;Node(int data, Node *next): data{data}, next{next} {}<br>
                        <span class="cline">06&nbsp;&nbsp;</span>};<br>
                        <span class="cline">07&nbsp;&nbsp;</span>Node *n = new Node{1, nex Node{1, new Node{2, new Node{}, nullptr}}};<br>
                    </code></pre>
                </span>
                <img src="image/cs246/lec9/lec9_1.png" width="35%" height="35%">
                <p>
                    Simply copy of fields -&gt; only the first node is actually copied (<strong>shallow</strong> copy).<br>
                    If you want a <strong>deep</strong> copy (copies the whole list), must write you own copy constructor.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Node {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;...<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;Node(const Node &amp;other):<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;data{other.data}, next{other.next? new Node{*other.next}:nullptr} {}<br>
                        <span class="cline">05&nbsp;&nbsp;</span>};<br>
                    </code></pre>
                </span>
                <p>
                    <code>new Node{*other.next}</code> calls the copy constructor - Recursion!!!<br>
                    <br>
                    The copy constructor is called when...<br>
                    1) an object is initialised with another object<br>
                    2) an object is passed by value<br>
                    3) an object is returned  by a function<br>
                    P.S. There are exceptions to these (later!)<br>
                    <br>
                    <strong>Beware</strong> of copy constructor that can take <u>one</u> argument.<br>
                    Example:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Node {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;...<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;Node(int data): data{data}, next{nullptr} {}<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;...<br>
                        <span class="cline">05&nbsp;&nbsp;</span>};<br>
                    </code></pre>
                </span>
                <p>
                    Single-argument copy constructors create implicit conversions.<br>
                    Example: <code>Node n{4}; // [4|nullptr]</code><br>
                    But also <code>Node n = 4; // implicit conversion from integer to Node</code><br>
                    and <code>String s = "hello";</code> // implicit conversion from char* to string<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>int f(Node n) {...}<br>
                        <span class="cline">02&nbsp;&nbsp;</span>f(4); // this works, since 4 implicitly converted to Node<br>
                    </code></pre>
                </span>
                <p>
                    <strong>Danger!</strong><br>
                    Accidentally pass an integer to a function expecting a Node...<br>
                    1) silent conversion<br>
                    2) compiler does not signal an error<br>
                    3) potential error not caught<br>
                    <br>
                    Good Idea: disable the implicit conversion and make the copy constructor <code>ecplicit</code>.<br>
                    Example:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Node {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;...<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;explicit Node(int data): data{data}, next{nullptr} {}<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;...<br>
                        <span class="cline">05&nbsp;&nbsp;</span>};<br>
                        <span class="cline">06&nbsp;&nbsp;</span><br>
                        <span class="cline">07&nbsp;&nbsp;</span>// then...<br>
                        <span class="cline">08&nbsp;&nbsp;</span>Node n{4}; // okay<br>
                        <span class="cline">09&nbsp;&nbsp;</span>Node n = 4; // no<br>
                        <span class="cline">10&nbsp;&nbsp;</span>f(4); // no<br>
                        <span class="cline">11&nbsp;&nbsp;</span>f(Node{4}); // okay<br>
                    </code></pre>
                </span>
                <br>
                <b>Destructor</b>
                <p>	
                    When an object is destroyed...<br>
                    - stack-allocated: goes out of scope<br>
                    - heap-allocated: is deleted<br>
                    <br>
                    ... a method calls the <u>destructor</u> runs:<br>
                    1) destructor (dtor) body runs<br>
                    2) field's destructor are called in reverse declaration order<br>
                    3) Space deallocated<br>
                    Classes come with a destructor (just calls destructor for all fields that are objects).<br>
                    <br>
                    When do we need to write one?<br>
                    <code>Node *np = new Node{1, new Node{2, new Node{3, nullptr}}};</code><br>
                    If <code>np</code> goes out of scope...<br>
                    - the <u>pointer</u> is reclaimed (on the stack).<br>
                    - the <u>entire list</u> is leaked.<br>
                    If we say <code>delete np</code>...<br>
                    - calls <code>*np</code>'s destructor, which doesn't do anything.<br>
                </p>
                <img src="image/cs246/lec9/lec9_2.png" width="45%" height="45%">
                <p>
                    <br>
                    Write a destructor to ensure the whole list is freed:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Node {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;...<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;~Node() {delete next;}<br>
                        <span class="cline">04&nbsp;&nbsp;</span>};<br>
                    </code></pre>
                </span>
                <p>
                    <code>delete next;</code> recursively calls <code>*next</code>'s destructor, so whole list is freed.<br>
                    Now, <code>delete np;</code> frees the whole list.<br>
                </p>
                <br>
                <b>Copy Assignment Operator</b>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>Student billy{60, 70, 80};<br>
                        <span class="cline">02&nbsp;&nbsp;</span>Student bilaal = billy; // copy constructor<br>
                        <span class="cline">03&nbsp;&nbsp;</span>Student frost; // default constructor {0, 0, 0}<br>
                        <span class="cline">04&nbsp;&nbsp;</span>frost = billy; // copy, but not constructor<br>
                    </code></pre>
                </span>
                <p>
                    In line 4, this is the copy assignment operator.<br>
                    It uses compiler-supplied default (shallow).<br>
                    <br>
                    You may need to write your own one:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Node {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;...<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;Node &amp;operator=(const Node &amp;other) {<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;data = oter.data;<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;next = other.next? new Node{*other.next}:nullptr;<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;return *this;<br>
                        <span class="cline">07&nbsp;&nbsp;</span>&nbsp;&nbsp;}<br>
                        <span class="cline">08&nbsp;&nbsp;</span>};<br>
                    </code></pre>
                </span>
                <p>
                    This is DANGEROUS!!!!<br>
                    Using <code>Node &amp;</code>: so that cascading works.<br>
                    But why the structure is dangerous?<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>Node n{1, new Node{2, new Node{3, nullptr}}};<br>
                        <span class="cline">02&nbsp;&nbsp;</span>n = n;<br>
                    </code></pre>
                </span>
                <p>
                    Deletes <code>n</code> and then tries to copy <code>n</code> to <code>n</code>?<br>
                    This is undefined behaviour!<br>
                    <br>
                    Other examples for using copy assignment operator:<br>
                    <code>*p = *q;</code> and <code>a[i] = a[j];</code><br>
                    <br>
                    When writing <code>operator=</code>, ALWAYS make sure it works for self-assignment:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Node {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;...<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;Node &amp;operator=(const Node &amp;other) {<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;if (this == &amp;other) return *this;<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;data = other.data;<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;delete next;<br>
                        <span class="cline">07&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;next = other.next? new Node {*other.next}:nullptr;<br>
                        <span class="cline">08&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;return *this;<br>
                        <span class="cline">09&nbsp;&nbsp;</span>&nbsp;&nbsp;}<br>
                        <span class="cline">10&nbsp;&nbsp;</span>};<br>
                    </code></pre>
                </span>
                <p>
                    If the <code>new</code> in line 7 fail, this function will fail out.<br>
                    - deleted successor nudes, but <code>next</code> still points at them<br>
                    &nbsp;- dangling pointer<br>
                </p>
            </div>
            <hr>  
            
            <div class="lec10">
                <h3>Lecture 10 - 12/10/2017</h3>
                <hr>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Node {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;...<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;Node &amp;operator=(const Node &amp;other) {<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;if (this == &amp;other) return *this;<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;data = next.data;<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;next = other.next? new Node {*other.next}:nullptr;<br>
                        <span class="cline">07&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;delete next;<br>
                        <span class="cline">08&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;return *this;<br>
                        <span class="cline">09&nbsp;&nbsp;</span>&nbsp;&nbsp;}<br>
                        <span class="cline">10&nbsp;&nbsp;</span>};<br>
                    </code></pre>
                </span>
                <p>
                    If the <code>new</code> in line 6 fail, function will abort.<br>
                    The <code>next</code> points at deleted data corrupted list.<br>
                    <br>
                    A better way to do is...<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Node {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;...<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;Node &amp;operator=(const Node &amp;other) {<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;if (this == &amp;other) return *this;<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;Node *tmp = next;<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;data = other.data;<br>
                        <span class="cline">07&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;next = other.next? new Node {*other.next}:nullptr;<br>
                        <span class="cline">08&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;delete tmp;<br>
                        <span class="cline">09&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;return *this;<br>
                        <span class="cline">10&nbsp;&nbsp;</span>&nbsp;&nbsp;}<br>
                        <span class="cline">11&nbsp;&nbsp;</span>};<br>
                    </code></pre>
                </span>
                <p>
                    If the <code>new</code> in line 7 fail, the Node will still be in a valid state.<br>
                </p>
                <br>
                <b>Alternative: Copy and Swap Idiom</b>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>#include &lt;utility&gt;<br>
                        <span class="cline">02&nbsp;&nbsp;</span>struct Node {<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;...<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;void swap(Node &amp;other) {<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;using std::swap;<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;swap(data, other.data);<br>
                        <span class="cline">07&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;swap(next, other.next);<br>
                        <span class="cline">08&nbsp;&nbsp;</span>&nbsp;&nbsp;}<br>
                        <span class="cline">09&nbsp;&nbsp;</span>&nbsp;&nbsp;Node &amp;operator=(const Node &amp;other) {<br>
                        <span class="cline">10&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;Node tmp = other;<br>
                        <span class="cline">11&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;swap(tmp);<br>
                        <span class="cline">12&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;return *this;<br>
                        <span class="cline">13&nbsp;&nbsp;</span>&nbsp;&nbsp;}<br>
                        <span class="cline">14&nbsp;&nbsp;</span>};<br>
                    </code></pre>
                </span>
                <p>
                    Notice:<br>
                    The <code>operator=</code> is a member function, not a Standalone function.<br>
                    When an operator is declared as a member function, <code>*this</code> plays the role of the first operand.<br>
                    Example:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Vec {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;int x, y;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;Vec operator+(const Vec &amp;other) {<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;return {x + other.x, y + other.y};<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;}<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;Vec operator*(const int k) { // this is v * k<br>
                        <span class="cline">07&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;return {x * k, y * k};<br>
                        <span class="cline">08&nbsp;&nbsp;</span>&nbsp;&nbsp;}<br>
                        <span class="cline">09&nbsp;&nbsp;</span>};<br>
                    </code></pre>
                </span>
                <p>
                    How would we implement <i>k*v</i>?<br>
                    You can't do it as a member function.<br>
                    The first argument no a <code>Vec</code>! It must be standalone:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>Vec operator*(const int k, const Vec &amp;v) {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;return v * k;<br>
                        <span class="cline">013&nbsp;&nbsp;</span>}<br>
                    </code></pre>
                </span>
                <p>
                    <br>
                    What about I/O operators?<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Vec {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;...<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;ostream&amp; operator&lt;&lt;(ostream &amp;out) {<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;return out &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y;<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;}<br>
                        <span class="cline">06&nbsp;&nbsp;</span>};<br>
                    </code></pre>
                </span>
                <p>
                    What is wrong with this?<br>
                    It makes <code>Vec</code> the LHS operand, not the RHS.<br>
                    So we need to do <code>v &lt;&lt; cout;</code>. This is so confusing!!!<br>
                    So we need to write the <code>operator&lt;&lt;</code> and <code>operator&gt;&gt;</code> as standalone functions.<br>
                    <br>
                    Certain operators <u>must</u> be members:<br>
                    1) <code>operator=</code><br>
                    2) <code>operator[]</code><br>
                    3) <code>operator-&gt;</code><br>
                    4) <code>operator()</code><br>
                    5) <code>operatorT</code> where <code>T</code> is a type<br>
                </p>
                <br>
                <b>Separate Compilation for Classes</b>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>// Node.h <br>
                        <span class="cline">02&nbsp;&nbsp;</span>#ifnder NODE_H<br>
                        <span class="cline">03&nbsp;&nbsp;</span>#define NODE_H<br>
                        <span class="cline">04&nbsp;&nbsp;</span>struct Node {<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;int data;<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;Node *next;<br>
                        <span class="cline">07&nbsp;&nbsp;</span>&nbsp;&nbsp;explicit Node(int data, Node *next = nullptr);<br>
                        <span class="cline">08&nbsp;&nbsp;</span>&nbsp;&nbsp;bool isSingleton();<br>
                        <span class="cline">09&nbsp;&nbsp;</span>};<br>
                        <span class="cline">10&nbsp;&nbsp;</span>#endif<br>
                        <span class="cline">11&nbsp;&nbsp;</span><br>
                        <span class="cline">12&nbsp;&nbsp;</span>// Node.cc<br>
                        <span class="cline">13&nbsp;&nbsp;</span>#include "Node.h"<br>
                        <span class="cline">14&nbsp;&nbsp;</span>Node::Node(int data, Node *next): data{data}, next{next} {}<br>
                        <span class="cline">15&nbsp;&nbsp;</span>bool Node::isSingleton() {return next == nullptr;}<br>
                    </code></pre>
                </span>
                <p>
                    <code>::</code> is called <u>scope resolution operator</u>.<br>
                    <code>Node::______</code> means <code>______</code> in the context of <code>struct Node</code>.<br>
                    <code>::</code> is like <code>.</code> where LHS is a class (or namespace, not an object.<br>
                </p>
                <br>
                <b>Constant Objects</b>
                <p>
                    <code>int f (const Node &amp;n) {...}</code><br>
                    Constatn objects arise often, especially as parameters.<br>
                    <br>
                    So, what is a constant object?<br>
                    The fields cannot be modified.<br>
                    <br>
                    Can we call methods on a constant object?<br>
                    Issue: the method may change fields, violate constant.<br>
                    Answer: Yes, we can call methods that <u>promise</u> not to modify fields.<br>
                    Example:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Student {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;int assn, mt, final;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;float grade() const; // doesn't modify fields, so declare the method const<br>
                        <span class="cline">04&nbsp;&nbsp;</span>};<br>
                        <span class="cline">05&nbsp;&nbsp;</span>...<br>
                        <span class="cline">06&nbsp;&nbsp;</span>float Student::grade() const {...}<br>
                    </code></pre>
                </span>
                <p>
                    Compiler will check that constant methods don't modify fields.<br>
                    Only constant methods can be called on constant objects.<br>
                </p>
                <br>
                <b>Rvalues and Rvalue References</b>
                <p>
                    Reacll:<br>
                    An lvalue is anything with an address.<br>
                    An lvalue reference (<code>&amp;</code>) is like a constant pointer with auto-dereference.<br>
                    We need to always initialised an lvalue reference to an lvalue.<br>
                    <br>
                    Now consider:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>Node n{1, new Node {2, nullptr}};<br>
                        <span class="cline">02&nbsp;&nbsp;</span>Node m = n;  // copy constructor<br>
                        <span class="cline">03&nbsp;&nbsp;</span>Node m2;<br>
                        <span class="cline">04&nbsp;&nbsp;</span>m2 = n; // copy assignment<br>
                        <span class="cline">05&nbsp;&nbsp;</span><br>
                        <span class="cline">06&nbsp;&nbsp;</span>Node pulsOne(Node n) {<br>
                        <span class="cline">07&nbsp;&nbsp;</span>&nbsp;&nbsp;for (Node *p = &amp;n; p; p = p-&gt;next) {<br>
                        <span class="cline">08&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;++p-&gt;data;<br>
                        <span class="cline">09&nbsp;&nbsp;</span>&nbsp;&nbsp;}<br>
                        <span class="cline">10&nbsp;&nbsp;</span>&nbsp;&nbsp;return n;<br>
                        <span class="cline">11&nbsp;&nbsp;</span>}<br>
                        <span class="cline">12&nbsp;&nbsp;</span><br>
                        <span class="cline">13&nbsp;&nbsp;</span>Node m3 = plusOne(n); // copy constructor<br>
                    </code></pre>
                </span>
                <p>
                    In line 13, what is "other" for <code>plusOne(n)</code>?<br>
                    A reference.<br>
                    Reference to what?<br>
                    Compiler creates a <u>temporary object</u> to hold the result of <code>pulsOne</code>.<br>
                    So "other" is a reference to this temporary.<br>
                    Copy constructor deep-copies the data from the temporary.<br>
                    <br>
                    But...<br>
                    The temporary is just going to be discarded anyway, as soon as the statement <code>Node m3 = plusOne(n);</code> is done.<br>
                    It is wasteful to have to copy the data from the temporary. Why not just steal it instead? Then it will save the cost of a copy.<br>
                    We need to be able to tell whether other is a reference to a temporary object or a standalone object.<br>
                    <br>
                    C++:
                    rvalue reference <code>Node&amp;&amp;</code> is a reference to a <u>temporary</u> object (rvale) of bype Node.<br>
                    <br>
                    Version of the copy constructor that takes a <code>Node&amp;&amp;</code>:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Node {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;...<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;Node(Node &amp;&amp;other): data{other.data}, next{other.next} {<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;other.next = nullptr;<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;}<br>
                        <span class="cline">06&nbsp;&nbsp;</span>};<br>
                    </code></pre>
                </span>
                <p>
                    The <code>Node &amp;&amp;other</code> in line 3 is called a <u>move constructor</u>.<br>
                    Move Constructor: steal other's data<br>
                </p>
            </div>
            <hr>         
            
            <div class="lec11">
                <h3>Lecture 11 - 17/10/2017</h3>
                <hr>
                <p>Recall:</p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Node {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;...<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;Node(Node &amp;&amp;other): data{other.data}, next{other.next} {<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;other.next = nullptr;<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;}<br>
                        <span class="cline">06&nbsp;&nbsp;</span>};<br>
                    </code></pre>
                </span>
                <p>Similarly:</p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>// the example for move constructor<br>
                        <span class="cline">02&nbsp;&nbsp;</span>Node m;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>m = plusOne(n); // assignment from temporary<br>
                        <span class="cline">04&nbsp;&nbsp;</span><br>
                        <span class="cline">05&nbsp;&nbsp;</span>// Move assignment operator<br>
                        <span class="cline">06&nbsp;&nbsp;</span>struct Node {<br>
                        <span class="cline">07&nbsp;&nbsp;</span>&nbsp;&nbsp;...<br>
                        <span class="cline">08&nbsp;&nbsp;</span>&nbsp;&nbsp;Node&amp; operator=(Node &amp;&amp;other) {<br>
                        <span class="cline">09&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;//idea: steal other's data and destroy my old data<br>
                        <span class="cline">10&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;//easy way: swap without copy<br>
                        <span class="cline">11&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;using std::swap;<br>
                        <span class="cline">12&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;swap(data, other.data);<br>
                        <span class="cline">13&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;swap(next, other.next);<br>
                        <span class="cline">14&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;return *this;<br>
                        <span class="cline">15&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;// the temporary will be destroyed and take out old data with it<br>
                        <span class="cline">16&nbsp;&nbsp;</span>&nbsp;&nbsp;}<br>
                        <span class="cline">17&nbsp;&nbsp;</span>};<br>
                    </code></pre>
                </span>
                <p>
                    If you don't define move  constructor/assignment operations, the copy versions will be used.<br>
                    If the move ctor/assignment is defined, it will replace all calls to the copy  constructor/assignment when the argument "other" is a temporary (rvalue).<br>
                    <br>
                    Copy/Move Elision:
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>Vec makeAVec() {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;return {0,0}; // invokes Vec's basic  constructor<br>
                        <span class="cline">03&nbsp;&nbsp;</span>}<br>
                        <span class="cline">04&nbsp;&nbsp;</span>Vec v = makeAVec(); // What runs?<br>
                    </code></pre>
                </span>
                <p>
                    What will run in line 4?<br>
                    Copy constructor? If no move constructor.<br>
                    Move constructor? If there exist move constructor.<br>
                    Let's check in <code>g++</code>.<br>
                    Just the basic ctor runs - not copy constructor, not move constructor.<br>
                    <br>
                    In some circumstances, the compiler is allowed to skip calling copy/move constructors (but doesn't have to).<br>
                    <br>
                    In the example above:<br>
                    <code>makeAVec()</code> writes its result(<code>{0,0}</code>) directly into the space occupied by <code>v</code> in the caller, rather than copy it later.<br>
                    <br>
                    Example:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>void doSth(Vec v) {...} // pass-by-value: copy or move ctor<br>
                        <span class="cline">02&nbsp;&nbsp;</span>doSth(makeAVec());<br>
                        <span class="cline">03&nbsp;&nbsp;</span>// result of makeAVec() has written directly into the parameter - no copy/move<br>
                    </code></pre>
                </span>
                <p>
                    This code above is allowed, even if dropping ctor calls would change the behaviour of the program.<br>
                    Example: if the constructors print something<br>
                    <br>
                    You are not expected to know exactly when copy/move elision is allowed - just that it is possible.<br>
                    <br>
                    It you need all of the cconstructors to run: <code>g++ -fno-elid-constructors file.cc</code><br>
                    But this can slow down your program considerably.<br>
                    <br>
                    In summary: the Rule of 5 (or "Big 5")<br>
                    If you need to customise any one of<br>
                </p>
                <ol>
                    <li>copy constructor (copy ctor)</li>
                    <li>copy assignment</li>
                    <li>destructor (dtor)</li>
                    <li>move constructor (move ctor)</li>
                    <li>move assignment</li>
                </ol>
                <p>
                    then you usually need to customise all 5.<br>
                    <br>
                    Arrays of Objects:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Vec {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;int x, y;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;Vec(int x, int y): x{x}, y{y} {}<br>
                        <span class="cline">04&nbsp;&nbsp;</span>};<br>
                        <span class="cline">05&nbsp;&nbsp;</span>Vec *vp = new Vec[15];<br>
                        <span class="cline">06&nbsp;&nbsp;</span>Vec moveVectors[10];<br>
                    </code></pre>
                </span>
                <p>
                    Both of line 5 and 6 will not compile.<br>
                    These want to call the default constructor on each item.<br>
                    If there is no default ctor, then error!<br>
                    <br>
                    Options:<br>
                </p>
                <ol>
                    <li>Provide a default constructor.</li>
                    <li>
                        For stack arrays: <code>Vec moreVectors[] = {Vec{0,0}, Vec{1,3}, Vec{2,4}};</code><br>
                        This is allowed.<br>
                    </li>
                    <li>For heap arrays, create an array of pointer.</li>
                </ol>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>Vec **vp = new Vec*[5];<br>
                        <span class="cline">02&nbsp;&nbsp;</span>vp[0] = new Vec{0,0};<br>
                        <span class="cline">03&nbsp;&nbsp;</span>vp[1] = new Vec{1,3}; <br>
                        <span class="cline">04&nbsp;&nbsp;</span>// etc.<br>
                        <span class="cline">05&nbsp;&nbsp;</span>for (int i = 0; i &gt; 5; i++) {<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;delete vp[i];<br>
                        <span class="cline">07&nbsp;&nbsp;</span>}<br>
                        <span class="cline">08&nbsp;&nbsp;</span>delete [] vp;<br>
                    </code></pre>
                </span>
                <br>
                <b>Invariants and Encapsulation</b>
                <p>
                    Consider:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Node {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;int data;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;Node *next;<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;Node(int data, Node *next): data{data}, next{next} {}<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;…<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;~Node () {delete next;}<br>
                        <span class="cline">07&nbsp;&nbsp;</span>};<br>
                        <span class="cline">08&nbsp;&nbsp;</span>Node n1{1, new Node{2, nullptr}}; // on stack, next on heap<br>
                        <span class="cline">09&nbsp;&nbsp;</span>Node n2{3,nullptr};  // on stack<br>
                        <span class="cline">10&nbsp;&nbsp;</span>Node n3{4, &amp;n2};  // on stack<br>
                    </code></pre>
                </span>
                <p>
                    What happens when these go out of scope?<br>
                    <code>n1</code> - dtor runs, entire lies is deleted. OK.<br>
                    <code>n2</code>, <code>n3</code> go out of scope - <code>n3</code>'s dtor tries to delete <code>n2</code>, but <code>n2</code> is not on the heap; <code>n2</code> is on the stack!<br>
                    This is undefined behaviour!<br>
                    You can't call <code>delete</code> for stack (only heap)!<br>
                    The class <code>Node</code> relies on an assumption for its proper operation - that <code>next</code> is either <code>nullptr</code>, or is a valid pointer to the heap, allocated by <code>new</code>.<br>
                    <br>
                    This is an <u>invariant</u>.<br>
                    Statement that holds true that <code>next</code> is either null pointer or pointer to memory allocated by <code>new</code>, upon which <code>Node</code> relies.<br>
                    But we can't guarantee the invariant.<br>
                    We can't trust the user to use <code>Node</code> property.<br>
                    Right now, we can't enforce <i>any</i> incariants since the user can interfere with our data.<br>
                    <br>
                    Example - Stack<br>
                    Invariant: last item pushed is the first item popped.<br>
                    But not if the client can rearrange the underlying data.<br>
                    To enforce invariants, we introduce <i>encapsulation</i>.<br>
                    We want clinets to treat objects as black boxes - <u>capsules</u>.<br>
                </p>
                <ul>
                    <li>implementation details sealed away</li>
                    <li>can only interact via provided methods</li>
                    <li>
                        creates an abstraction<br>
                        <ul>
                            <li>regains control over the object</li>
                        </ul>
                    </li>
                </ul>
                <p>
                    Example:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Vec {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;Vec(int x, int y);<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;private:<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;int x, y;<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;public:<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;Vec &amp;operator+(const Vec &amp;other);<br>
                        <span class="cline">07&nbsp;&nbsp;</span>&nbsp;&nbsp;...<br>
                        <span class="cline">08&nbsp;&nbsp;</span>};<br>
                    </code></pre>
                </span>
                <p>
                    Anything in <code>private</code> is private, can't be accessed outside the struct.<br>
                    Anything in <code>public</code> - anyone can assess.<br>
                    By default, <code>Vec (int x, int y);</code> is public.<br>
                    <br>
                    Default visibility in structs - public.<br>
                    In general, we want fields to be private; only methods should be public.<br>
                    Better to have default visibility - private.<br>
                    <br>
                    Now, it is time to switch from <code>struct</code> to <code>class</code>.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>class Vec {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;int x, y;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;public:<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;Vec(int x, int y);<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;Vec&amp; operator+(const Vec &amp;other);<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;...<br>
                        <span class="cline">07&nbsp;&nbsp;</span>};<br>
                    </code></pre>
                </span>
                <p>
                    The difference between <code>class</code> and <code>struct</code> is default visibility: public in <code>struct</code> and private in <code>class</code>.<br>
                </p>
            </div>
            <hr>  
            
            <div class="lec12">
                <h3>Lecture 12 - 19/10/2017</h3>
                <hr>
                <p>Fix the linked list class:</p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>// list.h<br>
                        <span class="cline">02&nbsp;&nbsp;</span>class List {<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;struct Node; // private nested class<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;Node *theList = nullptr; // only accessible inside class list<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;public:<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;void addToFront(int n);<br>
                        <span class="cline">07&nbsp;&nbsp;</span>&nbsp;&nbsp;int ith(int i);<br>
                        <span class="cline">08&nbsp;&nbsp;</span>&nbsp;&nbsp;~List();<br>
                        <span class="cline">09&nbsp;&nbsp;</span>&nbsp;&nbsp;...<br>
                        <span class="cline">10&nbsp;&nbsp;</span>};<br>
                        <span class="cline">11&nbsp;&nbsp;</span><br>
                        <span class="cline">12&nbsp;&nbsp;</span>// list.cc<br>
                        <span class="cline">13&nbsp;&nbsp;</span>struct List::Node {<br>
                        <span class="cline">14&nbsp;&nbsp;</span>&nbsp;&nbsp;int data;<br>
                        <span class="cline">15&nbsp;&nbsp;</span>&nbsp;&nbsp;Node *next;<br>
                        <span class="cline">16&nbsp;&nbsp;</span>&nbsp;&nbsp;Node(int data, Node *next): ... {}<br>
                        <span class="cline">17&nbsp;&nbsp;</span>&nbsp;&nbsp;~Node {delete next;}<br>
                        <span class="cline">18&nbsp;&nbsp;</span>&nbsp;&nbsp;...<br>
                        <span class="cline">19&nbsp;&nbsp;</span>};<br>
                        <span class="cline">20&nbsp;&nbsp;</span><br>
                        <span class="cline">21&nbsp;&nbsp;</span>void List::addToFront(int n) {<br>
                        <span class="cline">22&nbsp;&nbsp;</span>&nbsp;&nbsp;theList = new Node{n, theList};<br>
                        <span class="cline">23&nbsp;&nbsp;</span>}<br>
                        <span class="cline">24&nbsp;&nbsp;</span><br>
                        <span class="cline">25&nbsp;&nbsp;</span>int List::ith(int i) {<br>
                        <span class="cline">26&nbsp;&nbsp;</span>&nbsp;&nbsp;node *curr;<br>
                        <span class="cline">27&nbsp;&nbsp;</span>&nbsp;&nbsp;for (int j = 0; j &lt; i, j++) {<br>
                        <span class="cline">28&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;curr = curr-&gt;next;<br>
                        <span class="cline">29&nbsp;&nbsp;</span>&nbsp;&nbsp;}<br>
                        <span class="cline">30&nbsp;&nbsp;</span>&nbsp;&nbsp;return curr-&gt;data;<br>
                        <span class="cline">31&nbsp;&nbsp;</span>}<br>
                        <span class="cline">32&nbsp;&nbsp;</span><br>
                        <span class="cline">22&nbsp;&nbsp;</span>List::~List() {delete theList;}<br>
                    </code></pre>
                </span>
                <p>
                    Note that only <code>List</code> can create/manipulate <code>Node</code> object.<br>
                    It's because we need to gurentee the invariant that <code>next</code> is always <code>nullptr</code> or heap pointer.<br>
                    But now, we can't traverse the list from node to node as we would want in a linked list.<br>
                    Repeatedly calling <code>ith()</code> to access the whole list needs O(n<sup>2</sup>) time.<br>
                    However, we can't expose the nodes or we lose encapsulation.<br>
                </p>
                <br>
                <div class="specialTalk">
                    <h4 class="title">Software Engineering Topic: Design Pattern</h4>
                    <ul>
                        <li>certain problems/scenarios arise frequently</li>
                        <li>keep track of good solutions to these problems</li>
                        <li>Design Pattern: If you have a situation like this, the technique may solve the problem.</li>
                    </ul>
                </div>
                <br>
                <p>
                    Solution: Iterator Pattern
                </p>
                <ul>
                    <li>
                        create a class theat manages access to node
                        <ul>
                            <li>abstraction of a pointer</li>
                            <li>walk the list without exposing the actual pointers</li>
                        </ul>
                    </li>
                </ul>

                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>// Inspiration: C<br>
                        <span class="cline">02&nbsp;&nbsp;</span>for (int *p = a; p != (a+n); p++) {<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;cout &lt;&lt; *p &lt;&lt; endl;<br>
                        <span class="cline">04&nbsp;&nbsp;</span>}<br>
                        <span class="cline">05&nbsp;&nbsp;</span><br>
                        <span class="cline">06&nbsp;&nbsp;</span>class List {<br>
                        <span class="cline">07&nbsp;&nbsp;</span>&nbsp;&nbsp;struct Node;<br>
                        <span class="cline">08&nbsp;&nbsp;</span>&nbsp;&nbsp;Node *theList;<br>
                        <span class="cline">09&nbsp;&nbsp;</span>&nbsp;public:<br>
                        <span class="cline">10&nbsp;&nbsp;</span>&nbsp;&nbsp;class Iterator {<br>
                        <span class="cline">11&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;Node *p;<br>
                        <span class="cline">12&nbsp;&nbsp;</span>&nbsp;&nbsp;public:<br>
                        <span class="cline">13&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;explicit Iterator(Node *p): p{p} {}<br>
                        <span class="cline">14&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;int &amp;operator* (){return p-&gt;data;}<br>
                        <span class="cline">15&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;Iterator &amp;operator++() {<br>
                        <span class="cline">16&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p = p-&gt;next;<br>
                        <span class="cline">17&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return *this;<br>
                        <span class="cline">18&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <span class="cline">19&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;bool &amp;operator!=(const Iterator &amp;other) const {<br>
                        <span class="cline">20&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return p != other.p;<br>
                        <span class="cline">21&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                        <span class="cline">22&nbsp;&nbsp;</span>&nbsp;&nbsp;}; // end Iterator<br>
                        <span class="cline">23&nbsp;&nbsp;</span>&nbsp;&nbsp;Iterator begin() {return Iterator{theList};}<br>
                        <span class="cline">24&nbsp;&nbsp;</span>&nbsp;&nbsp;Iterator end() {return Iterator{nullptr};}<br>
                        <span class="cline">25&nbsp;&nbsp;</span>}; // end List<br>
                    </code></pre>
                </span>
                <p>
                    In line 14, the method <code>&amp;operator* ()</code> returns by reference.<br>
                    The result is not a copy; it can mutate list items.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>// client<br>
                        <span class="cline">02&nbsp;&nbsp;</span>int main() {<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;List l;<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;l.addToFront(1);<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;l.addToFront(2);<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;l.addToFront(3);<br>
                        <span class="cline">07&nbsp;&nbsp;</span>&nbsp;&nbsp;for (List::Iterator it = l.begin(); it != l.end(); ++it) {<br>
                        <span class="cline">08&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; *it &lt;&lt; endl;<br>
                        <span class="cline">09&nbsp;&nbsp;</span>&nbsp;&nbsp;}<br>
                        <span class="cline">10&nbsp;&nbsp;</span>}<br>
                    </code></pre>
                </span>
                <p>
                    There is a shortcut: automatic type deduction - <code>auto x = y;</code>
                    The keyword <code>auto</code> automatically give <code>x</code> the same type as its initializer <code>y</code>.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>for (auto it = l.begin(); it != l.end(); ++it) {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;cout &lt;&lt; *it &lt;&lt; endl;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>}<br>
                    </code></pre>
                </span>
                <p>
                    Now, the shorter-cut way: range-based for loop. 
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>for (auto n:l) { // n is the thing in the list<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;cout &lt;&lt; n &lt;&lt; endl;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>}<br>
                    </code></pre>
                </span>
                <p>
                    In line 1, <code>n</code> will copy of list item.<br>
                    The <code>for</code> statement can mutate <code>n</code>, but <code>l</code> will not be mutated.<br>
                    <br>
                    The keyword <code>auto</code> is available for any class with method <code>begin()</code> and <code>end()</code> that produce iterators, and the iterator type must support unary <code>*</code>, <code>!=</code> and prefix <code>++</code>.<br>
                    <br>
                    If you want to modify list items (or save copying), do the following:
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>for (auto &amp;n:l) {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;cout &lt;&lt; n &lt;&lt; endl;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;++n; // it will mutate list items<br>
                        <span class="cline">04&nbsp;&nbsp;</span>}<br>
                    </code></pre>
                </span>
                <br>
                <b>Encapsulation (continue)</b>
                <p>
                    <code>List</code> clinet can create iterators directly!<br>
                    <code>auto it = List::Iterator(nullptr);</code><br>
                    This violates encapsulation, the clinet should be using <code>begin()</code> or <code>end()</code>.<br>
                    We could make Iterator's constructor private.<br>
                    Then client can't call <code>List::Iterator()</code>, but then neither can List.<br>
                    <br>
                    Solution: Give list privileged access to Iterator, using the keyword <code>friend</code>.<br>	
                </p>

                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>class Listb{<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;...<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;public:<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;class Iterator {<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;Node *p;<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;explicit Iterator (Node *p);<br>
                        <span class="cline">07&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;public:<br>
                        <span class="cline">08&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;...<br>
                        <span class="cline">09&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;friend class List;<br>
                        <span class="cline">10&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;;...<br>
                        <span class="cline">11&nbsp;&nbsp;</span>&nbsp;&nbsp;};<br>
                        <span class="cline">12&nbsp;&nbsp;</span>&nbsp;&nbsp;...<br>
                        <span class="cline">13&nbsp;&nbsp;</span>};<br>
                    </code></pre>
                </span>
                <p>
                    The keyword <code>friend</code> in line 9, has access to all members of Iterator.<br>
                    <br>
                    Now list can still create iterators, but client can only create iterators by calling <code>begin()</code> or <code>end()</code>.<br>
                    <br>
                    Notice that give your classes as few <code>friend</code>s as possible - weakness encapsulation.<br>
                    Oce again, keep fields private.<br>
                    What if you want to provide access to fields?<br>
                    Create accessor/mutator methods.<br>
                </p>

                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>class Vec{<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;int x, y;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;public:<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;...<br>
                        <span class="cline">05&nbsp;&nbsp;</span>&nbsp;&nbsp;int getX() const {return x;} // accessor<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;void setY(int z) {y = z;} // mutator<br>
                        <span class="cline">07&nbsp;&nbsp;</span>};<br>
                    </code></pre>
                </span>
                <br>
                <h4 class="title">Module 3 - C++ (Part 2) and Introduction to OOP</h4>
                <h5 class="title">The End</h5>
            </div>
            <hr>         
            
            
            <table width="100%">
                <tr>
                    <td width="45%"><a href="./cs246_2.html">&larr; Go to Module 2 - C++ (Part 1)</a></td>
                    <td width="10%" align="centre"><a href="./cs246.html">&uarr; Go to Index</a></td>
                    <td width="45%" align="right"><a href="./cs246_4.html">&rarr; Go to Module 4 - C++ (Part 3), UML and Design Pattern&nbsp;</a></td>
                </tr>
            </table>
            
            
            <div class="footer">
                <p>Thanks For Coming Here. - Calvin Li</p>
                <a href = "mailto: ck6li@edu.uwaterloo.ca" target = "_blank;">
                    <i class = "fa fa-envelope-square"></i>
                </a>
                <a href = "https://www.linkedin.com/in/vertckli/" target = "_blank;">
                    <i class = "fa fa-linkedin-square"></i>
                </a>       
                <a href = "https://www.instagram.com/vert_arts/" target = "_blank;">
                    <i class="fa fa-instagram"></i>
                </a>
                <a href = "https://github.com/vertli" target = "_blank;">
                    <i class="fa fa-github-square"></i>
                </a>
                <br>
                <p>Chun Kit (Calvin) Li &copy; 2017</p>
                <br>
            </div>
        </div>
        
        <script src="https://code.jquery.com/jquery-2.1.4.js"></script>
        <script src="./bootstrap-3.3.7-dist/js/bootstrap.js"></script>
    </body>
    
</html>