<!DOCTYPE html>

<html>

    <head>
        <meta charset="utf-8">
        <title>Calvin Li</title>
        <link rel="stylesheet" href="./bootstrap-3.3.7-dist/css/bootstrap.css">
        <link rel="stylesheet" href="./note.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:400,800" rel="stylesheet">
        <link rel='stylesheet' href='//cdn.jsdelivr.net/npm/hack-font/build/web/hack.css'> <!-- HACK!!! -->
        <!-- stylesheet found from w3school. (icon use)-->
        <link rel = "stylesheet" href = "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    </head>
    
    <body>
        <nav class="navbar navbar-inverse navbar-fixed-top">
            <div class="container-fluid">
                <!-- Brand and toggle get grouped for better mobile display -->
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#topNavbar" aria-expanded="false">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="./index.html">Calvin Li</a>
                </div>

                <!-- Collect the nav links, forms, and other content for toggling -->
                <div class="collapse navbar-collapse" id="topNavbar">
                    <ul class="nav navbar-nav">
                        <li><a href="./doc/NewResume_CKLI.pdf" target="_blank;">Résumé</a></li>
                    </ul>
                    <ul class="nav navbar-nav navbar-right">
                        <li><a href="./about.html">About</a></li>
                        <li><a href="./projects.html">Projects</a></li>
                        <li class="courseNote">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Course Notes<span class="caret"></span></a>
                            <ul class="dropdown-menu">
                                <li><a href="./cs246.html">CS 246</a></li>
                            </ul>
                        </li>
                    </ul>
                </div><!-- /.navbar-collapse -->
            </div><!-- /.container-fluid -->
        </nav>
        <br><br>
        <div class="container">
            <br>
            <table class="header">
                <tr>
                    <td colspan="100%">
                        <h1 class="title">CS 246 - Object-Oriented Development</h1>
                    </td>
                </tr>
                <tr>
                    <td colspan="5%">
                        <span class="headerLeft">Instructor:</span>
                    </td>
                    <td colspan="95%">Brad Lushman</td>
                </tr>
                <tr>
                    <td colspan="5%">
                        <span class="headerLeft">Office:</span>
                    </td>
                    <td colspan="95%">DC3110</td>
                </tr>
                <tr>
                    <td colspan="5%">
                        <span class="headerLeft">Email:</span>
                    </td>
                    <td colspan="95%">brad.lushman@uwaterloo.ca</td>
                </tr>
                <tr>
                    <td colspan="5%">
                        <span class="headerLeft">Website:</span>
                    </td>
                    <td colspan="95%">
                        <a href="https://www.student.cs.uwaterloo.ca/~cs246/" target="_blank;">https://www.student.cs.uwaterloo.ca/~cs246/</a>
                    </td>
                </tr>
                <br>
                <tr>
                    <td colspan="95%"><span class="headerLeft">Note:</span></td>
                    <td>All program codes below are provided by Prof. Lushman in class.</td>
                </tr>
            </table>
            <hr>
                
            <div class="lec4">
                <h3>Lecture 4 - 19/09/2017</h3>
                <hr>
                <h4 class="title">Module 2 - C++ (Part 1)</h4>
                
                <p>Recall out first C program in CS136 - <b>helloWorld.c</b>:</p>
                <script src="https://gist.github.com/vertli/bf37f591f2da675b77219074ed7c9c15.js"></script>
                <p>Here is the C++ version:</p>
                <script src="https://gist.github.com/vertli/886b5694ccb9c4016d8b9ca7e615b348.js"></script>
                <p>
                    Note that the <code class="name">main</code> function <u>must</u> be return the type <code class="var">int</code> in C++.<br>
                    The <code class="name">stdio.h</code> and <code class="name">printf</code> are still available in C++.<br>
                    But of course, we should always use C++ I/O where we are coding with C++.<br>
                    The header for C++ I/O is <code class="name">iostream</code>.<br>
                    The output format is <code><span class="name">std::cout &lt;&lt; </span>(data) <span class="name"> &lt;&lt; </span>...<span class="name"> &lt;&lt; </span>(data)<span class="name"> &lt;&lt; </span><span class="name"> std::endl</span></code>.<br>
                    <code class="name">std::endl</code> means "end of line"; it is same as <code>\n</code> in C.<br>
                    If we add <code>using namespace <span class="name">std</span>;</code> after <code class="name">iostream</code>, then we can omit <code>std::</code>.<br>
                </p>
                <br>
                <p>
                    To compiling C++ programs, type <code>g++ -std=c++14 -Wall helloWorld.cc -o helloWorld</code> or <code>g++14 helloWorld.cc -o helloWorld</code>.<br>
                    <code>-o hello</code>: name of execute binary (default as <code>a.out</code>)<br>
                    Once you compile the program, then type <code>./helloWorld</code>.<br>
                    <br>
                    Again, C programs work in C++.<br><br>
                </p>
                <p>
                    <b>Input/Output</b><br>
                    There are three types of I/O streams:
                </p>
                <ul>
                    <li><code>cout</code>: for printing to <code>stdOut</code> (standard output)</li>
                    <li><code>cin&nbsp;&nbsp;</code>: for reading from <code>stdIn</code> (standard Input)</li>
                    <li><code>cerr</code>: for printing to <code>stdErr</code> (standard Error)</li>
                </ul>
                <br>
                <p><b>I/O Operators in C++:</b></p>
                <ul>
                    <li>
                        <code>&lt;&lt;</code>: "put to" (output)
                    </li>
                    <li>
                        <code>&gt;&gt;</code>: "get from" (input)
                    </li>
                    <li>
                        <code>cerr &gt;&gt; x</code> and <code>cerr &lt;&lt; x</code>: operatore "points" in the direction of information flow
                    </li>
                </ul>
                <br>
                <P>Example: Add 2 numbers:</P>
                <script src="https://gist.github.com/vertli/960f50a60ef8ae9c79d3613ffa256a72.js"></script>
                <p>
                    In line 8, the program will get two integers from StdIn and skipping whitespace.<br>
                    What if input does not contain an integer next?<br>
                    <li>The statement will fail and the variable will become either ) or maxInt or minInt.</li>
                    What if input is exhausted before we get two integers?
                    <li>Same as before...</li>
                    <br>
                    If the read failed: <code>cin.fail ()</code> will be true.<br>
                    If EOF <code>cin.eof ()</code> and <code>cin.fail ()</code> will be true, but not until the attempted read fails!<br>
                    <br>
                    Example: Read all integers from stdIn, echo them one per line, to stdOut; stop on bad input of EOF.
                </p>
                <script src="https://gist.github.com/vertli/e7d97917bb63be45032a2a2b08d982e9.js"></script>
                <p>    
                    Note: then there is am implicit conversion from <code>cin</code> to <code>bool</code>.<br>
                    Let <code>cin</code> be used as a condition: true for success and false for failure.<br><br>
                    Then... Here is the v2.0 for our example:
                </p>
                <script src="https://gist.github.com/vertli/8ba1443aa06cc5177389a8745f49f67f.js"></script>
                <p>
                    Note that <code>&gt;&gt;</code> is the right bitshift operator in C.<br>
                    <code>a &gt;&gt; b</code> means shifts <span class="var">a</span>'s bits to the right by <span class="var">b</span> spots.<br>
                    For example: <code>21 &gt;&gt; 3</code><br>
                    Since <code>21=10101<sub>2</sub></code>, we get <code>21 &gt;&gt; 3 = 10<sub>2</sub> = 2</code>.<br>
                    But when the left hand side is <code>cin</code>, <code>&gt;&gt;</code> is the "get from" operator.<br>
                    <br>
                    Operator <code>&gt;&gt;</code> inputs:
                    <li><code>cin</code> (type <code class="name">istream</code>)</li>
                    <li>data (several possible types)</li>
                    Output??? Returns <code>cin</code> in back (<code>istream</code>).
                    This is why we can write <code><span class="name">cin &gt;&gt; </span>x<span class="name"> &gt;&gt; </span>y<span class="name"> &gt;&gt; </span>z;</code>.<br><br>
                    V3.0 for our example...
                </p>
                <script src="https://gist.github.com/vertli/9866755ac5a138fd0a8a20564ac5145f.js"></script>
                <p>Lastly, V4.0 for our example:</p>
                <script src="https://gist.github.com/vertli/f9dc9292464f19c7ab764c4060c6874a.js"></script>
                <br>
                <p>
                    Example: Read all integers and echo to stdOut until EOF; skip non-integer input.
                </p>
                <script src="https://gist.github.com/vertli/e0a9e44a678a52d5b1a190ed44f9796e.js"></script>
            </div>
            <hr>
            
            <div class="lec5">
                <h3>Lecture 5 - 21/09/2017</h3>
                <hr>
                <P>
                    <b>Reading String</b><br>
                    type <code class="name">std::string (#include &lt;string&gt;)</code>: More details later.
                </P>
                <script src="https://gist.github.com/vertli/d3f503d84e120429c63c3973259ce035.js"></script>
                <p>
                    Line 7 will read a string, it skips leading whitespace and stops at whitespace (read one word only).<br><br>
                </p>
                <p>
                    What if we want the whitespace?<br>
                    Use <code>getline (cin, s)</code>.<br>
                    It will read from current position to text newline into <code>s</code>.<br>
                </p>
                <p>
                    Recall <code>cout &lt;&lt; 95 &lt;&lt; endl</code>; this will print out 95.<br>
                    What if we want to print a number in hexadecimal?<br>
                    Do <code>cout &lt;&lt; hex &lt;&lt; 95 &lt;&lt; end;</code>; this will prints out 5f.<br>
                    The <code>hex</code> is an I/O manipulator. After use it, all subsequent integers print in hexadecimal forever.<br>
                    To reset to decimal, use <code>cout &lt;&lt; dec</code>.<br>
                    For other manipulators, check <code>#include &lt;iomanip&gt;</code>.<br><br>
                </p>
                <p>
                    Stream abstraction applies to other sources of data.<br>
                    File - read from a file instead of <code>cin</code>.<br>
                    Using <code>std::ifstream</code> to read from a file and using <code>std::ofstream</code> wrtie to a file.<br>
                </p>
                <p>
                    File access in C:
                </p>
                <script src="https://gist.github.com/vertli/42a654534afa963149b0d37f92482b75.js"></script>
                <p>
                    Here is the C++ version:
                </p>
                <script src="https://gist.github.com/vertli/293759ce514d9c590ea0cd362e40de7c.js"></script>
                <p>Anything you can do with <code>cin/ cout</code>, you can do with an <code>ifstream / ofstream</code>.<br><br></p>
                <p>
                    String Example: Attach a stream to a string variable and read from/write to the string.<br>
                    <li><code>std::istringstream</code>: read from a string</li>
                    <li><code>std::ostringstream</code>: write to a string</li>
                    <br>
                    Solution:
                </p>
                <script src="https://gist.github.com/vertli/3208d6af553653235a3b076fe4aa1e97.js"></script>
                <br>
                <p>
                    Example: convert string to number.
                </p>
                <script src="https://gist.github.com/vertli/5fe7fc3d02a418e9d2c89d7fac6b84e6.js"></script>
                <br>
                <p>Example Revisited: Echo all numbers, skip non-numbers.</p>
                <script src="https://gist.github.com/vertli/608619f17dbe436a73f608c8902f8f66.js"></script>
                <p>
                    <b>Strings</b><br>
                    In C...
                    <li>array of char <code>(char* or char[])</code>, terminated by <code>\0</code></li>
                    <li>
                        must explicitly manage memory
                        <ul>
                            <li>allocate more memory as strings get larger</li>
                        </ul>
                    </li>
                    <li>easy to overwrite the <code>\0</code> and corrupt memory</li>
                    <br>
                    In C++...
                    <li>grow as needed (no need to manage memory)</li>
                    <li>safer to manipulate</li>
                    <br>Example: <code>string s = "Hello";</code><br>
                    <code>s</code> is the C++ string, creater from the C string.<br>
                    <code>"Hello"</code> is the C-style string (char array) <code>[H][e][l][l][o][\0]</code><br>
                </p>
                <p>
                    <b>String Operations</b>
                    <li>Equality: <code>s1 == s2;</code></li>
                    <li>Inequality: <code>s1 != s2;</code></li>
                    <li>Comparison (lexicographic): <code>s1 &lt;= s2;</code></li>
                    <li>Length: <code>slength();</code></li>
                    <li>Get individual chars: <code>s[0]  s[1]  s[2]  etc...</code></li>
                    <li>Concat: <code>s3 = s1 + s2;     s3 += s4;</code></li>
                    For more details, check the course notes in CS246 website.<br><br>
                </p>
                <p><b>Default Function Parameters:</b></p>
                    <script src="https://gist.github.com/vertli/3916d2778cf58129c9c21c0cf4679046.js"></script>
                <p>  
                    <strong>Note:</strong> Optional parameters must be <strong><u>LAST</u></strong>.
                </p>
                <br>
                <b>Overloading</b>
                <p>In C, we do...</p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>int negInt (int n) {return -n;}<br>
                        <span class="cline">02&nbsp;&nbsp;</span>bool negBool (bool b) {return !b;}<br>
                    </code></pre>
                </span>

                <p>In C++, we do...</p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>int neg (int n) {return -n;}<br>
                        <span class="cline">02&nbsp;&nbsp;</span>bool neg (bool b) {return !b;}<br>
                    </code></pre>
                </span>
                <p>
                    These two functions called <strong>overloading</strong>.<br>
                    <br>
                    Compiler uses number and types of arguments to decide which <code>neg()</code> is being called. - overload resolution<br>
                    Overloads must differ in number or ytpes of arguments - may not differ on just return type.<br>
                    <br>
                    We've seen this already: <code>&lt;&lt;</code> and <code>&gt;&gt;</code> are overloaded.<br>
                    The behaviour depends on types of arguments.<br>
                </p>
                <br>
                <b>Structs</b>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Node {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;int data;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;Node* next;<br>
                        <span class="cline">04&nbsp;&nbsp;</span>};<br>
                        <span class="cline">05&nbsp;&nbsp;</span>// don't forget the semicolon<br>
                    </code></pre>
                </span>
                <br>
                <b>Constants</b>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>const int maxGrade = 100; // must be initialled<br>
                    </code></pre>
                </span>
                <p>
                    Declare as many things <code>const</code> as you can - it helps catch erros!<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>Node n1 = {5, nullptr};<br>
                        <span class="cline">02&nbsp;&nbsp;</span>// use nullptr, no NOT use NULL or 0 in this class<br>
                        <span class="cline">03&nbsp;&nbsp;</span><br>
                        <span class="cline">04&nbsp;&nbsp;</span>const Node n2 = n1;<br>
                        <span class="cline">05&nbsp;&nbsp;</span>// immutable copy of n1 (n1 can change, but n2 not)<br>
                        <span class="cline">06&nbsp;&nbsp;</span><br>
                        <span class="cline">07&nbsp;&nbsp;</span>const Node *pn = &amp;n1;<br>
                        <span class="cline">08&nbsp;&nbsp;</span>// it can reassign n1 data, but it cannot reassign pn-&gt;data<br>
                        <span class="cline">09&nbsp;&nbsp;</span><br>
                        <span class="cline">10&nbsp;&nbsp;</span>Node *pn2 = &amp;n2;<br>
                        <span class="cline">11&nbsp;&nbsp;</span>// this does NOT work!<br>
                    </code></pre>
                </span>
                <p>
                    You can have constant pointer to non-constant.<br>
                    But you CANNOT have non-constant pointer to const.<br>
                </p>
            </div>
            <hr>
            
            <div class="lec6">
                <h3>Lecture 6 - 26/09/2017</h3>
                <hr>
                <b>Parameter Passing</b>
                <p>Recall:<br></p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>void inc (int n) {n = n + 1;}<br>
                        <span class="cline">02&nbsp;&nbsp;</span>...<br>
                        <span class="cline">03&nbsp;&nbsp;</span>int x = 5;<br>
                        <span class="cline">04&nbsp;&nbsp;</span>inc (x);<br>
                        <span class="cline">05&nbsp;&nbsp;</span>cout &lt;&lt; x; // we will get 5, not 6 here! Why?<br>
                    </code></pre>
                </span>
                <b>Pass-by-value</b>
                <p>
                    The function <code>inc()</code> gets a <u>copy</u> of <code>x</code>, the original unchanged.<br>
                    <br>
                    Solution: If a function needs to modify a parameter - pass a pointer.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>void inc (int *n) {*n = *n + 1;}<br>
                        <span class="cline">02&nbsp;&nbsp;</span>...<br>
                        <span class="cline">03&nbsp;&nbsp;</span>int x = 5;<br>
                        <span class="cline">04&nbsp;&nbsp;</span>inc (&amp;x);<br>
                        <span class="cline">05&nbsp;&nbsp;</span>cout &lt;&lt; x; // now, we will get 6 here.<br>
                    </code></pre>
                </span>
                <p>
                    Why <code>cin &gt;&gt; x</code> but not <code>cin &gt;&gt; (&amp;x)</code>?<br>
                    C++ has another pointer-like type: references!<br>
                </p>
                <br>
                <b>References - IMPORTANT!!!</b>
                <span>
                    <pre><code>
                        <span class="cline">02&nbsp;&nbsp;</span>int y = 10;<br>
                        <span class="cline">02&nbsp;&nbsp;</span>int &amp;z = y;<br>
                    </code></pre>
                </span>
                <p>
                    <code>z</code> is a <u>lvalue reference</u> to integer (to <code>y</code>).<br>
                    Reference is like a constant pointer.<br>
                    It is similar to <code>int* const z = &amp;y;</code><br>
                    References are like constant pointers with automatic dereferencing.
                </p>
                <img src="./image/cs246/lec6/Lec6_1.png" height="15%" width="15%">
                <p></p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>z = 12; // NOT *z = 12; <br>
                        <span class="cline">02&nbsp;&nbsp;</span>// now y = 12<br>
                        <span class="cline">03&nbsp;&nbsp;</span><br>
                        <span class="cline">04&nbsp;&nbsp;</span>int *p = &amp;z;<br>
                        <span class="cline">05&nbsp;&nbsp;</span>// &amp;z gives the address of y<br>
                    </code></pre>
                </span>
                <p>
                    In all cases, <code>z</code> behaves exactly like y.<br>
                    <code>z</code> is an <i>alias</i> ("another name") for y.<br>
                    <br>
                    Things you can't do with lvalue references:
                </p>
                <ul>
                    <li>
                        leave them uninitialized<br>
                        <ul>
                            <li>
                                <code>int &amp;x; // can't do this!</code>
                            </li>
                            <li>
                                must be initialized with something that has an address<br>
                                <ul>
                                    <li>
                                        <code>int &amp;x = 3; // can't do this!</code> 
                                    </li>
                                    <li>
                                        <code>int &amp;x = y + z; // can't do this!</code>
                                    </li>
                                    <li>
                                        <code>int &amp;x = y; // you are fine.</code>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>
                        create a pointer to a reference<br>
                        <ul>
                            <li>You want the pointer to the original thing...</li>
                            <li><code>int &amp;*x = ...; // do NOT do this!</code></li>
                            <li>
                                reference to pointer is okay.<br>
                                <code>int *&amp;x = ...; // this is fine ._.</code>
                            </li>
                        </ul>
                    </li>
                    <li>
                        create a reference to a reference<br>
                        <ul>
                            <li>You want the reference to the original thing...</li>
                            <li>
                                <code>int &amp;&amp;r = ...;</code>
                                <ul>
                                    <li>This means something different (you will see it later)</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>
                        create an array of reference<br>
                        <code>int &amp;r[3] = {..., ..., ...}; // can't do this!</code>
                    </li>
                </ul>
                <br>
                <p>
                    What <u>can</u> you do??? Pass as function parameters!<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>void inc (int &amp;n) {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;n = n + 1;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>}<br>
                    </code></pre>
                </span>
                <p>
                    The <code>&amp;n</code> here is the constant pointer to the argument(*), so changes to <code>n</code> affect <code>x</code>.<br>
                    Note that <code>n = n + 1;</code> is no pointer dereference.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>...<br>
                        <span class="cline">02&nbsp;&nbsp;</span>int x = 5;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>inc (x);<br>
                        <span class="cline">04&nbsp;&nbsp;</span>cout &gt;&gt; x; // you will get 6 here.<br>
                    </code></pre>
                </span>
                <p>
                    Why does <code>cin &gt;&gt; x</code> work?<br>
                    It takes <code>x</code> by reference.<br>
                    Example:<br>
                    <code>istream &amp;operator&gt;&gt; (istream &amp;in, int &amp;x);</code><br>
                    <br>
                </p>
                <b>Pass-by-value</b>
                <p>
                    Example: <code>int f (int n) {...}</code> copy the argument<br>
                    If the argument is big, copy is expensive.<br>
                    Example:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct ReallyBig {...};<br>
                        <span class="cline">02&nbsp;&nbsp;</span>int f (ReallyBig rb) {...}; // this is slow<br>
                        <span class="cline">03&nbsp;&nbsp;</span>int g (reallyBig &amp;rb) {...} // alias-fast, but could change rb in the caller<br>
                        <span class="cline">04&nbsp;&nbsp;</span>int h (const ReallyBig &amp;rb) {...} // fast, no copy, parameter will not change<br>
                    </code></pre>
                </span>
                <p>
                    <i>Advice:</i><br>
                    Prefer pass-by-const-value over pass-by-value for anything larger than a pointer, unless the function needs to make a copy anyway, then use pass-by-value.<br>
                    <br>
                    <i>Also:</i><br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>int f (int &amp;n) {...}<br>
                        <span class="cline">02&nbsp;&nbsp;</span>int g (const int &amp;n) {...}<br>
                        <span class="cline">03&nbsp;&nbsp;</span>f(5);<br>
                        <span class="cline">04&nbsp;&nbsp;</span>g(5);<br>
                    </code></pre>
                </span>
                <p>
                    For line 3...<br>
                    You can't do this! You can't initialize an lvalue reference (<code>n</code>) to a literal value. If <code>n</code> change, it can't change the literal 5.<br>
                    <br>
                    For line 4...<br>
                    This is okay. Since <code>n</code> can never be changed, compiler allows this.<br>
                    How? Compiler creates a <i>temporary</i> location in memory to hold the 5. Hence, the reference <code>n</code> has something to point at.<br>
                </p>
                <br>
                <b>Dynamic Memory Allocation</b>
                <p>In C...</p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>int *p = malloc (... * sizeof(int));<br>
                        <span class="cline">02&nbsp;&nbsp;</span>...<br>
                        <span class="cline">03&nbsp;&nbsp;</span>free(p);<br>
                    </code></pre>
                </span>
                <p>
                    Good news: do NOT use these in C++!<br>
                    Bad news: C++ has it own way to do it...<br>
                    The keywords are <code>new</code> and <code>delete</code>.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>// type-aware, less error-prone<br>
                        <span class="cline">02&nbsp;&nbsp;</span>struct Node {<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;int data;<br>
                        <span class="cline">04&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;Node *next;<br>
                        <span class="cline">05&nbsp;&nbsp;</span>};<br>
                        <span class="cline">06&nbsp;&nbsp;</span>Node *np = new Node;<br>
                        <span class="cline">07&nbsp;&nbsp;</span>...<br>
                        <span class="cline">08&nbsp;&nbsp;</span>delete np;<br>
                    </code></pre>
                </span>
                <img src="./image/cs246/lec6/Lec6_2.png" height="15%" width="15%">
                <p>
                    All local variables reside on the <u>heap</u>.<br>
                    Variables deallocated when they go out of scope (stack is popped).<br>
                    <br>
                    Allocated memory resides on the <i>heap</i>.<br>
                    Remains allocated until <code>delete</code> is called.<br>
                    If you don't delete all allocated memory... Memory Leak!!!<br>
                    The program will eventually fail and this is incorrect behaviour.<br>
                    <br>
                    Example:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>Node getMeANode () {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;Node n;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;return n;<br>
                        <span class="cline">04&nbsp;&nbsp;</span>}<br>
                    </code></pre>
                </span>
                <p>
                    This is expensive.<br>
                    <code>n</code> is copied to caller's stack frame on return.<br>
                    How about return a pointer (or reference) instead?<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>Node &amp;getMeANode () {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;Node n;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;return n;<br>
                        <span class="cline">04&nbsp;&nbsp;</span>}<br>
                    </code></pre>
                </span>
                <p>
                    It's fast, but... This is DANGEROUS! You should NOT do it.<br>
                    It will return a reference to stack, allocated data, which is dead on return.<br>
                    Hence, do NOT return a pointer to a location data.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>Node *getMeANode () {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;return new Node;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>}<br>
                    </code></pre>
                </span>
                <p>
                    This is fast and safe.<br>
                    It returns a pointer to the heap. (The pointer is still alive!)<br>
                    But don't forget to delete it when done!<br>
                </p>
                <br>
                <b>Operator Overloading</b>
                <p>
                    Give meaning to C++ operators for new types.<br>
                    Example:<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Vec {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;int x, y;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>}<br>
                        <span class="cline">04&nbsp;&nbsp;</span><br>
                        <span class="cline">05&nbsp;&nbsp;</span>Vec operator+ (const Vec &amp;v1, const Vec &v2) {<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;Vec v {v1.x + v2.x, v1.y + v2.y};<br>
                        <span class="cline">07&nbsp;&nbsp;</span>}<br>
                        <span class="cline">08&nbsp;&nbsp;</span><br>
                        <span class="cline">09&nbsp;&nbsp;</span>Vec operator* (const int k, const Vec &amp;v1) {<br>
                        <span class="cline">10&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;return {k * v1.x, k * v1.y};<br>
                        <span class="cline">11&nbsp;&nbsp;</span>}<br>
                    </code></pre>
                </span>
                <p>
                    The <code>operator*</code> is okay because the compiler knows it's creating a <code>Vec</code>, based on the return type.<br>
                </p>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>// Another version<br>
                        <span class="cline">02&nbsp;&nbsp;</span>Vec operator* (const Vec &amp;v1, const int k) {<br>
                        <span class="cline">03&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;return k * v1;<br>
                        <span class="cline">04&nbsp;&nbsp;</span>}<br>
                    </code></pre>
                </span>
                <br>
                <b>Overloading &lt;&lt; and &gt;&gt;</b>
                <span>
                    <pre><code>
                        <span class="cline">01&nbsp;&nbsp;</span>struct Grade {<br>
                        <span class="cline">02&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;int theGrade;<br>
                        <span class="cline">03&nbsp;&nbsp;</span>};<br>
                        <span class="cline">04&nbsp;&nbsp;</span><br>
                        <span class="cline">05&nbsp;&nbsp;</span>ostream &amp;operator&lt;&lt; (ostream &amp;out, const Grade &amp;g) {<br>
                        <span class="cline">06&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;out &lt;&lt; g.theGrade &lt;&lt; '%';<br>
                        <span class="cline">07&nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;return out;<br>
                        <span class="cline">08&nbsp;&nbsp;</span>}<br>
                    </code></pre>
                </span>
                <br>
                <h4 class="title">Module 2 - C++ (Part 1)</h4>
                <h5 class="title">The End</h5>
            </div>
            <hr>         
            
            <table width="100%">
                <tr>
                    <td width="45%"><a href="./cs246_1.html">&larr; Go to Module 1 - The Shell</a></td>
                    <td width="10%" align="centre"><a href="./cs246.html">&uarr; Go to Index</a></td>
                    <td width="45%" align="right"><a href="./cs246_3.html">&rarr; Go to Module 3 - C++ (Part 2) and Introduction to OOP&nbsp;</a></td>
                </tr>
            </table>
            
            <div class="footer">
                <p>Thanks For Coming Here. - Calvin Li</p>
                <a href = "mailto: ck6li@edu.uwaterloo.ca" target = "_blank;">
                    <i class = "fa fa-envelope-square"></i>
                </a>
                <a href = "https://www.linkedin.com/in/vertckli/" target = "_blank;">
                    <i class = "fa fa-linkedin-square"></i>
                </a>       
                <a href = "https://www.instagram.com/vert_arts/" target = "_blank;">
                    <i class="fa fa-instagram"></i>
                </a>
                <a href = "https://github.com/vertli" target = "_blank;">
                    <i class="fa fa-github-square"></i>
                </a>
                <br>
                <p>Chun Kit (Calvin) Li &copy; 2017</p>
                <br>
            </div>
        </div>
        <script src="https://code.jquery.com/jquery-2.1.4.js"></script>
        <script src="./bootstrap-3.3.7-dist/js/bootstrap.js"></script>
    </body>
    
</html>