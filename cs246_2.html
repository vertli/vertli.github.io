<!DOCTYPE html>

<html>

    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>CS246|Calvin Li</title>
        <link rel="stylesheet" href="./css/style.css">
        <link rel="stylesheet" href="./css/notes.css">
        <link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/hack-font/build/web/hack.css'> <!-- HACK!!! -->
        <link rel="stylesheet" href="./css/font-awesome-5.8.1/all.css" />
        <!-- Code Display use -->
        <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?skin=desert"></script>
        <link rel="stylesheet" href="./css/skin.css">
    </head>
    
    <body onload="restHeight('about')" onresize="location.reload()>
        <div class="topnav" id="myTopnav">
            <a href="./index.html" class="active">Calvin Li</a>
            <a href="./about.html">About</a>
            <a href="./projects.html">Projects</a>
            <a href="./arts.html">Arts</a>
            <a href="./contact.html">Contact</a>
            <div class="topnav-right">
              <a href="./doc/NewResume_CKLI.pdf">Résumé</a>
            </div>
            <a href="javascript:void(0);" class="icon" onclick="navbarUse()">
              <i class="fa fa-bars"></i>
            </a>
        </div>
        
        <div class="container">
            <div class="row">
                <div class="col=12">
                    <table class="header">
                        <tr>
                            <td colspan="100%">
                                <h1 class="title">CS 246 - Object-Oriented Development</h1>
                            </td>
                        </tr>
                        <tr>
                            <th colspan="5%">Instructor:</th>
                            <td colspan="95%">Brad Lushman</td>
                        </tr>
                        <tr>
                            <th colspan="5%">Office:</th>
                            <td colspan="95%">DC3110</td>
                        </tr>
                        <tr>
                            <th colspan="5%">Email:</th>
                            <td colspan="95%"><a href = "mailto: brad.lushman@uwaterloo.ca" target = "_blank;">brad.lushman@uwaterloo.ca</a></td>
                        </tr>
                        <tr>
                            <th colspan="5%">Website:</th>
                            <td colspan="95%">
                                <a href="https://www.student.cs.uwaterloo.ca/~cs246/" target="_blank;">https://www.student.cs.uwaterloo.ca/~cs246/</a>
                            </td>
                        </tr>
                        <tr>
                            <th colspan="5%">Note:</th>
                            <td>All program codes below are provided by Prof. Lushman during class.</td>
                        </tr>
                    </table>
                </div>
            </div>
            <hr>
            <div class="row">
                <div class="col-12">
                    <div class="lec4">
                        <h3>Lecture 4 - 19/09/2017</h3>
                        <hr>
                        <h4 class="title">Module 2 - C++ (Part 1)</h4>
                        
                        <p>Recall out first C program in CS136 - <b>helloWorld.c</b>:</p>
<pre class="prettyprint linenums lang-c">#include &lt;stdio.h&gt;
int main () {
  printf(“Hello, World!\n”);
  return 0;
}</pre>
                        <p>Here is the C++ version:</p>
<pre class="prettyprint linenums lang-cpp">#include &lt;iostream&gt;
using namespace std;

int main () {
  cout &lt;&lt; "Hello world" &lt;&lt; endl;
  return 0;
}</pre>
                        <p>
                            Note that the <code class="name">main</code> function <u>must</u> be return the type <code class="var">int</code> in C++.<br>
                            The <code class="name">stdio.h</code> and <code class="name">printf</code> are still available in C++.<br>
                            But of course, we should always use C++ I/O where we are coding with C++.<br>
                            The header for C++ I/O is <code class="name">iostream</code>.<br>
                            The output format is <code><span class="name">std::cout &lt;&lt; </span>(data) <span class="name"> &lt;&lt; </span>...<span class="name"> &lt;&lt; </span>(data)<span class="name"> &lt;&lt; </span><span class="name"> std::endl</span></code>.<br>
                            <code class="name">std::endl</code> means "end of line"; it is same as <code>\n</code> in C.<br>
                            If we add <code>using namespace <span class="name">std</span>;</code> after <code class="name">iostream</code>, then we can omit <code>std::</code>.
                        </p>
                        <p>
                            To compiling C++ programs, type <code>g++ -std=c++14 -Wall helloWorld.cc -o helloWorld</code> or <code>g++14 helloWorld.cc -o helloWorld</code>.<br>
                            <code>-o hello</code>: name of execute binary (default as <code>a.out</code>)<br>
                            Once you compile the program, then type <code>./helloWorld</code>.<br>
                            <br>
                            Again, C programs work in C++.<br>
                        </p>
                        <p>
                            <b>Input/Output</b><br>
                            There are three types of I/O streams:
                        </p>
                        <ul>
                            <li><code>cout</code>: for printing to <code>stdOut</code> (standard output)</li>
                            <li><code>cin&nbsp;</code>: for reading from <code>stdIn</code> (standard Input)</li>
                            <li><code>cerr</code>: for printing to <code>stdErr</code> (standard Error)</li>
                        </ul>
                        <br>
                        <p><b>I/O Operators in C++:</b></p>
                        <ul>
                            <li><code>&lt;&lt;</code>: "put to" (output)</li>
                            <li><code>&gt;&gt;</code>: "get from" (input)</li>
                            <li><code>cerr &gt;&gt; x</code> and <code>cerr &lt;&lt; x</code>: operatore "points" in the direction of information flow</li>
                        </ul>
                        <br>
                        <P>Example: Add 2 numbers:</P>
<pre class="prettyprint linenums lang-cpp">#include &lt;iostream&gt;
using namespace std;
// We will omit the above lines for now on (understood)

int main () {
  int x, y;
  cin &gt;&gt; x &gt;&gt; y;// ignore whitespace
  cout &lt;&lt; x + y &lt;&lt; endl;
}</pre>
                        <p>
                            In line 8, the program will get two integers from StdIn and skipping whitespace.<br>
                            What if input does not contain an integer next?<br>
                            <li>The statement will fail and the variable will become either 0 or maxInt or minInt.</li>
                            What if input is exhausted before we get two integers?
                            <li>Same as before...</li>
                            <br>
                            If the read failed: <code>cin.fail ()</code> will be true.<br>
                            If EOF <code>cin.eof ()</code> and <code>cin.fail ()</code> will be true, but not until the attempted read fails!<br>
                            <br>
                            Example: Read all integers from stdIn, echo them one per line, to stdOut; stop on bad input of EOF.
                        </p>
<pre class="prettyprint linenums lang-cpp">#include &lt;iostream&gt;
using namespace std;

int main () {
  int i;
  while (true) {
      cin &gt;&gt; i;
      if (cin.fail()) break;
      cout &lt;&lt; i &lt;&lt; endl;
    }
}</pre>
                        <p>    
                            Note: then there is am implicit conversion from <code>cin</code> to <code>bool</code>.<br>
                            Let <code>cin</code> be used as a condition: true for success and false for failure.<br><br>
                            Then... Here is the v2.0 for our example:
                        </p>
<pre class="prettyprint linenums lang-cpp">#include &lt;iostream&gt;
using namespace std;

int main () {
    int i;
    while (true) {
        cin >> i;
        if (!cin) break;
        cout &lt;&lt; i &lt;&lt; endl;
    }
}</pre>
                        <p>
                            Note that <code>&gt;&gt;</code> is the right bitshift operator in C.<br>
                            <code>a &gt;&gt; b</code> means shifts <span class="var">a</span>'s bits to the right by <span class="var">b</span> spots.<br>
                            For example: <code>21 &gt;&gt; 3</code><br>
                            Since <code>21=10101<sub>2</sub></code>, we get <code>21 &gt;&gt; 3 = 10<sub>2</sub> = 2</code>.<br>
                            But when the left hand side is <code>cin</code>, <code>&gt;&gt;</code> is the "get from" operator.<br>
                            <br>
                            Operator <code>&gt;&gt;</code> inputs:
                            <li><code>cin</code> (type <code class="name">istream</code>)</li>
                            <li>data (several possible types)</li>
                            Output??? Returns <code>cin</code> in back (<code>istream</code>).
                            This is why we can write <code><span class="name">cin &gt;&gt; </span>x<span class="name"> &gt;&gt; </span>y<span class="name"> &gt;&gt; </span>z;</code>.<br><br>
                            V3.0 for our example...
                        </p>
<pre class="prettyprint linenums lang-cpp">#include &lt;iostream&gt;
using namespace std;

int main () {
    int i;
    while (true) {
        if (!(cin &gt;&gt; i)) break;
        cout &lt;&lt; i &lt;&lt; endl;
    }
}</pre>
                        <p>Lastly, V4.0 for our example:</p>
<pre class="prettyprint linenums lang-cpp">#include &lt;iostream&gt;
using namespace std;

int main () {
    int i;
    while (true) {
        if (cin &gt;&gt; i) break;
        cout &lt;&lt; i &lt;&lt; endl;
    }
}</pre>
                        <p>
                            Example: Read all integers and echo to stdOut until EOF; skip non-integer input.
                        </p>
<pre class="prettyprint linenums lang-cpp">#include &lt;iostream&gt;
using namespace std;

int main () {
    int i;
    while (true) {
        if (!(cin &gt;&gt; i)) {
            if (cin.eof()) break;
            cin.clear (); // reset the fail flag
            cin.ignore (); // skip a char
        } else { // read was ok
            cout &lt;&lt; i &lt;&lt; endl;
        }
    }
}</pre>
                    </div>
                </div>
            </div>
            <hr>
            <div class="row">
                <div class="col-12">
                    <div class="lec5">
                        <h3>Lecture 5 - 21/09/2017</h3>
                        <hr>
                        <P>
                            <b>Reading String</b><br>
                            type <code class="name">std::string (#include &lt;string&gt;)</code>: More details later.
                        </P>
<pre class="prettyprint linenums lang-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
    
int main () {
    string s;
    cin &gt;&gt; s;
    cout &lt;&lt; s &lt;&lt; endl;
}</pre>
                        <p>Line 7 will read a string, it skips leading whitespace and stops at whitespace (read one word only).</p>
                        <p>
                            What if we want the whitespace?<br>
                            Use <code>getline (cin, s)</code>.<br>
                            It will read from current position to text newline into <code>s</code>.
                        </p>
                        <p>
                            Recall <code>cout &lt;&lt; 95 &lt;&lt; endl</code>; this will print out 95.<br>
                            What if we want to print a number in hexadecimal?<br>
                            Do <code>cout &lt;&lt; hex &lt;&lt; 95 &lt;&lt; end;</code>; this will prints out 5f.<br>
                            The <code>hex</code> is an I/O manipulator. After use it, all subsequent integers print in hexadecimal forever.<br>
                            To reset to decimal, use <code>cout &lt;&lt; dec</code>.<br>
                            For other manipulators, check <code>#include &lt;iomanip&gt;</code>.
                        </p>
                        <p>
                            Stream abstraction applies to other sources of data.<br>
                            File - read from a file instead of <code>cin</code>.<br>
                            Using <code>std::ifstream</code> to read from a file and using <code>std::ofstream</code> wrtie to a file.
                        </p>
                        <p>File access in C:</p>
 <pre class="prettyprint linenums lang-c">#include &lt;stdio.h&gt;

int main() {
    char s[256];
    FILE *f = fopen (“suite.txt”, “r”);
    while (ture) {
        fscanf (f, “%255 s”, s);
        if (feof(f)) break:
        printf(“%s\n”, s);
    }
    fclose (f);
}</pre>
                        <p>Here is the C++ version:</p>
<pre class="prettyprint linenums lang-cpp">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
using namespace std;

int main() {
    ifstream f {“suite.txt”};    // defining an ifstream opens the file
    string s;
    while (f >> s) {
    cout &lt;&lt; s &lt;&lt; endl;
    }
    // file is closed when the variable f goes out of scope
}</pre>
                        <p>Anything you can do with <code>cin/ cout</code>, you can do with an <code>ifstream / ofstream</code>.<br><br></p>
                        <p>
                            String Example: Attach a stream to a string variable and read from/write to the string.<br>
                            <li><code>std::istringstream</code>: read from a string</li>
                            <li><code>std::ostringstream</code>: write to a string</li>
                            <br>
                            Solution:
                        </p>
<pre class="prettyprint linenums lang-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;

int main () {
    int hi = 100;
    int lo = 1;
    ostringstream oss;
    oss &lt;&lt; “Enter a number between “ &lt;&lt; lo &lt;&lt; “ and “ &lt;&lt; hi;
    string s = oss.str();
    cout &lt;&lt; s &lt;&lt; endl;
}</pre>
                        <p>Example: convert string to number.</p>
<pre class="prettyprint linenums lang-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;

int main () {
    int n;
    while (true) {
      cout &lt;&lt; "Enter a number" &lt;&lt; endl;
      string s;
      cin >> s;
      istringstream iss{s};
      if (iss >> n) break;
      cout &lt;&lt; "I said, ";
    }
    cout &lt;&lt; "You entered " &lt;&lt; n &lt;&lt; endl;
  }</pre>
                        <p>Example Revisited: Echo all numbers, skip non-numbers.</p>
<pre class="prettyprint linenums lang-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;

int main () {
    string s;
    while (cin >> s) {
      istringstream iss{s};
      int n;
      if (iss >> n) cout &lt;&lt; n &lt;&lt; endl; 
    } // end while
  } // end main</pre>
                        <p>
                            <b>Strings</b><br>
                            In C...
                            <li>array of char <code>(char* or char[])</code>, terminated by <code>\0</code></li>
                            <li>
                                must explicitly manage memory
                                <ul>
                                    <li>allocate more memory as strings get larger</li>
                                </ul>
                            </li>
                            <li>easy to overwrite the <code>\0</code> and corrupt memory</li>
                            <br>
                            In C++...
                            <li>grow as needed (no need to manage memory)</li>
                            <li>safer to manipulate</li>
                            <br>Example: <code>string s = "Hello";</code><br>
                            <code>s</code> is the C++ string, creater from the C string.<br>
                            <code>"Hello"</code> is the C-style string (char array) <code>[H][e][l][l][o][\0]</code><br>
                        </p>
                        <p>
                            <b>String Operations</b>
                            <li>Equality: <code>s1 == s2;</code></li>
                            <li>Inequality: <code>s1 != s2;</code></li>
                            <li>Comparison (lexicographic): <code>s1 &lt;= s2;</code></li>
                            <li>Length: <code>slength();</code></li>
                            <li>Get individual chars: <code>s[0]  s[1]  s[2]  etc...</code></li>
                            <li>Concat: <code>s3 = s1 + s2;     s3 += s4;</code></li>
                            For more details, check the course notes in CS246 website.<br><br>
                        </p>
                        <p><b>Default Function Parameters:</b></p>
<pre class="prettyprint linenums lang-cpp">#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;

void printSuiteFile(string name = "suite.txt") {
    ifstream f{name};
    string s;
    while (f >> s) cout &lt;&lt; s &lt;&lt; endl;
} // end printSuiteFile()

int main() {
    printSuiteFile("suite2.txt");
    printSuiteFile();
} // end main()</pre>
                        <p>  
                            <strong>Note:</strong> Optional parameters must be <strong><u>LAST</u></strong>.
                        </p>
                        <br>
                        <b>Overloading</b>
                        <p>In C, we do...</p>
<pre class="prettyprint linenums lang-c">int negInt(int n) {return -n;}
bool negBool(bool b) {return !b;}</pre>
        
                        <p>In C++, we do...</p>
<pre class="prettyprint linenums lang-cpp">int neg(int n) {return -n;}
bool neg(bool b) {return !b;}</pre>

                        <p>
                            These two functions called <strong>overloading</strong>.<br>
                            <br>
                            Compiler uses number and types of arguments to decide which <code>neg()</code> is being called. - overload resolution<br>
                            Overloads must differ in number or types of arguments - may not differ on just return type.<br>
                            <br>
                            We've seen this already: <code>&lt;&lt;</code> and <code>&gt;&gt;</code> are overloaded.<br>
                            The behaviour depends on types of arguments.<br>
                        </p>
                        <br>

                        <b>Structs</b>
<pre class="prettyprint linenums lang-cpp">struct Node {
    int data;
    Node* next;
}; // don't forget the semicolon</pre>
                        <br>

                        <b>Constants</b>
<pre class="prettyprint linenums lang-cpp">const int maxGrade = 100; // must be initialled</pre>

                        <p>
                            Declare as many things <code>const</code> as you can - it helps catch erros!<br>
                        </p>
<pre class="prettyprint linenums lang-cpp">Node n1 = {5, nullptr};
// use nullptr, no NOT use NULL or 0 in this class

const Node n2 = n1;
// immutable copy of n1 (n1 can change, but n2 not)

const Node *pn = &amp;n1;
// it can reassign n1 data, but it cannot reassign pn-&gt;data

Node *pn2 = &amp;n2;
// this does NOT work!</pre>
                        <p>
                            You can have constant pointer to non-constant.<br>
                            But you CANNOT have non-constant pointer to const.<br>
                        </p>
                    </div>
                </div>
            </div>
            <hr>
            <div class="row">
                <div class="col-12">
                    <div class="lec6">
                        <h3>Lecture 6 - 26/09/2017</h3>
                        <hr>
                        <b>Parameter Passing</b>
                        <p>Recall:<br></p>
<pre class="prettyprint linenums lang-cpp">void inc(int n) {n = n + 1;}
...
int x = 5;
inc(x);
cout &lt;&lt; x; // we will get 5, not 6 here! Why?</pre>

                        <b>Pass-by-value</b>
                        <p>
                            The function <code>inc()</code> gets a <u>copy</u> of <code>x</code>, the original unchanged.<br>
                            <br>
                            Solution: If a function needs to modify a parameter - pass a pointer.
                        </p>
<pre class="prettyprint linenums lang-cpp">void inc(int *n) {*n = *n + 1;}
...
int x = 5;
inc(&amp;x);
cout &lt;&lt; x; // now, we will get 6 here</pre>
                        <p>
                            Why <code>cin &gt;&gt; x</code> but not <code>cin &gt;&gt; (&amp;x)</code>?<br>
                            C++ has another pointer-like type: references!<br>
                        </p>
                        <br>
                        <b>References - IMPORTANT!!!</b>
<pre class="prettyprint linenums lang-cpp">int y = 10;
int &amp;z = y;</pre>
                        <p>
                            <code>z</code> is a <u>lvalue reference</u> to integer (to <code>y</code>).<br>
                            Reference is like a constant pointer.<br>
                            It is similar to <code>int* const z = &amp;y;</code><br>
                            References are like constant pointers with automatic dereferencing.
                        </p>
                        <img src="./img/cs246/lec6/Lec6_1.png" height="15%" width="15%">

 <pre class="prettyprint linenums lang-cpp">z = 12; // NOT *z = 12;
// now y = 12

int *p = &amp;z;
// &amp;z gives the address of y
</pre>
                        <p>In all cases, <code>z</code> behaves exactly like y.<br>
                            <code>z</code> is an <i>alias</i> ("another name") for y.<br>
                            <br>
                            Things you can't do with lvalue references:
                        </p>
                        <ul>
                            <li>
                                leave them uninitialized<br>
                                <ul>
                                    <li>
                                        <code>int &amp;x; // can't do this!</code>
                                    </li>
                                    <li>
                                        must be initialized with something that has an address<br>
                                        <ul>
                                            <li>
                                                <code>int &amp;x = 3; // can't do this!</code> 
                                            </li>
                                            <li>
                                                <code>int &amp;x = y + z; // can't do this!</code>
                                            </li>
                                            <li>
                                                <code>int &amp;x = y; // you are fine.</code>
                                            </li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li>
                                create a pointer to a reference<br>
                                <ul>
                                    <li>You want the pointer to the original thing...</li>
                                    <li><code>int &amp;*x = ...; // do NOT do this!</code></li>
                                    <li>
                                        reference to pointer is okay.<br>
                                        <code>int *&amp;x = ...; // this is fine ._.</code>
                                    </li>
                                </ul>
                            </li>
                            <li>
                                create a reference to a reference<br>
                                <ul>
                                    <li>You want the reference to the original thing...</li>
                                    <li>
                                        <code>int &amp;&amp;r = ...;</code>
                                        <ul>
                                            <li>This means something different (you will see it later)</li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li>
                                create an array of reference<br>
                                <code>int &amp;r[3] = {..., ..., ...}; // can't do this!</code>
                            </li>
                        </ul>
                        <br>
                        <p>
                            What <u>can</u> you do??? Pass as function parameters!<br>
                        </p>
<pre class="prettyprint linenums lang-cpp">void inc (int &amp;n) {
  n = n + 1;
}</pre>
                        <p>
                            The <code>&amp;n</code> here is the constant pointer to the argument(*), so changes to <code>n</code> affect <code>x</code>.<br>
                            Note that <code>n = n + 1;</code> is no pointer dereference.<br>
                        </p>
<pre class="prettyprint linenums lang-cpp">...
int x = 5;
inc(x);
cout &gt;&gt; x; // you will get 6 here</pre>
                        <p>
                            Why does <code>cin &gt;&gt; x</code> work?<br>
                            It takes <code>x</code> by reference.<br>
                            Example:<br>
                            <code>istream &amp;operator&gt;&gt; (istream &amp;in, int &amp;x);</code><br>
                            <br>
                        </p>
                        <b>Pass-by-value</b>
                        <p>
                            Example: <code>int f (int n) {...}</code> copy the argument<br>
                            If the argument is big, copy is expensive.<br>
                            Example:<br>
                        </p>
<pre class="prettyprint linenums lang-cpp">struct ReallyBig {...};
int f(ReallyBig rb) {...}; // this is slow
int g(reallyBig &amp;rb) {...} // alias-fast, but could change rb in the caller
int h(const ReallyBig &amp;rb) {...} // fast, no copy, parameter will not change</pre>

                        <p>
                            <i>Advice:</i><br>
                            Prefer pass-by-const-value over pass-by-value for anything larger than a pointer, unless the function needs to make a copy anyway, then use pass-by-value.<br>
                            <br>
                            <i>Also:</i><br>
                        </p>
<pre class="prettyprint linenums lang-cpp">int f(int &amp;n) {...}
int g(const int &amp;n) {...}
f(5);
g(5);</pre>

                        <p>
                            For line 3...<br>
                            You can't do this! You can't initialize an lvalue reference (<code>n</code>) to a literal value. If <code>n</code> change, it can't change the literal 5.<br>
                            <br>
                            For line 4...<br>
                            This is okay. Since <code>n</code> can never be changed, compiler allows this.<br>
                            How? Compiler creates a <i>temporary</i> location in memory to hold the 5. Hence, the reference <code>n</code> has something to point at.<br>
                        </p>
                        <br>
                        <b>Dynamic Memory Allocation</b>
                        <p>In C...</p>
 <pre class="prettyprint linenums lang-c">int *p = malloc(... * sizeof(int));
...
free(p);
</pre>
                        <p>
                            Good news: do NOT use these in C++!<br>
                            Bad news: C++ has it own way to do it...<br>
                            The keywords are <code>new</code> and <code>delete</code>.<br>
                        </p>
<pre class="prettyprint linenums lang-cpp">// type-aware, less error-prone
struct Node {
    int data;
    Node *next;
};
Node *np = new Node;
...
delete np;</pre>
                        <img src="./img/cs246/lec6/Lec6_2.png" height="15%" width="15%">
                        <p>
                            All local variables reside on the <u>heap</u>.<br>
                            Variables deallocated when they go out of scope (stack is popped).<br>
                            <br>
                            Allocated memory resides on the <i>heap</i>.<br>
                            Remains allocated until <code>delete</code> is called.<br>
                            If you don't delete all allocated memory... Memory Leak!!!<br>
                            The program will eventually fail and this is incorrect behaviour.<br>
                            <br>
                            Example:<br>
                        </p>
<pre class="prettyprint linenums lang-cpp">Node getMeANode () {
    Node n;
    return n;
}</pre>
                        <p>
                            This is expensive.<br>
                            <code>n</code> is copied to caller's stack frame on return.<br>
                            How about return a pointer (or reference) instead?
                        </p>
<pre class="prettyprint linenums lang-cpp">Node &amp;getMeANode () {
    Node n;
    return n;
}</pre>
                        <p>
                            It's fast, but... This is DANGEROUS! You should NOT do it.<br>
                            It will return a reference to stack, allocated data, which is dead on return.<br>
                            Hence, do NOT return a pointer to a location data.
                        </p>
<pre class="prettyprint linenums lang-cpp">Node *getMeANode () {
    return new Node;
}</pre>
                        <p>
                            This is fast and safe.<br>
                            It returns a pointer to the heap. (The pointer is still alive!)<br>
                            But don't forget to delete it when done!
                        </p>
                        <br>
                        <b>Operator Overloading</b>
                        <p>
                            Give meaning to C++ operators for new types.<br>
                            Example:<br>
                        </p>
<pre class="prettyprint linenums lang-cpp">struct Vec {
    int x, y;
}

>Vec operator+(const Vec &amp;v1, const Vec &amp;v2) {
    Vec v{v1.x + v2.x, v1.y + v2.y};
}

Vec operator*(const int k, const Vec &amp;v1) {
    return {k * v1.x, k * v1.y};
}</pre>
                        <p>The <code>operator*</code> is okay because the compiler knows it's creating a <code>Vec</code>, based on the return type.</p>
<pre class="prettyprint linenums lang-cpp">// Another version
Vec operator*(const Vec &amp;v1, const int k) {
    return k * v1;
}</pre>
                        <br>
                        <b>Overloading &lt;&lt; and &gt;&gt;</b>
<pre class="prettyprint linenums lang-cpp">struct Grade {
    int theGrade;
};

ostream &amp;operator&lt;&lt; (ostream &amp;out, const Grade &amp;g) {
    out &lt;&lt; g.theGrade &lt;&lt; '%';
    &nbsp;&nbsp;return out;
}</pre>
                        <br>
                        <h4 class="title">Module 2 - C++ (Part 1)</h4>
                        <h5 class="title">The End</h5>
                    </div>
                </div>
            </div>
            <hr>         
            <div class="row">
                <div class="col-12">
                    <table class="buttomTable">
                        <tr>
                            <td class="buttomLeftTable"><a href="./cs246_1.html">&larr; Go to Module 1 - The Shell</a></td>
                            <td class="buttomCentreTable"><a href="./cs246.html">&uarr; Go to Index</a></td>
                            <td class="buttomRightTable"><a href="./cs246_3.html">&rarr; Go to Module 3 - C++ (Part 2) and Introduction to OOP&nbsp;</a></td>
                        </tr>
                    </table>
                    <hr>
                    <p>Find a typo or mistake? Feel free to contact me and I will correct it as soon as possible.</p>
                </div>
            </div>
            <footer id="footer">
                <p>Thanks For Coming. - Vert Li</p>
                 <!-- icons -->
                <a href="mailto: vert.c.k.li@gmail.com" target="_blank;">
                    <i class="fas fa-envelope-square fa-2x"></i>
                </a>
                <a href="https://www.linkedin.com/in/vertckli/" target="_blank;">
                    <i class="fab fa-linkedin fa-2x"></i>
                </a>
                <a href="https://www.instagram.com/vert_arts/" target="_blank;">
                    <i class="fab fa-instagram fa-2x"></i>
                </a>
                <a href="https://github.com/vertli" target="_blank;">
                    <i class="fab fa-github-square fa-2x"></i>
                </a>
                <!-- icons -->
                <p>Chun Kit (Calvin Vert) Li &copy; 2017 - 2020</p>
            </footer>
        </div>

        <script src="./js/style.js"></script>
        <script src="./js/height.js"></script>
    </body>
    
</html>